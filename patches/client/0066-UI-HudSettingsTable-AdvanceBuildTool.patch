From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Wed, 1 May 2024 16:09:53 +0800
Subject: [PATCH] UI: HudSettingsTable, AdvanceBuildTool
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

整理差不多了，从ARC拆分

更新整理HudSettingsTable
way-zer <himc.wicp@gmail.com> on 2024/6/10 at 14:28
---
 core/src/mindustryX/features/UIExt.java       |   9 +
 .../features/ui/AdvanceBuildTool.java         | 450 ++++++++++++++++++
 .../features/ui/HudSettingsTable.java         | 229 +++++++++
 .../mindustryX/features/ui/ToolTableBase.java |  24 +
 4 files changed, 712 insertions(+)
 create mode 100644 core/src/mindustryX/features/ui/AdvanceBuildTool.java
 create mode 100644 core/src/mindustryX/features/ui/HudSettingsTable.java
 create mode 100644 core/src/mindustryX/features/ui/ToolTableBase.java

diff --git a/core/src/mindustryX/features/UIExt.java b/core/src/mindustryX/features/UIExt.java
index 7664e5cd240e9e933373cbd1a3eeb382886e94f8..1a33e4f6c9509d0b34422eb360687ffc6c35f3ab 100644
--- a/core/src/mindustryX/features/UIExt.java
+++ b/core/src/mindustryX/features/UIExt.java
@@ -16,6 +16,8 @@ public class UIExt{
     public static TeamSelectDialog teamSelect;
     public static ModsRecommendDialog modsRecommend = new ModsRecommendDialog();
     public static TeamsStatDisplay teamsStatDisplay;
+    public static HudSettingsTable hudSettingsTable = new HudSettingsTable();
+    public static AdvanceBuildTool advanceBuildTool = new AdvanceBuildTool();
 
     public static void init(){
         teamSelect = new TeamSelectDialog();
@@ -26,6 +28,13 @@ public class UIExt{
             t.left().add(teamsStatDisplay);
             t.visible(() -> ui.hudfrag.shown && Core.settings.getBool("showOtherTeamResource"));
         });
+
+        ui.hudGroup.fill(t -> {
+            t.name = "quickTool";
+            t.right().add(hudSettingsTable).growX();
+            t.row().add(advanceBuildTool).growX();
+            t.visible(() -> ui.hudfrag.shown && Core.settings.getBool("showQuickToolTable"));
+        });
     }
 
     public static void buildPositionRow(Table tt, Vec2 vec){
diff --git a/core/src/mindustryX/features/ui/AdvanceBuildTool.java b/core/src/mindustryX/features/ui/AdvanceBuildTool.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ab6555e466a128c0a24014391e424d62458b2de
--- /dev/null
+++ b/core/src/mindustryX/features/ui/AdvanceBuildTool.java
@@ -0,0 +1,450 @@
+package mindustryX.features.ui;
+
+import arc.*;
+import arc.func.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.math.geom.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.content.*;
+import mindustry.entities.units.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustry.world.*;
+import mindustry.world.blocks.*;
+import mindustry.world.blocks.environment.*;
+import mindustry.world.blocks.logic.*;
+import mindustry.world.blocks.power.*;
+import mindustry.world.blocks.production.*;
+import mindustry.world.blocks.storage.*;
+import mindustryX.features.*;
+import mindustryX.features.Settings;
+import mindustryX.features.func.*;
+
+import static mindustry.Vars.*;
+import static mindustry.ui.Styles.flatTogglet;
+
+//moved from mindustry.arcModule.ui.quickTool.AdvanceBuildTool
+public class AdvanceBuildTool extends ToolTableBase{
+    BuildRange placement = BuildRange.player;
+    Rect selection = new Rect();
+    private Block original = Blocks.conveyor, newBlock = Blocks.titaniumConveyor;
+    private Block autoBuild = Blocks.turbineCondenser;
+    private Block searchBlock = Blocks.itemSource;
+    private Building searchBuild = null;
+    private int searchBlockIndex = -1;
+    private boolean shadowBuild = false;
+
+    public Seq<Building> buildingSeq = new Seq<>();
+    private final BuildTiles buildTiles = new BuildTiles();
+    private final ObjectFloatMap<Tile> buildEff = new ObjectFloatMap<>();//default 0f
+
+
+    public AdvanceBuildTool(){
+        icon = Blocks.buildTower.emoji();
+        Events.on(EventType.WorldLoadEvent.class, e -> rebuild());
+        Events.run(EventType.Trigger.update, () -> {
+            if(shadowBuild && player.unit() != null && player.unit().plans != null && player.unit().activelyBuilding()){
+                if(player.unit().buildPlan().progress == 0) return;
+                player.unit().plans.remove(player.unit().buildPlan());
+                Call.deletePlans(player, new int[]{player.unit().plans.indexOf(player.unit().buildPlan(), true)});
+            }
+        });
+
+    }
+
+    @Override
+    protected void buildTable(){
+        table(t -> {
+            t.setBackground(Styles.black6);
+            t.table(tt -> {
+                tt.button((placement == BuildRange.global ? "[cyan]" : "[gray]") + "", Styles.flatBordert, () -> {
+                    placement = BuildRange.global;
+                    rebuild();
+                }).tooltip("[cyan]全局检查").size(30f);
+                tt.button((placement == BuildRange.zone ? "[cyan]" : "[gray]") + "\uE818", Styles.flatBordert, () -> {
+                    selection = control.input.lastSelection;
+                    if(selection.area() < 10f) return;
+                    placement = BuildRange.zone;
+                    rebuild();
+                }).tooltip("[cyan]选择范围").size(30f);
+                tt.button((placement == BuildRange.team ? "" : "[gray]") + Blocks.coreShard.emoji(), Styles.flatBordert, () -> {
+                    placement = BuildRange.team;
+                    rebuild();
+                }).tooltip("[cyan]队伍区域").size(30f);
+                tt.button((placement == BuildRange.player ? "" : "[gray]") + UnitTypes.gamma.emoji(), Styles.flatBordert, () -> {
+                    placement = BuildRange.player;
+                    rebuild();
+                }).tooltip("[cyan]玩家建造区").size(30f);
+                tt.update(() -> {
+                    if(placement != BuildRange.zone) return;
+                    FuncX.drawText(selection.getCenter(Tmp.v1).scl(tilesize), "建造区域", Scl.scl(1.25f), Color.white, Align.bottom);
+                    Draw.color(Pal.stat, 0.7f);
+                    Draw.z(Layer.effect - 1f);
+                    Lines.stroke(Math.min(Math.abs(width), Math.abs(height)) / tilesize / 10f);
+                    Lines.rect(selection.x * tilesize - tilesize / 2f, selection.y * tilesize - tilesize / 2f, selection.width * tilesize + tilesize, selection.height * tilesize + tilesize);
+                    Draw.reset();
+                });
+            }).fillX().row();
+            t.table(tt -> {
+                tt.button("R", Styles.flatBordert, this::replaceBlock).tooltip("[cyan]替换方块").size(30f);
+                tt.button(replaceBlockName(), Styles.flatBordert, this::replaceBlockSetting).tooltip("[acid]设置替换").width(100f).height(30f);
+            }).fillX().row();
+            t.table(tt -> {
+                tt.button(autoBuild.emoji(), Styles.flatBordert, () -> blockAutoPlacer(autoBuild)).size(30f);
+                tt.button("\uE87C", Styles.flatBordert, () -> {
+                    new BlockSelectDialog(Block::isPlaceable, block -> autoBuild = block, block -> autoBuild == block).show();
+                    rebuild();
+                }).size(30f);
+                tt.update(() -> {
+                    if(control.input.selectedBlock()){
+                        autoBuild = control.input.block;
+                        rebuild();
+                    }
+                });
+            }).fillX().row();
+            t.table(tt -> {
+                tt.button("S", Styles.flatBordert, this::searchBlock).update(button -> {
+
+                    buildingSeq = player.team().data().buildings.select(building1 -> building1.block == searchBlock);
+                    if(searchBlock.privileged){
+                        for(Team team : Team.all){
+                            if(team == player.team()) continue;
+                            buildingSeq.add(team.data().buildings.select(building1 -> building1.block == searchBlock));
+                        }
+                    }
+
+                    if(buildingSeq.contains(searchBuild)){
+                        searchBlockIndex = buildingSeq.indexOf(searchBuild);
+                    }else{
+                        searchBuild = null;
+                        searchBlockIndex = -1;
+                    }
+
+                    if(buildingSeq.isEmpty() || searchBlockIndex == -1) button.setText("[lightgray]\uE88A");
+                    else button.setText("\uE88A" + (searchBlockIndex + 1) + "/" + buildingSeq.size);
+                }).tooltip("[cyan]搜索方块").growX().height(30f);
+
+                tt.button(searchBlock.emoji(), Styles.flatBordert, () -> {
+                    new BlockSelectDialog(Block::isPlaceable, block -> searchBlock = block, block -> searchBlock == block).show().hidden(this::rebuild);
+                    searchBlockIndex = 0;
+                }).tooltip("[acid]搜索替换").width(30f).height(30f);
+
+                tt.update(() -> {
+                    if(control.input.selectedBlock()){
+                        searchBlock = control.input.block;
+                        rebuild();
+                    }
+                });
+            }).fillX().row();
+            t.table(tt -> {
+                tt.button(Blocks.worldMessage.emoji(), flatTogglet, () -> Settings.toggle("displayallmessage")).checked(a -> RenderExt.displayAllMessage).size(30, 30).tooltip("开关信息板全显示");
+                tt.button(Blocks.worldProcessor.emoji(), Styles.flatBordert, () -> {
+                    showWorldProcessorInfo();
+                    searchBlock = Blocks.worldProcessor;
+                    rebuild();
+                }).size(30).tooltip("地图世处信息");
+            }).fillX().row();
+            t.table(tt -> tt.button("\uE817", flatTogglet, () -> shadowBuild = !shadowBuild).checked(a -> shadowBuild).size(30, 30).tooltip("虚影建造模式\n[red]有些服限制发包数较低，建筑较多时会被踢出。请酌情使用")).fillX().row();
+            if(!net.client()){
+                t.table(tt -> {
+                    tt.button("\uF8C9", flatTogglet, () -> {
+                        AdvanceToolTable.forcePlacement ^= true;
+                        if(mobile)
+                            ui.announce("允许蓝图建造地形");
+                    }).checked(a -> AdvanceToolTable.forcePlacement).size(30, 30).tooltip("允许蓝图建造地形");
+                    tt.button("\uE800", Styles.flatBordert, () -> {
+                        instantBuild();
+                        if(mobile)
+                            ui.announce("瞬间建造\n[cyan]强制瞬间建造[acid]选择范围内[cyan]内规划中的所有建筑\n[orange]可能出现bug");
+                    }).size(30, 30).tooltip("瞬间建造\n[cyan]强制瞬间建造[acid]选择范围内[cyan]规划中的所有建筑\n[orange]可能出现bug");
+                    tt.button("\uF8D2", Styles.flatBordert, () -> {
+                        if(!AdvanceToolTable.forcePlacement) ui.announce("请开启允许蓝图建造地形 \uF8C9");
+                        else saveTerrain(true);
+                    }).size(30, 30).tooltip("复制所选范围内的地板作为蓝图");
+                    tt.button("\uF8C4", Styles.flatBordert, () -> {
+                        if(!AdvanceToolTable.forcePlacement) ui.announce("请开启允许蓝图建造地形 \uF8C9");
+                        else saveTerrain(false);
+                    }).size(30, 30).tooltip("复制所选范围内的修饰作为蓝图");
+
+                }).fillX().row();
+            }
+        });
+    }
+
+    void replaceBlockSetting(){
+        BaseDialog dialog = new BaseDialog("方块替换器");
+        dialog.cont.table(t -> {
+            t.table(tt -> tt.label(() -> "当前选择：" + replaceBlockName())).row();
+            t.image().color(Pal.accent).fillX().row();
+            t.table(tt -> {
+                replaceBlockGroup(dialog, tt, Blocks.conveyor, Blocks.titaniumConveyor);
+                replaceBlockGroup(dialog, tt, Blocks.conveyor, Blocks.duct);
+                replaceBlockGroup(dialog, tt, Blocks.conduit, Blocks.pulseConduit);
+                replaceBlockGroup(dialog, tt, Blocks.conduit, Blocks.reinforcedConduit);
+            }).padTop(5f).row();
+            t.image().color(Pal.accent).padTop(5f).fillX().row();
+            t.table(tt -> {
+                tt.button("源方块", () -> new BlockSelectDialog(block -> block.replaceable, block -> original = block, block -> original == block).show()).width(100f).height(30f).row();
+                tt.button("新方块", () -> new BlockSelectDialog(block -> original.canReplace(block), block -> newBlock = block, block -> newBlock == block).show()).width(100f).height(30f).row();
+            }).padTop(5f).row();
+        });
+        dialog.hidden(this::rebuild);
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    public static void showWorldProcessorInfo(){
+        Log.info("当前地图:@", state.map.name());
+        int[] data = new int[3];
+        Groups.build.each(b -> {
+            if(b instanceof LogicBlock.LogicBuild lb && lb.block.privileged){
+                data[0] += 1;
+                data[1] += lb.code.split("\n").length + 1;
+                data[2] += lb.code.length();
+            }
+        });
+        Log.info("地图共有@个世处，总共@行指令，@个字符", data[0], data[1], data[2]);
+        ui.announce(Strings.format("地图共有@个世处，总共@行指令，@个字符", data[0], data[1], data[2]), 10);
+    }
+
+    void replaceBlockGroup(Dialog dialog, Table t, Block ori, Block re){
+        t.button(replaceBlockName(ori, re), () -> {
+            original = ori;
+            newBlock = re;
+            dialog.hide();
+        }).width(100f).height(30f);
+    }
+
+    String replaceBlockName(){
+        return replaceBlockName(original, newBlock);
+    }
+
+    String replaceBlockName(Block ori, Block re){
+        return ori.emoji() + "\uE803" + re.emoji();
+    }
+
+    void replaceBlock(){
+        replaceBlock(original, newBlock);
+    }
+
+    void replaceBlock(Block ori, Block re){
+        player.team().data().buildings.each(building -> building.block() == ori && contain(building.tile),
+        building -> player.unit().addBuild(new BuildPlan(building.tile.x, building.tile.y, building.rotation, re, building.config())));
+    }
+
+    void blockAutoPlacer(Block block){
+        buildTiles.buildBlock(block, tile -> getBlockEff(block, tile));
+    }
+
+    float getBlockEff(Block block, Tile tile){
+        if(block instanceof ThermalGenerator) return block.sumAttribute(((ThermalGenerator)block).attribute, tile);
+        if(block instanceof Drill) return ((Drill)block).countOreArc(tile);
+        return 1f;
+    }
+
+    boolean contain(Tile tile){
+        if(placement == BuildRange.global) return true;
+        if(placement == BuildRange.zone) return selection.contains(tile.x, tile.y);
+        if(placement == BuildRange.player) return tile.within(player.x, player.y, buildingRange);
+        if(placement == BuildRange.team){
+            if(state.rules.polygonCoreProtection){
+                float mindst = Float.MAX_VALUE;
+                CoreBlock.CoreBuild closest = null;
+                for(Teams.TeamData data : state.teams.active){
+                    for(CoreBlock.CoreBuild tiles : data.cores){
+                        float dst = tiles.dst2(tile.x * tilesize, tile.y * tilesize);
+                        if(dst < mindst){
+                            closest = tiles;
+                            mindst = dst;
+                        }
+                    }
+                }
+                return closest == null || closest.team == player.team();
+            }else return !state.teams.anyEnemyCoresWithin(player.team(), tile.x * tilesize, tile.y * tilesize, state.rules.enemyCoreBuildRadius + tilesize);
+        }
+        return true;
+    }
+
+    void searchBlock(){
+        if(buildingSeq.size == 0){
+            ui.announce("[violet]方块搜索\n[acid]未找到此方块");
+            return;
+        }
+        searchBlockIndex = (searchBlockIndex + 1) % buildingSeq.size;
+        searchBuild = buildingSeq.get(searchBlockIndex);
+
+        control.input.panCamera(Tmp.v1.set(searchBuild));
+        ui.announce("[violet]方块搜索\n[acid]找到方块[cyan]" + (searchBlockIndex + 1) + "[acid]/[cyan]" + buildingSeq.size + "[white]" + searchBlock.emoji());
+    }
+
+    void instantBuild(){
+        player.unit().plans.each(buildPlan -> {
+            if(!contain(buildPlan.tile())) return;
+            forceBuildBlock(buildPlan.block, buildPlan.tile(), player.team(), buildPlan.rotation, buildPlan.config);
+        });
+    }
+
+    void saveTerrain(boolean floor){
+        buildTiles.updateTiles();
+        Seq<Schematic.Stile> tiles = new Seq<>();
+        buildTiles.validTile.each(tile -> {
+            if(!floor && tile.overlay() == Blocks.air) return;
+            tiles.add(new Schematic.Stile(floor ? tile.floor() : tile.overlay(), tile.x - buildTiles.minx, tile.y - buildTiles.miny));
+        });
+        control.input.lastSchematic = new Schematic(tiles, new StringMap(), buildTiles.width, buildTiles.height);
+        control.input.useSchematic(control.input.lastSchematic);
+    }
+
+    void forceBuildBlock(Block block, Tile tile, Team team, int rotation, Object config){
+        if(block == Blocks.cliff) buildCliff(tile);
+        else if(block instanceof OverlayFloor){
+            tile.setOverlay(block);
+        }else if(block instanceof Floor floor){
+            tile.setFloor(floor);
+        }else{
+            tile.setBlock(block, team, rotation);
+            tile.build.configure(config);
+        }
+        pathfinder.updateTile(tile);
+    }
+
+    void buildCliff(Tile tile){
+        int rotation = 0;
+        for(int i = 0; i < 8; i++){
+            Tile other = world.tiles.get(tile.x + Geometry.d8[i].x, tile.y + Geometry.d8[i].y);
+            if(other != null && !other.floor().hasSurface()){
+                rotation |= (1 << i);
+            }
+        }
+
+        if(rotation != 0){
+            tile.setBlock(Blocks.cliff);
+        }
+
+        tile.data = (byte)rotation;
+    }
+
+    enum BuildRange{
+        global, zone, team, player
+    }
+
+    class BuildTiles{
+        public int minx, miny, maxx, maxy, width, height;
+        Seq<Tile> validTile = new Seq<>();
+        Seq<Float> eff = new Seq<>();
+        float efficiency = 0;
+        Block block;
+        boolean canBuild = true;
+
+        public BuildTiles(){
+        }
+
+        void buildBlock(Block buildBlock, Floatf<Tile> tilef){
+            block = buildBlock;
+            updateTiles();
+            checkValid();
+            calBlockEff(tilef);
+            eff.sort().reverse().remove(0f);
+            eff.each(this::buildEff);
+        }
+
+        public void updateTiles(){
+            minx = 9999;
+            miny = 9999;
+            maxx = -999;
+            maxy = -999;
+            validTile.clear();
+            eff.clear();
+            world.tiles.eachTile(tile -> {
+                if(tile == null) return;
+                if(!contain(tile)) return;
+                validTile.add(tile);
+                minx = Math.min(minx, tile.x);
+                miny = Math.min(miny, tile.y);
+                maxx = Math.max(maxx, tile.x);
+                maxy = Math.max(maxy, tile.y);
+            });
+            buildEff.clear();
+            width = maxx - minx;
+            height = maxy - miny;
+        }
+
+        void checkValid(){
+            validTile.each(tile -> {
+                if(
+                (block.size == 2 && world.getDarkness(tile.x, tile.y) >= 3) ||
+                (state.rules.staticFog && state.rules.fog && !fogControl.isDiscovered(player.team(), tile.x, tile.y)) ||
+                (tile.floor().isDeep() && !block.floating && !block.requiresWater && !block.placeableLiquid) || //deep water
+                (block == tile.block() && tile.build != null && rotation == tile.build.rotation && block.rotate) || //same block, same rotation
+                !tile.interactable(player.team()) || //cannot interact
+                !tile.floor().placeableOn || //solid wall
+                //replacing a block that should be replaced (e.g. payload placement)
+                !((block.canReplace(tile.block()) || //can replace type
+                (tile.build instanceof ConstructBlock.ConstructBuild build && build.current == block && tile.centerX() == tile.x && tile.centerY() == tile.y)) && //same type in construction
+                block.bounds(tile.x, tile.y, Tmp.r1).grow(0.01f).contains(tile.block().bounds(tile.centerX(), tile.centerY(), Tmp.r2))) || //no replacement
+                (block.requiresWater && tile.floor().liquidDrop != Liquids.water) //requires water but none found
+                ) buildEff.put(tile, -1); // cannot build
+            });
+        }
+
+        void calBlockEff(Floatf<Tile> tilef){
+            validTile.each(tile -> {
+                canBuild = true;
+                getLinkedTiles(tile, tile1 -> canBuild = buildEff.get(tile, 0f) != -1 && canBuild);   //不可能建造
+                if(canBuild){
+                    efficiency = tilef.get(tile);
+                    buildEff.put(tile, efficiency);
+                    if(!eff.contains(efficiency)) eff.add(efficiency);
+                }else{
+                    buildEff.remove(tile, 0);
+                }
+            });
+        }
+
+        void buildEff(float e){
+            if(e == 0) return;
+            validTile.each(tile -> {
+                if(buildEff.get(tile, 0f) != e) return;
+                if(!block.canPlaceOn(tile, player.team(), 0)) return;
+                player.unit().addBuild(new BuildPlan(tile.x, tile.y, 0, block));
+                getFullLinkedTiles(tile, tile1 -> buildEff.remove(tile1, 0f));
+            });
+        }
+
+        private void getLinkedTiles(Tile tile, Cons<Tile> cons){
+            if(block.isMultiblock()){
+                int size = block.size, o = block.sizeOffset;
+                for(int dx = 0; dx < size; dx++){
+                    for(int dy = 0; dy < size; dy++){
+                        Tile other = world.tile(tile.x + dx + o, tile.y + dy + o);
+                        if(other != null) cons.get(other);
+                    }
+                }
+            }else{
+                cons.get(tile);
+            }
+        }
+
+        private void getFullLinkedTiles(Tile tile, Cons<Tile> cons){
+            if(block.isMultiblock()){
+                int size = block.size, o = 0;
+                for(int dx = -size + 1; dx < size; dx++){
+                    for(int dy = -size + 1; dy < size; dy++){
+                        Tile other = world.tile(tile.x + dx + o, tile.y + dy + o);
+                        if(other != null) cons.get(other);
+                    }
+                }
+            }else{
+                cons.get(tile);
+            }
+        }
+
+    }
+}
diff --git a/core/src/mindustryX/features/ui/HudSettingsTable.java b/core/src/mindustryX/features/ui/HudSettingsTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ae0bd9c757eb5d5664fa0dec872938e1f1e4b0e
--- /dev/null
+++ b/core/src/mindustryX/features/ui/HudSettingsTable.java
@@ -0,0 +1,229 @@
+package mindustryX.features.ui;
+
+import arc.*;
+import arc.scene.*;
+import arc.scene.event.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.util.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustryX.features.Settings;
+import mindustryX.features.*;
+
+import static arc.Core.*;
+import static mindustry.Vars.*;
+
+//moved from mindustry.arcModule.ui.quickTool.HudSettingsTable
+public class HudSettingsTable extends ToolTableBase{
+    private final Table cont = new Table();
+
+    public HudSettingsTable(){
+        icon = String.valueOf(Iconc.settings);
+        rebuild();
+        Events.on(EventType.WorldLoadEvent.class, e -> Core.settings.put("removeLogicLock", false));
+    }
+
+    @Override
+    protected void buildTable(){
+        cont.clearChildren();
+
+        cont.background(Styles.black6);
+        cont.table(t -> {
+            t.button("[cyan]S", Styles.flatBordert, () -> Call.sendChatMessage("/sync")).size(30).tooltip("同步一波");
+            t.button("[cyan]观", Styles.flatBordert, () -> Call.sendChatMessage("/ob")).size(30).tooltip("观察者模式");
+            t.button("[cyan]技", Styles.flatBordert, () -> Call.sendChatMessage("/skill")).size(30).tooltip("技能！");
+            t.button("[cyan]版", Styles.flatBordert, () -> Call.sendChatMessage("/broad")).size(30).tooltip("服务器信息版");
+            t.button("[red]版", Styles.flatTogglet, () -> Settings.toggle("ShowInfoPopup")).checked(a -> Core.settings.getBool("ShowInfoPopup")).size(30, 30).tooltip("关闭所有信息版");
+            t.button("[white]法", Styles.flatBordert, () -> ui.showConfirm("受不了，直接投降？", () -> Call.sendChatMessage("/vote gameover"))).size(30, 30).tooltip("法国军礼");
+            if(settings.getInt("arcQuickMsg", 0) == 0)
+                t.button("\uE87C", Styles.flatBordert, this::arcQuickMsgTable).size(30, 30).tooltip("快捷消息");
+        }).left().row();
+
+        if(settings.getInt("arcQuickMsg") > 0){
+            cont.table(t -> {
+                for(int i = 0; i < settings.getInt("arcQuickMsg"); i++){
+                    if(i % settings.getInt("arcQuickMsgKey", 8) == 0) t.row();
+                    int finalI = i;
+                    t.button(settings.getString(getArcQuickMsgShortName(i)), Styles.flatBordert, () -> {
+                        if(settings.getBool(getArcQuickMsgJs(finalI))) mods.getScripts().runConsole(settings.getString(getArcQuickMsgName(finalI)));
+                        else Call.sendChatMessage(settings.getString(getArcQuickMsgName(finalI)));
+                    }
+                    ).size(30);
+                }
+                t.button("\uE87C", Styles.flatBordert, this::arcQuickMsgTable).size(30, 30).tooltip("快捷消息");
+            }).left().row();
+        }
+        cont.table(t -> {
+            t.button("[cyan]块", Styles.flatTogglet, () -> Settings.cycle("blockRenderLevel", 3))
+            .checked((a) -> RenderExt.blockRenderLevel > 0).size(30, 30).tooltip("建筑显示");
+            t.button("[cyan]兵", Styles.flatTogglet, () -> RenderExt.unitHide = !RenderExt.unitHide)
+            .checked(a -> !RenderExt.unitHide).size(30, 30).tooltip("兵种显示");
+            t.button("[cyan]箱", Styles.flatTogglet, () -> Settings.toggle("unithitbox"))
+            .checked(a -> Core.settings.getBool("unithitbox")).size(30, 30).tooltip("碰撞箱显示");
+            t.button("[cyan]弹", Styles.flatTogglet, () -> Settings.toggle("bulletShow"))
+            .checked(a -> Core.settings.getBool("bulletShow")).size(30, 30).tooltip("子弹显示");
+            t.button("[cyan]" + Iconc.map, Styles.flatTogglet, () -> Settings.toggle("minimap"))
+            .checked(a -> Core.settings.getBool("minimap")).size(30, 30).tooltip("小地图显示");
+            t.button("[violet]锁", Styles.flatTogglet, () -> {
+                Settings.toggle("removeLogicLock");
+                control.input.logicCutscene = false;
+                ui.announce("已移除逻辑视角锁定");
+            }).checked(a -> Core.settings.getBool("removeLogicLock")).size(30, 30).tooltip("逻辑锁定");
+            t.button("[cyan]雾", Styles.flatTogglet, () -> {
+                if(!state.rules.pvp || player.team().id == 255) renderer.fogEnabled = !renderer.fogEnabled;
+            }).checked(a -> renderer.fogEnabled).size(30, 30).tooltip("战争迷雾").visible(() -> !state.rules.pvp || player.team().id == 255);
+        }).left().row();
+        cont.table(t -> {
+            t.button("[red]灯", Styles.flatTogglet, () -> Settings.toggle("drawlight"))
+            .checked(a -> state.rules.lighting).size(30, 30).name("灯光").tooltip("[cyan]开灯啊！");
+            t.button("[acid]效", Styles.flatTogglet, () -> Settings.toggle("effects"))
+            .checked(a -> Core.settings.getBool("effects")).size(30, 30).tooltip("特效显示");
+            t.button("[acid]光", Styles.flatTogglet, () -> {
+                Settings.toggle("bloom");
+                renderer.toggleBloom(settings.getBool("bloom"));
+            }).checked(a -> Core.settings.getBool("bloom")).size(30, 30).tooltip("光效显示");
+            t.button("[acid]墙", Styles.flatTogglet, () -> enableDarkness ^= true)
+            .checked(a -> enableDarkness).size(30, 30).tooltip("墙体阴影显示");
+            t.button("[acid]天", Styles.flatTogglet, () -> Settings.toggle("showweather"))
+            .checked(a -> Core.settings.getBool("showweather")).size(30, 30).tooltip("天气显示");
+            t.button("[cyan]扫", Styles.flatTogglet, () -> ArcScanMode.enabled = !ArcScanMode.enabled)
+            .checked(a -> ArcScanMode.enabled).size(30, 30).tooltip("扫描模式");
+
+        }).left().row();
+
+        sliderPref("turretShowRange", 0, 3, 1, s -> switch(s){
+            case 0 -> "关闭";
+            case 1 -> "仅对地";
+            case 2 -> "仅对空";
+            case 3 -> "全部";
+            default -> s + "";
+        });
+        sliderPref("chatValidType", 0, 3, 1, s -> switch(s){
+            case 0 -> "原版模式";
+            case 1 -> "纯净聊天";
+            case 2 -> "服务器记录";
+            case 3 -> "全部记录";
+            default -> s + "";
+        });
+        checkPref("unitHealthBar");
+        sliderPref("unitTransparency", 0, 100, 5, i -> i > 0 ? i + "%" : "关闭");
+        sliderPref("unitDrawMinHealth", 0, 2500, 50, i -> i + "[red]HP");
+        sliderPref("unitBarDrawMinHealth", 0, 2500, 100, i -> i + "[red]HP");
+        sliderPref("unitWeaponRange", 0, 100, 1, i -> i > 0 ? i + "%" : "关闭");
+
+        checkPref("alwaysShowUnitRTSAi");
+        checkPref("unitLogicMoveLine");
+        checkPref("unitWeaponTargetLine");
+
+        checkPref("blockWeaponTargetLine");
+        checkPref("unitbuildplan");
+        sliderPref("minimapSize", 40, 400, 10, i -> i + "");
+
+        ScrollPane pane = pane(cont).maxSize(800f, 300f).get();
+        pane.update(() -> {
+            Element e = Core.scene.hit(Core.input.mouseX(), Core.input.mouseY(), true);
+            if(e != null && e.isDescendantOf(pane)){
+                pane.requestScroll();
+            }else if(pane.hasScroll()){
+                Core.scene.setScrollFocus(null);
+            }
+        });
+    }
+
+    private void arcQuickMsgTable(){
+        BaseDialog dialog = new BaseDialog("快捷信息");
+        dialog.cont.table(t -> {
+            t.add("""
+            在此编辑快速消息，可在快捷设置面板显示。如设置：
+            [white]法 /vote gameover
+            这一指令会添加一个“[white]法的按钮，点击会自动输入/vote gameover。
+            由于懒得写更新，请修改滑块后[orange]关闭此窗口后再打开一次[white]
+            快捷设置面板同样需要[orange]关闭后再打开一次[white]才能生效""").center().fillX().row();
+            t.table(tt -> {
+                tt.add("快捷消息个数： ");
+                Label label = tt.add(String.valueOf(settings.getInt("arcQuickMsg", 0))).get();
+                tt.slider(0, 50, 1, settings.getInt("arcQuickMsg", 0), i -> {
+                    settings.put("arcQuickMsg", (int)i);
+                    label.setText(String.valueOf(settings.getInt("arcQuickMsg")));
+                }).width(200f).row();
+                tt.add("每行多少个按键： ");
+                Label label2 = tt.add(String.valueOf(settings.getInt("arcQuickMsgKey", 0))).get();
+                tt.slider(3, 10, 1, settings.getInt("arcQuickMsgKey", 0), i -> {
+                    settings.put("arcQuickMsgKey", (int)i);
+                    label2.setText(String.valueOf(settings.getInt("arcQuickMsgKey")));
+                }).width(200f);
+            }).row();
+            t.pane(tt -> {
+                tt.add("第i个").width(50f);
+                tt.add("JS").width(50f);
+                tt.add("按钮显示\n(建议单个字符)").width(100f);
+                tt.add("              输入信息").width(400f).center().row();
+
+                for(int i = 0; i < settings.getInt("arcQuickMsg", 0); i++){
+                    tt.add(i + "  ");
+                    int finalI = i;
+                    tt.check("", settings.getBool(getArcQuickMsgJs(finalI)), js -> settings.put(getArcQuickMsgJs(finalI), js));
+                    tt.field(settings.getString(getArcQuickMsgShortName(finalI), "?"), text -> settings.put(getArcQuickMsgShortName(finalI), text)).maxTextLength(10);
+                    tt.field(settings.getString(getArcQuickMsgName(finalI), "未输入指令"), text -> settings.put(getArcQuickMsgName(finalI), text)).maxTextLength(300).width(350f);
+                    tt.row();
+                }
+            });
+        });
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    private String getArcQuickMsgShortName(int i){
+        return "arcQuickMsgShort" + i;
+    }
+
+    private String getArcQuickMsgName(int i){
+        return "arcQuickMsg" + i;
+    }
+
+    private String getArcQuickMsgJs(int i){
+        return "arcQuickMsgJs" + i;
+    }
+
+    public interface StringProcessor{
+        String get(int i);
+    }
+
+    public void sliderPref(String name, int min, int max, int step, StringProcessor s){
+        Slider slider = new Slider(min, max, step, false);
+        Label value = new Label("", Styles.outlineLabel);
+        slider.update(() -> {
+            slider.setValue(settings.getInt(name));
+            value.setText(s.get((int)slider.getValue()));
+        });
+        slider.changed(() -> settings.put(name, (int)slider.getValue()));
+
+        Table content = new Table();
+        content.add(bundle.get("setting." + name + ".name"), Styles.outlineLabel).left().growX().wrap();
+        content.add(value).padLeft(10f).right();
+        content.margin(3f, 33f, 3f, 33f);
+        content.touchable = Touchable.disabled;
+
+        cont.stack(slider, content).width(Math.min(Core.graphics.getWidth() / 1.2f, 300f)).left().padTop(4f).get();
+        cont.row();
+
+        if(settings.getDefault(name) == null)
+            Log.warn("no default value for " + name);
+    }
+
+    public void checkPref(String name){
+        CheckBox box = new CheckBox(bundle.get("setting." + name + ".name"));
+        box.update(() -> box.setChecked(settings.getBool(name)));
+        box.changed(() -> settings.put(name, box.isChecked()));
+
+        box.left();
+        cont.add(box).left().padTop(0.5f);
+        cont.row();
+
+        if(settings.getDefault(name) == null)
+            Log.warn("no default value for " + name);
+    }
+}
diff --git a/core/src/mindustryX/features/ui/ToolTableBase.java b/core/src/mindustryX/features/ui/ToolTableBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..726972db14897a81e6f26efddc0404a029d1bd46
--- /dev/null
+++ b/core/src/mindustryX/features/ui/ToolTableBase.java
@@ -0,0 +1,24 @@
+package mindustryX.features.ui;
+
+import arc.scene.ui.layout.*;
+import mindustry.ui.*;
+
+public abstract class ToolTableBase extends Table{
+    public String icon = "";
+    public boolean expand = false;
+
+
+    public void rebuild(){
+        clear();
+        table().growX().left();
+        if(expand){
+            buildTable();
+        }
+        button((expand ? "" : "[lightgray]") + icon, Styles.flatBordert, () -> {
+            expand = !expand;
+            rebuild();
+        }).right().width(40f).minHeight(40f).fillY();
+    }
+
+    protected abstract void buildTable();
+}
