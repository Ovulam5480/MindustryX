From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Sun, 28 Jan 2024 17:39:57 +0800
Subject: [PATCH] =?UTF-8?q?FC:=20Loader=20Mod=E5=AE=9E=E7=8E=B0?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 .../src/mindustryX/loader/AndroidImpl.java    | 277 ++++++++++++++++++
 core/src/mindustryX/loader/DesktopImpl.java   | 131 +++++++++
 .../src/mindustryX/loader/LoaderPlatform.java |  45 +++
 core/src/mindustryX/loader/Main.java          | 130 ++++++++
 4 files changed, 583 insertions(+)
 create mode 100644 android/src/mindustryX/loader/AndroidImpl.java
 create mode 100644 core/src/mindustryX/loader/DesktopImpl.java
 create mode 100644 core/src/mindustryX/loader/LoaderPlatform.java
 create mode 100644 core/src/mindustryX/loader/Main.java

diff --git a/android/src/mindustryX/loader/AndroidImpl.java b/android/src/mindustryX/loader/AndroidImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0a9c75d7b7ea328d7f73f3d6d22a782f15dfc65
--- /dev/null
+++ b/android/src/mindustryX/loader/AndroidImpl.java
@@ -0,0 +1,277 @@
+package mindustryX.loader;
+
+import android.app.*;
+import android.content.pm.*;
+import android.os.*;
+import android.view.*;
+import arc.*;
+import arc.Files.*;
+import arc.backend.android.*;
+import arc.files.*;
+import arc.func.*;
+import arc.util.*;
+import dalvik.system.*;
+import mindustry.*;
+import mindustry.android.*;
+
+import java.io.*;
+import java.lang.reflect.Proxy;
+import java.lang.reflect.*;
+import java.net.*;
+import java.util.*;
+
+public class AndroidImpl implements LoaderPlatform{
+    private AndroidLauncher app = (AndroidLauncher)Core.app;
+
+    private Object[] getDexElements(ClassLoader classLoader){
+        Object pathList = Reflect.get(BaseDexClassLoader.class, classLoader, "pathList");
+        return Reflect.get(pathList, "dexElements");
+    }
+
+    private File findFirstJar(){
+        return Reflect.get(getDexElements(Main.class.getClassLoader())[0], "path");
+    }
+
+    @Override
+    public void withSafeClassloader(String method){
+        try{
+            ClassLoader classLoader = new DexClassLoader(findFirstJar().getPath(), app.getFilesDir().getPath(), null, Core.class.getClassLoader());
+            Reflect.invoke(classLoader.loadClass(Main.class.getName()), method);
+        }catch(Exception e){
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public ClassLoader createClassloader(){
+        ClassLoader parent = Core.class.getClassLoader();
+        File apk = Reflect.get(getDexElements(parent)[0], "path");
+//        List<File> nativeLibrary = Reflect.get(parentPathList, "nativeLibraryDirectories");
+        assert parent != null;
+        ClassLoader classLoader = new DexClassLoader(findFirstJar().getPath() + File.pathSeparator + apk.getPath(), app.getFilesDir().getPath(), null, parent){
+            @Override
+            protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{
+                if(!overwrite(name))
+                    return super.loadClass(name, resolve);
+                //check for loaded state
+                Class<?> loadedClass = findLoadedClass(name);
+                if(loadedClass == null){
+                    try{
+                        //try to load own class first
+                        loadedClass = findClass(name);
+                    }catch(ClassNotFoundException e){
+                        //use parent if not found
+                        return parent.loadClass(name);
+                    }
+                }
+
+                return loadedClass;
+            }
+
+            private Boolean overwrite(String name){
+//                if(name.contains("ExternalSynthetic")) return false;
+                if(name.startsWith("arc.func")) return false;
+                return name.startsWith("mindustry") || name.startsWith("arc.") || name.startsWith("rhino.");
+            }
+
+            @Override
+            public String findLibrary(String name){
+                //TODO Soloud的native会查找class，而且不支持classloader。
+                String file = super.findLibrary(name);
+                //Android的jni方法不能跨classloader，且同一个so库加载多次
+                if(file != null){
+                    Fi newFile = new Fi(app.getFilesDir()).child(name + ".so");
+                    new Fi(file).copyTo(newFile);
+                    file = newFile.path();
+                }
+                return file;
+            }
+
+            @Override
+            public URL getResource(String name){
+                if(name.equals("MindustryX.hjson"))
+                    return findResource("mod.hjson");
+                if(name.equals("mod.hjson")) return null;
+                //self first
+                URL url = findResource(name);
+                if(url == null)
+                    url = parent.getResource(name);
+                return url;
+            }
+
+            @Override
+            public Enumeration<URL> getResources(String name) throws IOException{
+                return new CompoundURLEnumeration(
+                //self first
+                findResources(name), parent.getResources(name)
+                );
+            }
+        };
+        Object pathList = Reflect.get(BaseDexClassLoader.class, classLoader, "pathList");
+        Object parentPathList = Reflect.get(BaseDexClassLoader.class, parent, "pathList");
+        Reflect.set(pathList, "nativeLibraryDirectories", Reflect.get(parentPathList, "nativeLibraryDirectories"));
+        Reflect.set(pathList, "nativeLibraryPathElements", Reflect.get(parentPathList, "nativeLibraryPathElements"));
+        return classLoader;
+    }
+
+    private static Object[] makeDexElements(Object dexPathList, ArrayList<File> files, File optimizedDirectory){
+        if(Build.VERSION.SDK_INT >= 23){
+            ArrayList<IOException> suppressedExceptions = new ArrayList<>();
+            return Reflect.invoke(dexPathList.getClass(), "makePathElements", new Object[]{files, optimizedDirectory, suppressedExceptions}, List.class, File.class, List.class);
+        }else{
+            return Reflect.invoke(dexPathList.getClass(), "makeDexElements", new Object[]{files, optimizedDirectory}, ArrayList.class, File.class);
+        }
+    }
+
+    @Override
+    public void launch(ClassLoader loader) throws Exception{
+
+        Class<?> cls = loader.loadClass(AndroidImpl.class.getName());
+        app.handler.post(() -> {
+            ((AndroidInput)Core.input).onPause();
+//            Reflect.invoke(Core.graphics, "pause");
+            Core.graphics.dispose();
+            Core.audio.dispose();
+            app.setContentView(Reflect.invoke(cls, "bootStrapAsView",
+            new Object[]{app, app.getListeners().get(0)}, Activity.class, Object.class));
+        });
+    }
+
+    public static View bootStrapAsView(Activity activity, Object platform){
+        AndroidApplication newApp = new AndroidLauncher();
+        copyFields(activity, newApp);
+        AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();
+        config.useImmersiveMode = true;
+        config.hideStatusBar = true;
+        View view = newApp.initializeForView(new ClientLauncher(){
+
+            @Override
+            public void hide(){
+                activity.moveTaskToBack(true);
+            }
+
+            @Override
+            public rhino.Context getScriptContext(){
+                return AndroidRhinoContext.enter(activity.getCacheDir());
+            }
+
+            @Override
+            public void shareFile(Fi file){
+            }
+
+            @Override
+            public ClassLoader loadJar(Fi jar, ClassLoader parent) throws Exception{
+                return new DexClassLoader(jar.file().getPath(), activity.getFilesDir().getPath(), null, parent){
+                    @Override
+                    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{
+                        //check for loaded state
+                        Class<?> loadedClass = findLoadedClass(name);
+                        if(loadedClass == null){
+                            try{
+                                //try to load own class first
+                                loadedClass = findClass(name);
+                            }catch(ClassNotFoundException | NoClassDefFoundError e){
+                                //use parent if not found
+                                return parent.loadClass(name);
+                            }
+                        }
+
+                        if(resolve){
+                            resolveClass(loadedClass);
+                        }
+                        return loadedClass;
+                    }
+                };
+            }
+
+            @Override
+            public void showFileChooser(boolean open, String title, String extension, Cons<Fi> cons){
+                showFileChooser(open, title, cons, extension);
+            }
+
+            @Override
+            public void showMultiFileChooser(Cons<Fi> cons, String... extensions){
+                showFileChooser(true, "@open", cons, extensions);
+            }
+
+            void showFileChooser(boolean open, String title, Cons<Fi> cons, String... extensions){
+                Cons<Object> consProxy = (fi) -> {
+                    Class<?> cls = fi.getClass();
+                    if(cls.isAnonymousClass()){
+                        cons.get(new Fi((File)Reflect.get(fi, "file")){
+                            @Override
+                            public InputStream read(){
+                                return Reflect.invoke(fi, "read");
+                            }
+
+                            @Override
+                            public OutputStream write(boolean append){
+                                return Reflect.invoke(fi, "write", new Object[]{append}, boolean.class);
+                            }
+                        });
+                    }else if(cls.getSimpleName().equals("Fi")){
+                        cons.get(new Fi((File)Reflect.get(fi, "file")));
+                    }else{
+                        Vars.ui.showErrorMessage("Not Implement showFileChooser");
+                    }
+                };
+                try{
+                    Method m = platform.getClass().getDeclaredMethod("showFileChooser", boolean.class, String.class, Cons.class, String[].class);
+                    m.setAccessible(true);
+                    m.invoke(platform, open, title, consProxy, extensions);
+                }catch(Exception e){
+                    Log.err(e);
+                }
+            }
+
+            @Override
+            public void beginForceLandscape(){
+                activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
+            }
+
+            @Override
+            public void endForceLandscape(){
+                activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_USER);
+            }
+        }, config);
+        ClassLoader loader = Main.class.getClassLoader();
+        assert loader != null;
+        Files origin = Core.files;
+        Core.files = (Files)Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]{Files.class}, (proxy, method, args) -> {
+            if(method.getName().equals("internal") || (method.getName().equals("get") && args[1] == FileType.internal)){
+                String path = (String)args[0];
+                if(loader.getResource(path) != null){
+                    return origin.classpath(path);
+                }
+            }
+            return method.invoke(origin, args);
+        });
+        try{
+            //new external folder
+            Fi data = Core.files.absolute(newApp.getExternalFilesDir(null).getAbsolutePath());
+            Core.settings.setDataDirectory(data);
+        }catch(Exception e){
+            //print log but don't crash
+            Log.err(e);
+        }
+        return view;
+    }
+
+    private static void copyFields(Object a, Object b){
+        Class<?> ca = a.getClass(), cb = b.getClass();
+        while(ca != Object.class){
+            if(ca == cb){
+                for(Field f : ca.getDeclaredFields()){
+                    f.setAccessible(true);
+                    Reflect.set(b, f, Reflect.get(a, f));
+                }
+            }
+            ca = ca.getSuperclass();
+            cb = cb.getSuperclass();
+        }
+    }
+
+    @Override
+    public void cleanup(){
+    }
+}
diff --git a/core/src/mindustryX/loader/DesktopImpl.java b/core/src/mindustryX/loader/DesktopImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ad76a14f44eabc68d3f75ebd5d6ba56361cf1f2
--- /dev/null
+++ b/core/src/mindustryX/loader/DesktopImpl.java
@@ -0,0 +1,131 @@
+package mindustryX.loader;
+
+import arc.*;
+import arc.struct.*;
+import arc.util.*;
+import arc.util.io.*;
+import mindustry.game.*;
+
+import java.io.*;
+import java.net.*;
+import java.util.*;
+
+public class DesktopImpl implements LoaderPlatform{
+    @Override
+    public void withSafeClassloader(String method){
+        URL file = ((URLClassLoader)Main.class.getClassLoader()).getURLs()[0];
+        ClassLoader parent = Core.class.getClassLoader();
+        try(var classLoader = new URLClassLoader(new URL[]{file}, parent)){
+            Reflect.invoke(classLoader.loadClass(Main.class.getName()), method);
+        }catch(Exception e){
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void cleanup(){
+        //fix steam
+        //noinspection unchecked
+        Seq<?> listeners = ((ObjectMap<Object, Seq<?>>)Reflect.get(Events.class, "events")).get(EventType.DisposeEvent.class);
+        if(listeners != null) listeners.clear();
+
+        for(ApplicationListener l : Core.app.getListeners()){
+            l.pause();
+            try{
+                l.dispose();
+            }catch(Throwable e){
+                Log.err("Cleanup", e);
+            }
+        }
+        Core.app.dispose();
+        try{
+            Class<?> sdl = Class.forName("arc.backend.sdl.jni.SDL");
+            Reflect.invoke(sdl, "SDL_DestroyWindow", new Object[]{Reflect.get(Core.app, "window")}, long.class);
+//            Reflect.invoke(sdl, "SDL_Quit");
+        }catch(Throwable e){
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public ClassLoader createClassloader(){
+        URL file = ((URLClassLoader)Main.class.getClassLoader()).getURLs()[0];
+        ClassLoader parent = Core.class.getClassLoader();
+        return new URLClassLoader(new URL[]{file}, parent){
+            @Override
+            protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{
+                synchronized(getClassLoadingLock(name)){
+                    //check for loaded state
+                    Class<?> loadedClass = findLoadedClass(name);
+                    if(loadedClass == null){
+                        try{
+                            //try to load own class first
+                            loadedClass = findClass(name);
+                        }catch(ClassNotFoundException e){
+                            //use parent if not found
+                            return parent.loadClass(name);
+                        }
+                    }
+
+                    if(resolve){
+                        resolveClass(loadedClass);
+                    }
+                    return loadedClass;
+                }
+            }
+
+            @Override
+            protected Class<?> findClass(String name) throws ClassNotFoundException{
+                try{
+                    return super.findClass(name);
+                }catch(ClassNotFoundException e){
+                    if(overwrite(name)){
+                        InputStream res = parent.getResourceAsStream(name.replace('.', '/').concat(".class"));
+                        if(res != null){
+                            try{
+                                byte[] bs = Streams.copyBytes(res);
+                                return defineClass(name, bs, 0, bs.length);
+                            }catch(IOException | ClassFormatError e2){
+                                e.addSuppressed(e2);
+                            }finally{
+                                Streams.close(res);
+                            }
+                        }
+                    }
+                    throw e;
+                }
+            }
+
+            private Boolean overwrite(String name){
+                if(name.startsWith("arc.backend.sdl.jni")) return false;
+                return name.startsWith("mindustry") || name.startsWith("arc");
+            }
+
+            @Override
+            public URL getResource(String name){
+                if(name.equals("MindustryX.hjson"))
+                    return findResource("mod.hjson");
+                if(name.equals("mod.hjson")) return null;
+                //self first
+                URL url = findResource(name);
+                if(url == null)
+                    url = parent.getResource(name);
+                return url;
+            }
+
+            @Override
+            public Enumeration<URL> getResources(String name) throws IOException{
+                return new CompoundURLEnumeration(
+                //self first
+                findResources(name), parent.getResources(name)
+                );
+            }
+        };
+    }
+
+    @Override
+    public void launch(ClassLoader loader) throws Exception{
+        Reflect.invoke(loader.loadClass("mindustry.desktop.DesktopLauncher"), "main", new Object[]{new String[]{}}, String[].class);
+        System.exit(0);
+    }
+}
diff --git a/core/src/mindustryX/loader/LoaderPlatform.java b/core/src/mindustryX/loader/LoaderPlatform.java
new file mode 100644
index 0000000000000000000000000000000000000000..7214a64cd3d4e93503c1ed50e1514db90260fc5a
--- /dev/null
+++ b/core/src/mindustryX/loader/LoaderPlatform.java
@@ -0,0 +1,45 @@
+package mindustryX.loader;
+
+import java.net.*;
+import java.util.*;
+
+interface LoaderPlatform{
+    void withSafeClassloader(String method);
+
+    void cleanup();
+
+    ClassLoader createClassloader();
+
+    void launch(ClassLoader loader) throws Exception;
+
+    final class CompoundURLEnumeration implements Enumeration<URL>{
+        private final Enumeration<URL>[] enums;
+        private int index;
+
+        @SafeVarargs
+        public CompoundURLEnumeration(Enumeration<URL>... enums){
+            this.enums = enums;
+        }
+
+        private boolean next(){
+            while(index < enums.length){
+                if(enums[index] != null && enums[index].hasMoreElements()){
+                    return true;
+                }
+                index++;
+            }
+            return false;
+        }
+
+        public boolean hasMoreElements(){
+            return next();
+        }
+
+        public URL nextElement(){
+            if(!next()){
+                throw new NoSuchElementException();
+            }
+            return enums[index].nextElement();
+        }
+    }
+}
diff --git a/core/src/mindustryX/loader/Main.java b/core/src/mindustryX/loader/Main.java
new file mode 100644
index 0000000000000000000000000000000000000000..c0f7d4a491a480763bee18139bbc13f896670bb4
--- /dev/null
+++ b/core/src/mindustryX/loader/Main.java
@@ -0,0 +1,130 @@
+package mindustryX.loader;
+
+import arc.*;
+import arc.struct.*;
+import arc.struct.ObjectMap.*;
+import arc.util.*;
+import arc.util.Log.*;
+import mindustry.*;
+import mindustry.core.*;
+import mindustry.game.EventType.*;
+import mindustry.mod.*;
+import mindustry.mod.Mods.*;
+
+import java.util.*;
+
+/** @author WayZer */
+@SuppressWarnings("unused")
+public class Main extends Mod{
+    static LoaderPlatform getLoaderPlatform(){
+        try{
+            if(Core.app.isDesktop()){
+                return new DesktopImpl();
+            }else if(Core.app.isAndroid()){
+                return (LoaderPlatform)Class.forName("mindustryX.loader.AndroidImpl").getConstructor().newInstance();
+            }
+        }catch(Exception e){
+            Log.err(e);
+        }
+        return null;
+    }
+    public Main(){
+        if(System.getProperty("MDTX-loaded") == null){
+            System.setProperty("MDTX-loaded", "true");
+            LoaderPlatform impl = getLoaderPlatform();
+            if(impl == null){
+                loadError("Not support platform, skip.");
+                return;
+            }
+            impl.withSafeClassloader("preload");
+        }else{
+            Log.infoTag("MindustryX", "Already inside MindustryX, cleanup outside");
+            try{
+                Class<?> mod = Core.class.getClassLoader().loadClass(Main.class.getName());
+                Reflect.invoke(mod, "cleanup");
+            }catch(Exception e){
+                Log.err(e);
+            }
+        }
+    }
+
+    private static LoaderPlatform impl;
+    private static boolean needClear = false;
+
+    private static void loadError(String msg){
+        Log.errTag("MindustryX", msg);
+        Events.on(ClientLoadEvent.class, (e) -> Vars.ui.showErrorMessage("Exception when load MindustryX:\n" + msg));
+    }
+
+    @SuppressWarnings("unused")//invoke in safe classloader
+    static void preload(){
+        impl = getLoaderPlatform();
+        if(!checkVersion()) return;
+        Core.app.post(Main::load);
+        try{
+            Thread.sleep(9999999999999999L);
+        }catch(InterruptedException e){
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static boolean checkVersion(){
+        if(!Version.type.equals("official") || !Version.combined().startsWith(Version.modifier)){
+            loadError("Not official version, skip: get " + Version.combined());
+            return false;
+        }
+
+        try{
+            loadError("Detected ARC client, skip: " + Reflect.get(Version.class, "arcbuild"));
+        }catch(Exception e){/*ignore*/}
+
+        ModMeta meta = null;
+        @SuppressWarnings("unchecked")
+        var metas = ((ObjectMap<Class<?>, ModMeta>)Reflect.get(Vars.mods, "metas"));
+        for(Entry<Class<?>, ModMeta> entry : metas.entries()){
+            if(entry.key.getName().equals(Main.class.getName())){//the class is not the same one.
+                meta = entry.value;
+                break;
+            }
+        }
+        Objects.requireNonNull(meta, "Can't get mod meta");
+        String version = meta.minGameVersion;
+        if(!Version.buildString().equals(version)){
+            loadError("Version not match, skip. (expect " + version + ", get " + Version.buildString() + ")");
+            return false;
+        }
+        return true;
+    }
+
+    @SuppressWarnings("unused")//reflect
+    public static void cleanup(){
+        if(!needClear) return;
+        needClear = false;
+        impl.cleanup();
+        Log.info("END cleanup");
+    }
+
+    static void load(){
+        ClassLoader classLoader = impl.createClassloader();
+        Log.info("=========== Start mindustryX client ===============");
+        needClear = true;
+        Threads.daemon(() -> {
+            try{
+                Thread.sleep(5000);
+                cleanup();
+            }catch(InterruptedException e){
+                throw new RuntimeException(e);
+            }
+        });
+        Vars.finishLaunch();//mark a successful launch
+        Log.logger = new NoopLogHandler();
+        try{
+            Thread.currentThread().setContextClassLoader(classLoader);
+            impl.launch(classLoader);
+            Thread.currentThread().interrupt();
+        }catch(Exception e){
+            e.printStackTrace(System.err);
+            Vars.launchIDFile.writeString(e.toString());//mark failed
+        }
+    }
+}
