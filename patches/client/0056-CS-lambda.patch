From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Sat, 20 Apr 2024 19:35:22 +0800
Subject: [PATCH] =?UTF-8?q?CS:=20=E5=87=8F=E5=B0=91=E9=83=A8=E5=88=86lambd?=
 =?UTF-8?q?a=E5=86=85=E5=AD=98=E5=88=86=E9=85=8D?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 core/src/mindustry/entities/Units.java        |  25 ++-
 .../mindustry/entities/bullet/BulletType.java |  11 +-
 .../src/mindustry/graphics/LightRenderer.java | 180 ++++++++++++------
 3 files changed, 147 insertions(+), 69 deletions(-)

diff --git a/core/src/mindustry/entities/Units.java b/core/src/mindustry/entities/Units.java
index e8194828463a91542bd9b1120df142bf959904cd..41033a224014d6f9423fa4c7e7bf50be806cf90f 100644
--- a/core/src/mindustry/entities/Units.java
+++ b/core/src/mindustry/entities/Units.java
@@ -265,6 +265,10 @@ public class Units{
         }
     }
 
+    private static float rangeL, xL, yL;
+    private static Team teamL;
+    private static Boolf<Unit> predicateL;
+    private static Sortf sortL;
     /** Returns the closest enemy of this team. Filter by predicate. */
     public static Unit closestEnemy(Team team, float x, float y, float range, Boolf<Unit> predicate){
         if(team == Team.derelict) return null;
@@ -273,11 +277,16 @@ public class Units{
         cdist = 0f;
         cpriority = -99999f;
 
+        xL = x;
+        yL = y;
+        rangeL = range;
+        teamL = team;
+        predicateL = predicate;
         nearbyEnemies(team, x - range, y - range, range*2f, range*2f, e -> {
-            if(e.dead() || !predicate.get(e) || e.team == Team.derelict || !e.targetable(team) || e.inFogTo(team)) return;
+            if(e.dead() || !predicateL.get(e) || e.team == Team.derelict || !e.targetable(teamL) || e.inFogTo(teamL)) return;
 
-            float dst2 = e.dst2(x, y) - (e.hitSize * e.hitSize);
-            if(dst2 < range*range && (result == null || dst2 < cdist || e.type.targetPriority > cpriority) && e.type.targetPriority >= cpriority){
+            float dst2 = e.dst2(xL, yL) - (e.hitSize * e.hitSize);
+            if(dst2 < rangeL*rangeL && (result == null || dst2 < cdist || e.type.targetPriority > cpriority) && e.type.targetPriority >= cpriority){
                 result = e;
                 cdist = dst2;
                 cpriority = e.type.targetPriority;
@@ -295,10 +304,16 @@ public class Units{
         cdist = 0f;
         cpriority = -99999f;
 
+        xL = x;
+        yL = y;
+        rangeL = range;
+        teamL = team;
+        predicateL = predicate;
+        sortL = sort;
         nearbyEnemies(team, x - range, y - range, range*2f, range*2f, e -> {
-            if(e.dead() || !predicate.get(e) || e.team == Team.derelict || !e.within(x, y, range + e.hitSize/2f) || !e.targetable(team) || e.inFogTo(team)) return;
+            if(e.dead() || !predicateL.get(e) || e.team == Team.derelict || !e.within(xL, yL, rangeL + e.hitSize/2f) || !e.targetable(teamL) || e.inFogTo(teamL)) return;
 
-            float cost = sort.cost(e, x, y);
+            float cost = sortL.cost(e, xL, yL);
             if((result == null || cost < cdist || e.type.targetPriority > cpriority) && e.type.targetPriority >= cpriority){
                 result = e;
                 cdist = cost;
diff --git a/core/src/mindustry/entities/bullet/BulletType.java b/core/src/mindustry/entities/bullet/BulletType.java
index 780978e4082ca872bae6d93b6c2305a08ac0d2e9..f8babc5f879c74f213b871a627031d52677d33e0 100644
--- a/core/src/mindustry/entities/bullet/BulletType.java
+++ b/core/src/mindustry/entities/bullet/BulletType.java
@@ -596,6 +596,7 @@ public class BulletType extends Content implements Cloneable{
         }
     }
 
+    private static Bullet argBullet;
     public void updateHoming(Bullet b){
         if(homingPower > 0.0001f && b.time >= homingDelay){
             float realAimX = b.aimX < 0 ? b.x : b.aimX;
@@ -603,20 +604,22 @@ public class BulletType extends Content implements Cloneable{
 
             Teamc target;
             //home in on allies if possible
+            argBullet = b;
             if(heals()){
                 target = Units.closestTarget(null, realAimX, realAimY, homingRange,
-                e -> e.checkTarget(collidesAir, collidesGround) && e.team != b.team && !b.hasCollided(e.id),
-                t -> collidesGround && (t.team != b.team || t.damaged()) && !b.hasCollided(t.id)
+                e -> e.checkTarget(collidesAir, collidesGround) && e.team != argBullet.team && !argBullet.hasCollided(e.id),
+                t -> collidesGround && (t.team != argBullet.team || t.damaged()) && !argBullet.hasCollided(t.id)
                 );
             }else{
                 if(b.aimTile != null && b.aimTile.build != null && b.aimTile.build.team != b.team && collidesGround && !b.hasCollided(b.aimTile.build.id)){
                     target = b.aimTile.build;
                 }else{
                     target = Units.closestTarget(b.team, realAimX, realAimY, homingRange,
-                        e -> e != null && e.checkTarget(collidesAir, collidesGround) && !b.hasCollided(e.id),
-                        t -> t != null && collidesGround && !b.hasCollided(t.id));
+                    e -> e != null && e.checkTarget(collidesAir, collidesGround) && !argBullet.hasCollided(e.id),
+                    t -> t != null && collidesGround && !argBullet.hasCollided(t.id));
                 }
             }
+            argBullet = null;
 
             if(target != null){
                 b.vel.setAngle(Angles.moveToward(b.rotation(), b.angleTo(target), homingPower * Time.delta * 50f));
diff --git a/core/src/mindustry/graphics/LightRenderer.java b/core/src/mindustry/graphics/LightRenderer.java
index a0cab5c03ea751a90a4bedb198af313c8c8d61b1..642f578131d5288ec4d62b353782fa4fe7f95d2d 100644
--- a/core/src/mindustry/graphics/LightRenderer.java
+++ b/core/src/mindustry/graphics/LightRenderer.java
@@ -8,6 +8,7 @@ import arc.math.*;
 import arc.math.geom.*;
 import arc.struct.*;
 import arc.util.*;
+import arc.util.pooling.*;
 import mindustry.*;
 
 import static mindustry.Vars.*;
@@ -16,7 +17,6 @@ import static mindustry.Vars.*;
 public class LightRenderer{
     private static final int scaling = 4;
 
-    private float[] vertices = new float[24];
     private FrameBuffer buffer = new FrameBuffer();
     private Seq<Runnable> lights = new Seq<>();
     private Seq<CircleLight> circles = new Seq<>(CircleLight.class);
@@ -52,19 +52,133 @@ public class LightRenderer{
 
         float res = color.toFloatBits();
         float xscl = Draw.xscl, yscl = Draw.yscl;
-        add(() -> {
+        add(Pools.get(RegionData.class, RegionData::new).obtain().set(res, opacity, xscl, yscl, region, x, y, rotation));
+    }
+
+    public void line(float x, float y, float x2, float y2, float stroke, Color tint, float alpha){
+        if(!enabled()) return;
+
+        add(Pools.get(LineData.class, LineData::new).obtain().set(tint, alpha, x2, x, y2, y, stroke));
+    }
+
+    public boolean enabled(){
+        return state.rules.lighting && state.rules.ambientLight.a > 0.0001f && renderer.drawLight;
+    }
+
+    public void draw(){
+        if(!Vars.enableLight){
+            lights.clear();
+            circleIndex = 0;
+            return;
+        }
+
+        if(circleRegion == null) circleRegion = Core.atlas.find("circle-shadow");
+
+        buffer.resize(Core.graphics.getWidth()/scaling, Core.graphics.getHeight()/scaling);
+
+        Draw.color();
+        buffer.begin(Color.clear);
+        Draw.sort(false);
+        Gl.blendEquationSeparate(Gl.funcAdd, Gl.max);
+        //apparently necessary
+        Blending.normal.apply();
+
+        for(Runnable run : lights){
+            run.run();
+        }
+        for(int i = 0; i < circleIndex; i++){
+            var cir = circles.items[i];
+            Draw.color(cir.color);
+            Draw.rect(circleRegion, cir.x, cir.y, cir.radius * 2, cir.radius * 2);
+        }
+        Draw.reset();
+        Draw.sort(true);
+        buffer.end();
+        Gl.blendEquationSeparate(Gl.funcAdd, Gl.funcAdd);
+
+        Draw.color();
+        Shaders.light.ambient.set(state.rules.ambientLight);
+        buffer.blit(Shaders.light);
+
+        Pools.freeAll(lights);
+        lights.clear();
+        circleIndex = 0;
+    }
+
+    static class CircleLight{
+        float x, y, color, radius;
+
+        public void set(float x, float y, float color, float radius){
+            this.x = x;
+            this.y = y;
+            this.color = color;
+            this.radius = radius;
+        }
+    }
+
+    private static class RegionData implements Runnable, Pool.Poolable{
+        private float res;
+        private float opacity;
+        private float xscl;
+        private float yscl;
+        private TextureRegion region;
+        private float x;
+        private float y;
+        private float rotation;
+
+        @Override
+        public void reset(){
+            region = null;
+        }
+
+        public RegionData set(float res, float opacity, float xscl, float yscl, TextureRegion region, float x, float y, float rotation){
+            this.res = res;
+            this.opacity = opacity;
+            this.xscl = xscl;
+            this.yscl = yscl;
+            this.region = region;
+            this.x = x;
+            this.y = y;
+            this.rotation = rotation;
+            return this;
+        }
+
+        @Override
+        public void run(){
             Draw.color(res);
             Draw.alpha(opacity);
             Draw.scl(xscl, yscl);
             Draw.rect(region, x, y, rotation);
             Draw.scl();
-        });
+        }
     }
 
-    public void line(float x, float y, float x2, float y2, float stroke, Color tint, float alpha){
-        if(!enabled()) return;
+    private static class LineData implements Runnable, Pool.Poolable{
+        private static final float[] vertices = new float[24];
+        private Color tint;
+        private float alpha;
+        private float x2;
+        private float x;
+        private float y2;
+        private float y;
+        private float stroke;
+
+        @Override
+        public void reset(){}
+
+        public LineData set(Color tint, float alpha, float x2, float x, float y2, float y, float stroke){
+            this.tint = tint;
+            this.alpha = alpha;
+            this.x2 = x2;
+            this.x = x;
+            this.y2 = y2;
+            this.y = y;
+            this.stroke = stroke;
+            return this;
+        }
 
-        add(() -> {
+        @Override
+        public void run(){
             Draw.color(tint, alpha);
 
             float rot = Mathf.angleExact(x2 - x, y2 - y);
@@ -178,60 +292,6 @@ public class LightRenderer{
             vertices[23] = 0;
 
             Draw.vert(ledge.texture, vertices, 0, vertices.length);
-        });
-    }
-
-    public boolean enabled(){
-        return state.rules.lighting && state.rules.ambientLight.a > 0.0001f && renderer.drawLight;
-    }
-
-    public void draw(){
-        if(!Vars.enableLight){
-            lights.clear();
-            circleIndex = 0;
-            return;
-        }
-
-        if(circleRegion == null) circleRegion = Core.atlas.find("circle-shadow");
-
-        buffer.resize(Core.graphics.getWidth()/scaling, Core.graphics.getHeight()/scaling);
-
-        Draw.color();
-        buffer.begin(Color.clear);
-        Draw.sort(false);
-        Gl.blendEquationSeparate(Gl.funcAdd, Gl.max);
-        //apparently necessary
-        Blending.normal.apply();
-
-        for(Runnable run : lights){
-            run.run();
-        }
-        for(int i = 0; i < circleIndex; i++){
-            var cir = circles.items[i];
-            Draw.color(cir.color);
-            Draw.rect(circleRegion, cir.x, cir.y, cir.radius * 2, cir.radius * 2);
-        }
-        Draw.reset();
-        Draw.sort(true);
-        buffer.end();
-        Gl.blendEquationSeparate(Gl.funcAdd, Gl.funcAdd);
-
-        Draw.color();
-        Shaders.light.ambient.set(state.rules.ambientLight);
-        buffer.blit(Shaders.light);
-
-        lights.clear();
-        circleIndex = 0;
-    }
-
-    static class CircleLight{
-        float x, y, color, radius;
-
-        public void set(float x, float y, float color, float radius){
-            this.x = x;
-            this.y = y;
-            this.color = color;
-            this.radius = radius;
         }
     }
 }
