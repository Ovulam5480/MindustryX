From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Wed, 24 Jan 2024 15:39:50 +0800
Subject: [PATCH] ARC merged
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Way-Zer:
removed: LabelController,ARCChat,QuickCameraTable,changelogreaded, UpdateDialog, 主页标语(联网), 学术日报, 热更新(无效), 检查更新, arcPlayerEffect(VIP), District(区域规划器)
partially remove `themeColor`
remove WindowManager.java
还原maxSchematicSize设置，优化ARCUnits
remove NumberFormat(已替代)
PICK 9eaa74b9 优化单位绘图执行逻辑，减少性能开销。同时不开启显示其他队伍状态时不绘制任何单位信息（除了碰撞箱）
  Lucky Clover <jmj18795967847@gmail.com> on 2024/2/29 at 10:09

MinRi2: 整理AuxilliaryTable;improve drawText;PausedDialog重排

Cong0707: remove AboutCN_ARC

fixup! ARC merged
微微简化

单位能力显示 优化
way-zer <himc.wicp@gmail.com> on 2024/4/18 at 23:22

remove getThemeColor()
way-zer <himc.wicp@gmail.com> on 2024/4/20 at 22:06
---
 core/src/mindustry/ai/BlockIndexer.java       |  116 ++
 core/src/mindustry/arcModule/ARCVars.java     |   42 +
 .../mindustry/arcModule/DrawUtilities.java    |  111 ++
 .../src/mindustry/arcModule/ElementUtils.java |   64 +
 core/src/mindustry/arcModule/RFuncs.java      |  236 +++
 core/src/mindustry/arcModule/ai/ATRIAI.java   |  208 +++
 .../mindustry/arcModule/ai/ArcBuilderAI.java  |  180 +++
 .../mindustry/arcModule/ai/ArcMinerAI.java    |  130 ++
 .../mindustry/arcModule/ai/ArcRepairAI.java   |   73 +
 .../mindustry/arcModule/draw/ARCBuilds.java   |  128 ++
 .../mindustry/arcModule/draw/ARCUnits.java    |  333 ++++
 .../arcModule/toolpack/arcChatPicture.java    |  205 +++
 .../arcModule/toolpack/arcScanMode.java       |  449 ++++++
 .../arcModule/toolpack/arcScanner.java        |  256 ++++
 .../arcModule/toolpack/arcWaveSpawner.java    |  243 +++
 .../arcModule/toolpack/picToMindustry.java    |  343 +++++
 core/src/mindustry/arcModule/ui/ARCUI.java    |   46 +
 .../arcModule/ui/ArcWaveInfoDialog.java       | 1115 ++++++++++++++
 .../arcModule/ui/OtherCoreItemDisplay.java    |  225 +++
 .../src/mindustry/arcModule/ui/PowerInfo.java |   93 ++
 .../arcModule/ui/RCoreItemsDisplay.java       |  180 +++
 core/src/mindustry/arcModule/ui/RStyles.java  |   86 ++
 .../arcModule/ui/auxilliary/AITools.java      |  125 ++
 .../ui/auxilliary/AuxilliaryTable.java        |   63 +
 .../ui/auxilliary/BaseToolsTable.java         |   36 +
 .../arcModule/ui/auxilliary/MapInfoTable.java |  152 ++
 .../arcModule/ui/auxilliary/MarkTable.java    |   55 +
 .../ui/auxilliary/MobileScriptButtons.java    |   52 +
 .../ui/auxilliary/ScriptButtons.java          |   86 ++
 .../ui/auxilliary/WaveInfoTable.java          |  137 ++
 .../ui/dialogs/AchievementsDialog.java        |  155 ++
 .../ui/dialogs/BlockSelectDialog.java         |   58 +
 .../arcModule/ui/dialogs/MessageDialog.java   |  425 ++++++
 .../arcModule/ui/dialogs/MusicDialog.java     | 1354 +++++++++++++++++
 .../arcModule/ui/dialogs/USIDDialog.java      |   82 +
 .../ui/quickTool/AdvanceBuildTool.java        |  435 ++++++
 .../ui/quickTool/HudSettingsTable.java        |  349 +++++
 .../ui/quickTool/QuickToolTable.java          |   13 +
 core/src/mindustry/core/NetClient.java        |   13 +
 core/src/mindustry/core/Renderer.java         |   13 +-
 core/src/mindustry/core/UI.java               |   29 +-
 core/src/mindustry/editor/EditorTool.java     |    2 +-
 core/src/mindustry/editor/MapEditor.java      |    7 +-
 .../src/mindustry/editor/MapEditorDialog.java |   54 +-
 core/src/mindustry/editor/MapInfoDialog.java  |  148 +-
 .../src/mindustry/editor/MapResizeDialog.java |    4 +-
 core/src/mindustry/editor/MapView.java        |   44 +-
 core/src/mindustry/entities/EntityGroup.java  |   19 +-
 .../entities/abilities/ShieldArcAbility.java  |    3 +-
 .../mindustry/entities/comp/BuildingComp.java |   39 +-
 .../mindustry/entities/comp/PlayerComp.java   |   26 +-
 .../mindustry/entities/comp/ShieldComp.java   |    6 +
 .../mindustry/entities/comp/StatusComp.java   |   12 +
 core/src/mindustry/game/Schematic.java        |  163 ++
 core/src/mindustry/game/Schematics.java       |   11 +-
 core/src/mindustry/game/Universe.java         |    2 +-
 .../src/mindustry/graphics/BlockRenderer.java |   14 +-
 core/src/mindustry/graphics/Drawf.java        |   54 +
 core/src/mindustry/graphics/MenuRenderer.java |  114 +-
 .../mindustry/graphics/MinimapRenderer.java   |   51 +-
 .../mindustry/graphics/OverlayRenderer.java   |   83 +-
 core/src/mindustry/input/Binding.java         |    5 +
 core/src/mindustry/input/DesktopInput.java    |  112 +-
 core/src/mindustry/input/InputHandler.java    |  102 +-
 core/src/mindustry/input/MobileInput.java     |   17 +-
 core/src/mindustry/input/Placement.java       |   79 +-
 core/src/mindustry/logic/LCanvas.java         |   95 +-
 core/src/mindustry/logic/LExecutor.java       |   14 +-
 core/src/mindustry/logic/LogicDialog.java     |  178 ++-
 core/src/mindustry/maps/MapPreviewLoader.java |    4 +-
 core/src/mindustry/service/GameService.java   |   14 +-
 core/src/mindustry/service/SStat.java         |    8 +
 core/src/mindustry/type/UnitType.java         |  152 +-
 core/src/mindustry/type/Weapon.java           |   41 +-
 core/src/mindustry/ui/Fonts.java              |   14 +-
 core/src/mindustry/ui/ItemImage.java          |   13 +
 core/src/mindustry/ui/Minimap.java            |   17 +-
 .../ui/dialogs/ContentInfoDialog.java         |   51 +-
 .../ui/dialogs/CustomRulesDialog.java         |  115 +-
 .../mindustry/ui/dialogs/DatabaseDialog.java  |   12 +-
 core/src/mindustry/ui/dialogs/JoinDialog.java |   15 +
 .../mindustry/ui/dialogs/KeybindDialog.java   |    9 +-
 core/src/mindustry/ui/dialogs/ModsDialog.java |    4 +
 .../mindustry/ui/dialogs/PausedDialog.java    |   12 +-
 .../mindustry/ui/dialogs/PlanetDialog.java    |  114 +-
 .../ui/dialogs/SchematicsDialog.java          |  414 ++++-
 .../ui/dialogs/SettingsMenuDialog.java        |    4 +
 .../mindustry/ui/fragments/ChatFragment.java  |   29 +-
 .../ui/fragments/ConsoleFragment.java         |    2 +
 .../mindustry/ui/fragments/HudFragment.java   |  357 ++++-
 .../mindustry/ui/fragments/MenuFragment.java  |  132 +-
 .../ui/fragments/PlacementFragment.java       |  331 +++-
 .../ui/fragments/PlayerListFragment.java      |  204 ++-
 core/src/mindustry/world/Block.java           |   77 +-
 core/src/mindustry/world/Build.java           |   50 +
 .../world/blocks/ConstructBlock.java          |   44 +-
 .../mindustry/world/blocks/ItemSelection.java |    3 +-
 .../world/blocks/defense/ForceProjector.java  |   20 +
 .../world/blocks/defense/MendProjector.java   |   32 +-
 .../blocks/defense/OverdriveProjector.java    |    7 +-
 .../turrets/ContinuousLiquidTurret.java       |   67 +
 .../blocks/defense/turrets/ItemTurret.java    |   69 +
 .../blocks/defense/turrets/LiquidTurret.java  |   28 +
 .../blocks/defense/turrets/PowerTurret.java   |   24 +
 .../blocks/defense/turrets/ReloadTurret.java  |   13 +
 .../world/blocks/defense/turrets/Turret.java  |   23 +
 .../world/blocks/distribution/Conveyor.java   |    2 +-
 .../blocks/distribution/DirectionBridge.java  |    8 +
 .../world/blocks/distribution/ItemBridge.java |   12 +
 .../world/blocks/distribution/MassDriver.java |   48 +
 .../world/blocks/liquid/Conduit.java          |    2 +-
 .../world/blocks/logic/LogicBlock.java        |   96 +-
 .../world/blocks/logic/MemoryBlock.java       |  107 ++
 .../world/blocks/power/PowerGraph.java        |    3 +
 .../world/blocks/production/Drill.java        |   42 +-
 .../blocks/production/GenericCrafter.java     |   29 +
 .../world/blocks/storage/CoreBlock.java       |    9 +
 .../world/blocks/units/Reconstructor.java     |   16 +
 .../world/blocks/units/UnitAssembler.java     |   16 +
 .../world/blocks/units/UnitFactory.java       |   18 +-
 core/src/mindustry/world/meta/StatValues.java |   27 +-
 core/src/mindustryX/Hooks.java                |    9 +
 core/src/mindustryX/features/StatExt.java     |    2 +-
 123 files changed, 12477 insertions(+), 446 deletions(-)
 create mode 100644 core/src/mindustry/arcModule/ARCVars.java
 create mode 100644 core/src/mindustry/arcModule/DrawUtilities.java
 create mode 100644 core/src/mindustry/arcModule/ElementUtils.java
 create mode 100644 core/src/mindustry/arcModule/RFuncs.java
 create mode 100644 core/src/mindustry/arcModule/ai/ATRIAI.java
 create mode 100644 core/src/mindustry/arcModule/ai/ArcBuilderAI.java
 create mode 100644 core/src/mindustry/arcModule/ai/ArcMinerAI.java
 create mode 100644 core/src/mindustry/arcModule/ai/ArcRepairAI.java
 create mode 100644 core/src/mindustry/arcModule/draw/ARCBuilds.java
 create mode 100644 core/src/mindustry/arcModule/draw/ARCUnits.java
 create mode 100644 core/src/mindustry/arcModule/toolpack/arcChatPicture.java
 create mode 100644 core/src/mindustry/arcModule/toolpack/arcScanMode.java
 create mode 100644 core/src/mindustry/arcModule/toolpack/arcScanner.java
 create mode 100644 core/src/mindustry/arcModule/toolpack/arcWaveSpawner.java
 create mode 100644 core/src/mindustry/arcModule/toolpack/picToMindustry.java
 create mode 100644 core/src/mindustry/arcModule/ui/ARCUI.java
 create mode 100644 core/src/mindustry/arcModule/ui/ArcWaveInfoDialog.java
 create mode 100644 core/src/mindustry/arcModule/ui/OtherCoreItemDisplay.java
 create mode 100644 core/src/mindustry/arcModule/ui/PowerInfo.java
 create mode 100644 core/src/mindustry/arcModule/ui/RCoreItemsDisplay.java
 create mode 100644 core/src/mindustry/arcModule/ui/RStyles.java
 create mode 100644 core/src/mindustry/arcModule/ui/auxilliary/AITools.java
 create mode 100644 core/src/mindustry/arcModule/ui/auxilliary/AuxilliaryTable.java
 create mode 100644 core/src/mindustry/arcModule/ui/auxilliary/BaseToolsTable.java
 create mode 100644 core/src/mindustry/arcModule/ui/auxilliary/MapInfoTable.java
 create mode 100644 core/src/mindustry/arcModule/ui/auxilliary/MarkTable.java
 create mode 100644 core/src/mindustry/arcModule/ui/auxilliary/MobileScriptButtons.java
 create mode 100644 core/src/mindustry/arcModule/ui/auxilliary/ScriptButtons.java
 create mode 100644 core/src/mindustry/arcModule/ui/auxilliary/WaveInfoTable.java
 create mode 100644 core/src/mindustry/arcModule/ui/dialogs/AchievementsDialog.java
 create mode 100644 core/src/mindustry/arcModule/ui/dialogs/BlockSelectDialog.java
 create mode 100644 core/src/mindustry/arcModule/ui/dialogs/MessageDialog.java
 create mode 100644 core/src/mindustry/arcModule/ui/dialogs/MusicDialog.java
 create mode 100644 core/src/mindustry/arcModule/ui/dialogs/USIDDialog.java
 create mode 100644 core/src/mindustry/arcModule/ui/quickTool/AdvanceBuildTool.java
 create mode 100644 core/src/mindustry/arcModule/ui/quickTool/HudSettingsTable.java
 create mode 100644 core/src/mindustry/arcModule/ui/quickTool/QuickToolTable.java

diff --git a/core/src/mindustry/ai/BlockIndexer.java b/core/src/mindustry/ai/BlockIndexer.java
index 0cae6ca7900a2a6961fd659fa28b3eea50ce50d0..3b9db41b63c01d5e4b7810ae24095c835aedefd7 100644
--- a/core/src/mindustry/ai/BlockIndexer.java
+++ b/core/src/mindustry/ai/BlockIndexer.java
@@ -42,6 +42,14 @@ public class BlockIndexer{
     /** Array used for returning and reusing. */
     private Seq<Building> breturnArray = new Seq<>(Building.class);
 
+    /** Stores all wallore quadrants on the map. Maps ID to qX to qY to a list of tiles with that ore. */
+    private IntSeq[][][] oresWall;
+    /** All wallores available on this map. */
+    private ObjectIntMap<Item> allOresWall = new ObjectIntMap<>();
+
+    public Integer[] floorOresCount = new Integer[content.blocks().size +1];
+    public Integer[] wallOresCount = new Integer[content.blocks().size +1];
+
     public BlockIndexer(){
         clearFlags();
 
@@ -61,7 +69,15 @@ public class BlockIndexer{
             clearFlags();
 
             allOres.clear();
+            allOresWall.clear();
+            floorOresCount = new Integer[content.blocks().size +1];
+            wallOresCount = new Integer[content.blocks().size +1];
+            for (int ls=0;ls<content.blocks().size;ls++){
+                floorOresCount[ls] = 0;
+                wallOresCount[ls] = 0;
+            }
             ores = new IntSeq[content.items().size][][];
+            oresWall = new IntSeq[content.items().size][][];
             quadWidth = Mathf.ceil(world.width() / (float)quadrantSize);
             quadHeight = Mathf.ceil(world.height() / (float)quadrantSize);
             blocksPresent = new boolean[content.blocks().size];
@@ -94,8 +110,36 @@ public class BlockIndexer{
                         }
                         ores[drop.id][qx][qy].add(tile.pos());
                         allOres.increment(drop);
+                        if(tile.overlay().itemDrop!=null) floorOresCount[tile.overlay().id] +=1;
+                        else if(tile.floor().itemDrop!=null) floorOresCount[tile.floor().id] +=1;
+                    }else{
+                        if(oresWall[drop.id] == null){
+                            oresWall[drop.id] = new IntSeq[quadWidth][quadHeight];
+                        }
+                        if(oresWall[drop.id][qx][qy] == null){
+                            oresWall[drop.id][qx][qy] = new IntSeq(false, 16);
+                        }
+                        oresWall[drop.id][qx][qy].add(tile.pos());
+                        allOresWall.increment(drop);
+                        if(tile.overlay().itemDrop!=null) wallOresCount[tile.overlay().id] +=1;
                     }
                 }
+                if(tile.block()!=null && tile.block().itemDrop!=null){
+                    int qx = (tile.x / quadrantSize);
+                    int qy = (tile.y / quadrantSize);
+                    if(oresWall[tile.block().itemDrop.id] == null){
+                        oresWall[tile.block().itemDrop.id] = new IntSeq[quadWidth][quadHeight];
+                    }
+                    if(oresWall[tile.block().itemDrop.id][qx][qy] == null){
+                        oresWall[tile.block().itemDrop.id][qx][qy] = new IntSeq(false, 16);
+                    }
+                    oresWall[tile.block().itemDrop.id][qx][qy].add(tile.pos());
+                    allOresWall.increment(tile.block().itemDrop);
+                    wallOresCount[tile.block().id] +=1;
+                }
+                if(tile.block()!=null && tile.floor().liquidDrop!=null){
+                    floorOresCount[tile.floor().id] +=1;
+                }
             }
         });
     }
@@ -167,6 +211,50 @@ public class BlockIndexer{
                 seq.removeValue(pos);
                 allOres.increment(drop, -1);
             }
+
+
+            ///wallore
+            if(oresWall[drop.id] == null){
+                oresWall[drop.id] = new IntSeq[quadWidth][quadHeight];
+            }
+            if(oresWall[drop.id][qx][qy] == null){
+                oresWall[drop.id][qx][qy] = new IntSeq(false, 16);
+            }
+
+            pos = tile.pos();
+            seq = oresWall[drop.id][qx][qy];
+            //when the drop can be mined, record the ore position
+            if(tile.block() != Blocks.air && !seq.contains(pos)){
+                seq.add(pos);
+                allOresWall.increment(drop);
+            }else{
+                //otherwise, it likely became blocked, remove it (even if it wasn't there)
+                seq.removeValue(pos);
+                allOresWall.increment(drop, -1);
+            }
+        }
+        else if(tile.block()!=null && tile.block().itemDrop!=null){
+            int qx = tile.x / quadrantSize;
+            int qy = tile.y / quadrantSize;
+            ///wallore
+            if(oresWall[tile.block().itemDrop.id] == null){
+                oresWall[tile.block().itemDrop.id] = new IntSeq[quadWidth][quadHeight];
+            }
+            if(oresWall[tile.block().itemDrop.id][qx][qy] == null){
+                oresWall[tile.block().itemDrop.id][qx][qy] = new IntSeq(false, 16);
+            }
+
+            int pos = tile.pos();
+            var seq = oresWall[tile.block().itemDrop.id][qx][qy];
+            //when the drop can be mined, record the ore position
+            if(!seq.contains(pos)){
+                seq.add(pos);
+                allOresWall.increment(tile.block().itemDrop);
+            }else{
+                //otherwise, it likely became blocked, remove it (even if it wasn't there)
+                seq.removeValue(pos);
+                allOresWall.increment(tile.block().itemDrop, -1);
+            }
         }
 
     }
@@ -193,6 +281,10 @@ public class BlockIndexer{
         return allOres.get(item) > 0;
     }
 
+    public boolean hasOreWall(Item item){
+        return allOresWall.get(item) > 0;
+    }
+
     /** Returns all damaged tiles by team. */
     public Seq<Building> getDamaged(Team team){
         if(damagedTiles[team.id] == null){
@@ -436,6 +528,30 @@ public class BlockIndexer{
         return findClosestOre(unit.x, unit.y, item);
     }
 
+    public Tile findClosestWallOre(float xp, float yp, Item item){
+        if(oresWall[item.id] != null){
+            float minDst = 0f;
+            Tile closest = null;
+            for(int qx = 0; qx < quadWidth; qx++){
+                for(int qy = 0; qy < quadHeight; qy++){
+                    var arr = oresWall[item.id][qx][qy];
+                    if(arr != null && arr.size > 0){
+                        Tile tile = world.tile(arr.first());
+                        if(tile.block() != Blocks.air){
+                            float dst = Mathf.dst2(xp, yp, tile.worldx(), tile.worldy());
+                            if(closest == null || dst < minDst){
+                                closest = tile;
+                                minDst = dst;
+                            }
+                        }
+                    }
+                }
+            }
+            return closest;
+        }
+
+        return null;
+    }
     private void process(Tile tile){
         var team = tile.team();
         //only process entity changes with centered tiles
diff --git a/core/src/mindustry/arcModule/ARCVars.java b/core/src/mindustry/arcModule/ARCVars.java
new file mode 100644
index 0000000000000000000000000000000000000000..a03281bf3fc7f2edbb81b3e354fb3097bfa69d21
--- /dev/null
+++ b/core/src/mindustry/arcModule/ARCVars.java
@@ -0,0 +1,42 @@
+package mindustry.arcModule;
+
+import arc.*;
+import arc.graphics.*;
+import mindustry.*;
+import mindustry.arcModule.ui.*;
+import mindustry.core.*;
+import mindustry.game.*;
+import mindustry.graphics.*;
+
+import static arc.Core.settings;
+
+public class ARCVars{
+    public static ARCUI arcui = new ARCUI();
+    public static boolean limitUpdate = false;
+    public static int limitDst = 0;
+    public static final int maxBuildPlans = 100;
+    public static String arcVersionPrefix = "<ARC~" + Version.mdtXBuild + ">";
+
+    private static Boolean arcInfoControl = false;
+
+    static{
+        // 减少性能开销
+        Events.run(EventType.Trigger.update, () -> {
+            arcInfoControl = Core.settings.getBool("showOtherTeamState");
+            limitUpdate = Core.settings.getBool("limitUpdate");
+        });
+    }
+
+    public static Color getPlayerEffectColor(){
+        try{
+            return Color.valueOf(settings.getString("playerEffectColor"));
+        }catch(Exception e){
+            return Pal.accent;
+        }
+    }
+
+    public static Boolean arcInfoControl(Team team){
+        return team == Vars.player.team() || arcInfoControl ||
+        Vars.player.team().id == 255 || Vars.state.rules.mode() != Gamemode.pvp;
+    }
+}
diff --git a/core/src/mindustry/arcModule/DrawUtilities.java b/core/src/mindustry/arcModule/DrawUtilities.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e03bf73d27b01ac1c27620e8a81ac9fbb23d200
--- /dev/null
+++ b/core/src/mindustry/arcModule/DrawUtilities.java
@@ -0,0 +1,111 @@
+package mindustry.arcModule;
+
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.math.*;
+import arc.math.geom.*;
+import arc.util.*;
+import arc.util.pooling.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+
+import static arc.graphics.g2d.Draw.color;
+import static arc.graphics.g2d.Lines.*;
+
+public class DrawUtilities{
+    private static final Vec2 vector = new Vec2();
+
+    public static float drawText(String text, float scl, float dx, float dy, int align){
+        return drawText(text, scl, dx, dy, Color.white, align);
+    }
+
+    public static float drawText(String text, float scl, float dx, float dy, Color color, int align){
+        return drawText(Fonts.outline, text, scl, dx, dy, color, align);
+    }
+
+    /**
+     * 绘制文本
+     * <p>
+     * 文本框在'给定方位'对齐'给定坐标'
+     * <p>
+     * 注意：当对齐方位没有指定横向方位时，默认居中对齐
+     * <p>
+     * 例如：{@code drawText(Fonts.outline, "Test", 1f, 3f, 3f, Color.white, Align.bottom)}
+     * "Test"文本框的 '正下方' 将对齐坐标(3, 3)
+     * @param align 文本对齐方位
+     * @return 返回绘制文本的高度
+     */
+    public static float drawText(Font font, String text, float scl, float x, float y, Color color, int align){
+        if(!Align.isLeft(align) && !Align.isRight(align)){
+            align |= Align.center;
+        }
+        GlyphLayout layout = Pools.obtain(GlyphLayout.class, GlyphLayout::new);
+        boolean ints = font.usesIntegerPositions();
+        font.setUseIntegerPositions(false);
+        font.getData().setScale(scl);
+        layout.setText(font, text);
+
+        float height = layout.height;
+
+        /* draw 的原点在文本左上角 */
+        if(Align.isBottom(align)){
+            y += height;
+        }else if((align & Align.center) == 0){
+            y += height / 2f;
+        }
+
+        font.setColor(color);
+        font.draw(text, x, y, align);
+
+        font.setUseIntegerPositions(ints);
+        font.setColor(Color.white);
+        font.getData().setScale(1f);
+        Draw.reset();
+        Pools.free(layout);
+
+        return height;
+    }
+
+    public static void arcDashCircling(float x, float y, float radius, float speed){
+        arcDashCircle(x, y, radius, Time.time * speed);
+    }
+
+    public static void arcDashCircle(float x, float y, float radius, float rotation){
+        float scaleFactor = 0.6f;
+        int sides = 10 + (int)(radius * scaleFactor);
+        if(sides % 2 == 1) sides++;
+
+        vector.set(0, 0);
+
+        for(int i = 0; i < sides; i += 2){
+            vector.set(radius, 0).rotate(360f / sides * i + 90 + rotation);
+            float x1 = vector.x;
+            float y1 = vector.y;
+
+            vector.set(radius, 0).rotate(360f / sides * (i + 1) + 90 + rotation);
+
+            line(x1 + x, y1 + y, vector.x + x, vector.y + y);
+        }
+    }
+
+    public static void drawNSideRegion(float x, float y, int n, float range, float rotation, Color color, float fraction, TextureRegion region, boolean regionColor){
+        Draw.z(Layer.effect - 2f);
+        color(color);
+
+        stroke(2f);
+
+        for(int i = 0; i < n; i++){
+            float frac = 360f * (1 - fraction * n) / n / 2;
+            float rot = rotation + i * 360f / n + frac;
+            if(!regionColor){
+                color(color);
+                arc(x, y, range, 0.25f, rot, (int)(50 + range / 10));
+                color();
+            }else{
+                arc(x, y, range, 0.25f, rot, (int)(50 + range / 10));
+            }
+            Draw.rect(region, x + range * Mathf.cos((float)Math.toRadians(rot - frac)), y + range * Mathf.sin((float)Math.toRadians(rot - frac)), 12f, 12f);
+        }
+        Draw.reset();
+    }
+}
diff --git a/core/src/mindustry/arcModule/ElementUtils.java b/core/src/mindustry/arcModule/ElementUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..13f788de1d764bc71e2c3cda3b8cfff28c76743c
--- /dev/null
+++ b/core/src/mindustry/arcModule/ElementUtils.java
@@ -0,0 +1,64 @@
+package mindustry.arcModule;
+
+import arc.graphics.*;
+import arc.scene.*;
+import arc.scene.ui.*;
+import arc.scene.ui.Tooltip.*;
+import arc.scene.ui.layout.*;
+import mindustry.ui.*;
+
+import static mindustry.gen.Tex.*;
+import static mindustry.ui.Styles.*;
+
+public class ElementUtils{
+    public static TextButton.TextButtonStyle
+    textStyle = new TextButton.TextButtonStyle(){{
+        down = flatOver;
+        up = pane;
+        over = flatDownBase;
+        font = Fonts.def;
+        fontColor = Color.white;
+        disabledFontColor = Color.gray;
+        checked = flatDown;
+    }},
+    NCtextStyle = new TextButton.TextButtonStyle(){{
+        down = flatOver;
+        up = pane;
+        over = flatDownBase;
+        font = Fonts.def;
+        fontColor = Color.white;
+        disabledFontColor = Color.gray;
+    }};
+
+    public static <T extends Element> T tooltip(T element, String text){
+        return tooltip(element, text, true);
+    }
+
+    public static <T extends Element> T tooltip(T element, String text, boolean allowMobile){
+        Tooltip tooltip = Tooltips.getInstance().create(text);
+        tooltip.allowMobile = allowMobile;
+
+        element.addListener(tooltip);
+        return element;
+    }
+
+    public static abstract class ToolTable extends Table{
+        public String icon = "";
+        public boolean expand = false;
+
+
+        public void rebuild(){
+            clear();
+            table().growX().left();
+            if(expand){
+                buildTable();
+            }
+            button((expand ? "" : "[lightgray]") + icon, textStyle, () -> {
+                expand = !expand;
+                rebuild();
+            }).right().width(40f).minHeight(40f).fillY();
+        }
+
+        protected abstract void buildTable();
+    }
+}
diff --git a/core/src/mindustry/arcModule/RFuncs.java b/core/src/mindustry/arcModule/RFuncs.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb8aa6278b7ef1da1ec67cd1602b28b0b53993c9
--- /dev/null
+++ b/core/src/mindustry/arcModule/RFuncs.java
@@ -0,0 +1,236 @@
+package mindustry.arcModule;
+
+import arc.*;
+import arc.files.*;
+import arc.func.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.math.geom.*;
+import arc.util.*;
+import mindustry.*;
+import mindustry.content.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.input.*;
+import mindustry.ui.*;
+import mindustry.ui.fragments.*;
+import mindustry.world.*;
+import mindustry.world.blocks.logic.*;
+import mindustryX.features.ui.*;
+
+import static arc.Core.camera;
+import static arc.graphics.Color.RGBtoHSV;
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+
+public class RFuncs{
+    static final int msgSeperator = 145;
+
+    public interface Stringf<T>{
+        String get(T i);
+    }
+
+    public static void arcSetCamera(Position pos){
+        if(control.input instanceof DesktopInput input){
+            input.panning = true;
+        }
+        camera.position.set(pos);
+    }
+
+    public static void sendChatMsg(String msg){
+        for(int i = 0; i < msg.length() / (float)msgSeperator; i++){
+            Call.sendChatMessage(msg.substring(i * msgSeperator, Math.min(msg.length(), (i + 1) * msgSeperator)));
+        }
+    }
+
+    public static void colorizeContent(){
+        if(!Core.settings.getBool("colorizedContent")) return;
+        content.items().each(c -> c.localizedName = colorized(c.color, c.localizedName));
+        content.liquids().each(c -> c.localizedName = colorized(c.color, c.localizedName));
+        content.statusEffects().each(c -> c.localizedName = colorized(c.color, c.localizedName));
+        content.planets().each(c -> c.localizedName = colorized(c.atmosphereColor, c.localizedName));
+        content.blocks().each(c -> {
+            if(c.hasColor) c.localizedName = colorized(blockColor(c), c.localizedName);
+            else if(c.itemDrop != null) c.localizedName = colorized(c.itemDrop.color, c.localizedName);
+        });
+    }
+
+    private static String colorized(Color color, String name){
+        return "[#" + color + "]" + name + "[]";
+    }
+
+    private static Color blockColor(Block block){
+        Color bc = new Color(0, 0, 0, 1);
+        Color bestColor = new Color(0, 0, 0, 1);
+        int highestS = 0;
+        if(!block.synthetic()){
+            PixmapRegion image = Core.atlas.getPixmap(block.fullIcon);
+            for(int x = 0; x < image.width; x++)
+                for(int y = 0; y < image.height; y++){
+                    bc.set(image.get(x, y));
+                    int s = RGBtoHSV(bc)[1] * RGBtoHSV(bc)[1] + RGBtoHSV(bc)[2] + RGBtoHSV(bc)[2];
+                    if(s > highestS){
+                        highestS = s;
+                        bestColor = bc;
+                    }
+                }
+        }else{
+            return block.mapColor.cpy().mul(1.2f);
+        }
+        return bestColor;
+    }
+
+    public static String arcShareWaveInfo(int waves){
+        if(!state.rules.waves) return " ";
+        StringBuilder builder = new StringBuilder(getPrefix("orange", "Wave"));
+        builder.append("标记了第").append(waves).append("波");
+        if(waves < state.wave){
+            builder.append("。");
+        }else{
+            if(waves > state.wave){
+                builder.append("，还有").append(waves - state.wave).append("波");
+            }
+            int timer = (int)(state.wavetime + (waves - state.wave) * state.rules.waveSpacing);
+            builder.append("[").append(fixedTime(timer)).append("]。");
+        }
+
+        builder.append(arcWaveInfo(waves));
+        return builder.toString();
+    }
+
+    public static String calWaveTimer(){
+        StringBuilder waveTimer = new StringBuilder();
+        waveTimer.append("[orange]");
+        int m = ((int)state.wavetime / 60) / 60;
+        int s = ((int)state.wavetime / 60) % 60;
+        int ms = (int)state.wavetime % 60;
+        if(m > 0){
+            waveTimer.append(m).append("[white]: [orange]");
+            if(s < 10){
+                waveTimer.append("0");
+            }
+            waveTimer.append(s).append("[white]min");
+        }else{
+            waveTimer.append(s).append("[white].[orange]").append(ms).append("[white]s");
+        }
+        return waveTimer.toString();
+    }
+
+    public static String arcWaveInfo(int waves){
+        StringBuilder builder = new StringBuilder();
+        if(state.rules.attackMode){
+            int sum = Math.max(state.teams.present.sum(t -> t.team != player.team() ? t.cores.size : 0), 1) + Vars.spawner.countSpawns();
+            builder.append("包含(×").append(sum).append(")");
+        }else{
+            builder.append("包含(×").append(Vars.spawner.countSpawns()).append("):");
+        }
+        for(SpawnGroup group : state.rules.spawns){
+            if(group.getSpawned(waves - 1) > 0){
+                builder.append((char)Fonts.getUnicode(group.type.name)).append("(");
+                if(group.effect != StatusEffects.invincible && group.effect != StatusEffects.none && group.effect != null){
+                    builder.append((char)Fonts.getUnicode(group.effect.name)).append("|");
+                }
+                if(group.getShield(waves - 1) > 0){
+                    builder.append(FormatDefault.format(group.getShield(waves - 1))).append("|");
+                }
+                builder.append(group.getSpawned(waves - 1)).append(")");
+            }
+        }
+        return builder.toString();
+    }
+
+    public static String arcColorTime(int timer){
+        return arcColorTime(timer, true);
+    }
+
+    public static String arcColorTime(int timer, boolean units){
+        StringBuilder str = new StringBuilder();
+        String color = timer > 0 ? "[orange]" : "[acid]";
+        timer = Math.abs(timer);
+        str.append(color);
+        int m = timer / 60 / 60;
+        int s = timer / 60 % 60;
+        int ms = timer % 60;
+        if(m > 0){
+            str.append(m).append("[white]: ").append(color);
+            if(s < 10){
+                str.append("0");
+            }
+
+            str.append(s);
+            if(units) str.append("[white]min");
+        }else{
+            str.append(s).append("[white].").append(color).append(ms);
+            if(units) str.append("[white]s");
+        }
+        return str.toString();
+    }
+
+    public static String fixedTime(int timer, boolean units){
+        StringBuilder str = new StringBuilder();
+        int m = timer / 60 / 60;
+        int s = timer / 60 % 60;
+        int ms = timer % 60;
+        if(m > 0){
+            str.append(m).append(": ");
+            if(s < 10){
+                str.append("0");
+            }
+
+            str.append(s);
+            if(units) str.append("min");
+        }else{
+            str.append(s).append(".").append(ms);
+            if(units) str.append('s');
+        }
+        return str.toString();
+    }
+
+    public static String fixedTime(int timer){
+        return fixedTime(timer, true);
+    }
+
+    public static StringBuilder getPrefix(Color color, String type){
+        return getPrefix("#" + color, type);
+    }
+
+    public static StringBuilder getPrefix(String color, String type){
+        StringBuilder prefix = new StringBuilder();
+        if(ui.chatfrag.mode == ChatFragment.ChatMode.team) prefix.append("/t ");
+        prefix.append(ARCVars.arcVersionPrefix);
+        prefix.append("[").append(color).append("]");
+        prefix.append("<").append(type).append(">");
+        prefix.append("[white]");
+        return prefix;
+    }
+
+    public static void worldProcessor(){
+        Log.info("当前地图:@", state.map.name());
+        int[] data = new int[3];
+        Groups.build.each(b -> {
+            if(b instanceof LogicBlock.LogicBuild lb && lb.block.privileged){
+                data[0] += 1;
+                data[1] += lb.code.split("\n").length + 1;
+                data[2] += lb.code.length();
+            }
+        });
+        Log.info("地图共有@个世处，总共@行指令，@个字符", data[0], data[1], data[2]);
+        ui.announce(Strings.format("地图共有@个世处，总共@行指令，@个字符", data[0], data[1], data[2]), 10);
+    }
+
+    public static void uploadToWeb(Fi f, Cons<String> result){
+        uploadToWebID(f, l -> result.get("http://124.220.46.174/api/get?id=" + l));
+    }
+
+    public static void uploadToWebID(Fi f, Cons<String> result){
+        arcui.arcInfo("上传中，请等待...");
+        Http.HttpRequest post = Http.post("http://124.220.46.174/api/upload");
+        post.contentStream = f.read();
+        post.header("filename", f.name());
+        post.header("size", String.valueOf(f.length()));
+        post.header("token", "3ab6950d5970c57f938673911f42fd32");
+        post.timeout = 10000;
+        post.error(e -> Core.app.post(() -> arcui.arcInfo("发生了一个错误:" + e.toString())));
+        post.submit(r -> result.get(r.getResultAsString()));
+    }
+}
diff --git a/core/src/mindustry/arcModule/ai/ATRIAI.java b/core/src/mindustry/arcModule/ai/ATRIAI.java
new file mode 100644
index 0000000000000000000000000000000000000000..e7d2480466d6334049e38a7fd31a941b1d7dda43
--- /dev/null
+++ b/core/src/mindustry/arcModule/ai/ATRIAI.java
@@ -0,0 +1,208 @@
+package mindustry.arcModule.ai;
+
+import arc.struct.*;
+import arc.util.*;
+import mindustry.*;
+import mindustry.ai.types.*;
+import mindustry.entities.*;
+import mindustry.entities.units.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.input.*;
+import mindustry.type.*;
+import mindustry.world.*;
+import mindustry.world.blocks.*;
+import mindustry.world.blocks.environment.*;
+
+import static mindustry.Vars.*;
+
+public class ATRIAI extends AIController{
+    //builderAI
+
+    public static float buildRadius = 1500, retreatDst = 110f, retreatDelay = Time.toSeconds * 2f;
+    public static float rebuildTime = 120f;
+
+    public @Nullable Unit following;
+    public @Nullable Teamc enemy;
+    public @Nullable Teams.BlockPlan lastPlan;
+
+    public float fleeRange = 370f;
+
+    boolean found = false;
+    float retreatTimer;
+
+    //minerAI
+    public static final Seq<Block> oreAllList = content.blocks().select(b -> b instanceof Floor f && !f.wallOre && f.itemDrop != null);
+    public static final Seq<Block> oreAllWallList = content.blocks().select(b -> ((b instanceof Floor f && f.wallOre) || b instanceof StaticWall) && b.itemDrop != null);
+    public static Seq<Block> oreList = content.blocks().select(b -> b instanceof Floor f && !f.wallOre && f.itemDrop != null);
+    public static Seq<Block> oreWallList = content.blocks().select(b -> ((b instanceof Floor f && f.wallOre) || b instanceof StaticWall) && b.itemDrop != null);
+
+    public Seq<Item> canMineList;
+    public boolean mining = true;
+    public Item targetItem;
+    public Tile ore;
+
+
+    public ATRIAI(float fleeRange){
+        this.fleeRange = fleeRange;
+    }
+
+    public ATRIAI(){
+    }
+
+    @Override
+    public void init(){
+        if(!unit.canMine()) return;
+
+        if(unit.type.mineFloor){
+            canMineList = oreList.map(b -> b.itemDrop).select(i -> unit.canMine(i));
+        }else if(unit.type.mineWalls){
+            canMineList = oreWallList.map(b -> b.itemDrop).select(i -> unit.canMine(i));
+        }
+    }
+
+    @Override
+    public void updateMovement(){
+        builderMode();
+    }
+
+    private void builderMode(){
+
+        if(target != null && shouldShoot()){
+            unit.lookAt(target);
+        }
+
+        unit.updateBuilding = true;
+
+        if(following != null){
+            retreatTimer = 0f;
+            //try to follow and mimic someone
+
+            //validate follower
+            if(!following.isValid() || !following.activelyBuilding()){
+                following = null;
+                unit.plans.clear();
+                return;
+            }
+
+            //set to follower's first build plan, whatever that is
+            unit.plans.clear();
+            unit.plans.addFirst(following.buildPlan());
+            lastPlan = null;
+        }else if(unit.buildPlan() == null){
+            //not following anyone or building
+            if(timer.get(timerTarget4, 40)){
+                enemy = target(unit.x, unit.y, fleeRange, true, true);
+            }
+
+            //fly away from enemy when not doing anything, but only after a delay
+            if((retreatTimer += Time.delta) >= retreatDelay){
+                if(enemy != null){
+                    unit.clearBuilding();
+                    var core = unit.closestCore();
+                    if(core != null && !unit.within(core, retreatDst)){
+                        moveTo(core, retreatDst);
+                    }
+                }
+            }
+        }
+
+        if(unit.buildPlan() != null){
+            if(unit.controller() == Vars.player && control.input instanceof DesktopInput di) di.isBuilding = true;
+            //approach plan if building
+            BuildPlan req = unit.buildPlan();
+
+            //clear break plan if another player is breaking something
+            if(!req.breaking && timer.get(timerTarget2, 40f)){
+                for(Player player : Groups.player){
+                    if(player.isBuilder() && player.unit().activelyBuilding() && player.unit().buildPlan().samePos(req) && player.unit().buildPlan().breaking){
+                        unit.plans.removeFirst();
+                        //remove from list of plans
+                        unit.team.data().plans.remove(p -> p.x == req.x && p.y == req.y);
+                        return;
+                    }
+                }
+            }
+
+            boolean valid =
+            !(lastPlan != null && lastPlan.removed) &&
+            ((req.tile() != null && req.tile().build instanceof ConstructBlock.ConstructBuild cons && cons.current == req.block) ||
+            (req.breaking ?
+            Build.validBreak(unit.team(), req.x, req.y) :
+            Build.validPlace(req.block, unit.team(), req.x, req.y, req.rotation)));
+
+            if(valid){
+                //move toward the plan
+                moveTo(req.tile(), unit.type.buildRange - 20f);
+            }else{
+                //discard invalid plan
+                unit.plans.removeFirst();
+                lastPlan = null;
+            }
+        }else{
+            //follow someone and help them build
+            if(timer.get(timerTarget2, 60f)){
+                found = false;
+
+                Units.nearby(unit.team, unit.x, unit.y, buildRadius, u -> {
+                    if(found) return;
+
+                    if(u.canBuild() && u != unit && u.activelyBuilding()){
+                        BuildPlan plan = u.buildPlan();
+
+                        Building build = world.build(plan.x, plan.y);
+                        if(build instanceof ConstructBlock.ConstructBuild cons){
+                            float dist = Math.min(cons.dst(unit) - unit.type.buildRange, 0);
+
+                            //make sure you can reach the plan in time
+                            if(dist / unit.speed() < cons.buildCost * 0.9f){
+                                following = u;
+                                found = true;
+                            }
+                        }
+                    }
+                });
+            }
+
+            //find new plan
+            if(!unit.team.data().plans.isEmpty() && following == null && timer.get(timerTarget3, rebuildTime)){
+                Queue<Teams.BlockPlan> blocks = unit.team.data().plans;
+                Teams.BlockPlan block = blocks.first();
+
+                //check if it's already been placed
+                if(world.tile(block.x, block.y) != null && world.tile(block.x, block.y).block().id == block.block){
+                    blocks.removeFirst();
+                }else if(Build.validPlace(content.block(block.block), unit.team(), block.x, block.y, block.rotation) && (!nearEnemy(block.x, block.y))){ //it's valid
+                    lastPlan = block;
+                    //add build plan
+                    unit.addBuild(new BuildPlan(block.x, block.y, block.rotation, content.block(block.block), block.config));
+                    //shift build plan to tail so next unit builds something else
+                    blocks.addLast(blocks.removeFirst());
+                }else{
+                    //shift head of queue to tail, try something else next time
+                    blocks.addLast(blocks.removeFirst());
+                }
+            }
+        }
+    }
+
+
+    protected boolean nearEnemy(int x, int y){
+        return Units.nearEnemy(unit.team, x * tilesize - fleeRange / 2f, y * tilesize - fleeRange / 2f, fleeRange, fleeRange);
+    }
+
+    @Override
+    public AIController fallback(){
+        return unit.type.flying ? new FlyingAI() : new GroundAI();
+    }
+
+    @Override
+    public boolean useFallback(){
+        return state.rules.waves && unit.team == state.rules.waveTeam && !unit.team.rules().rtsAi;
+    }
+
+    @Override
+    public boolean shouldShoot(){
+        return !unit.isBuilding() && unit.type.canAttack;
+    }
+}
diff --git a/core/src/mindustry/arcModule/ai/ArcBuilderAI.java b/core/src/mindustry/arcModule/ai/ArcBuilderAI.java
new file mode 100644
index 0000000000000000000000000000000000000000..b9ec473518ebc4ba21fc15d9568f716fc5e5025a
--- /dev/null
+++ b/core/src/mindustry/arcModule/ai/ArcBuilderAI.java
@@ -0,0 +1,180 @@
+package mindustry.arcModule.ai;
+
+import arc.struct.*;
+import arc.util.*;
+import mindustry.*;
+import mindustry.ai.types.*;
+import mindustry.entities.*;
+import mindustry.entities.units.*;
+import mindustry.game.Teams.*;
+import mindustry.gen.*;
+import mindustry.input.*;
+import mindustry.world.*;
+import mindustry.world.blocks.ConstructBlock.*;
+
+import static mindustry.Vars.*;
+
+public class ArcBuilderAI extends AIController{
+    public static float buildRadius = 1500, retreatDst = 110f, retreatDelay = Time.toSeconds * 2f;
+    public static float rebuildTime = 120f;
+
+    public @Nullable Unit following;
+    public @Nullable Teamc enemy;
+    public @Nullable BlockPlan lastPlan;
+
+    public float fleeRange = 370f;
+    public boolean alwaysFlee;
+
+    boolean found = false;
+    float retreatTimer;
+
+    public ArcBuilderAI(boolean alwaysFlee, float fleeRange){
+        this.alwaysFlee = alwaysFlee;
+        this.fleeRange = fleeRange;
+    }
+
+    public ArcBuilderAI(){
+    }
+
+    @Override
+    public void updateMovement(){
+
+        if(target != null && shouldShoot()){
+            unit.lookAt(target);
+        }
+
+        unit.updateBuilding = true;
+
+        if(following != null){
+            retreatTimer = 0f;
+            //try to follow and mimic someone
+
+            //validate follower
+            if(!following.isValid() || !following.activelyBuilding()){
+                following = null;
+                unit.plans.clear();
+                return;
+            }
+
+            //set to follower's first build plan, whatever that is
+            unit.plans.clear();
+            unit.plans.addFirst(following.buildPlan());
+            lastPlan = null;
+        }else if(unit.buildPlan() == null || alwaysFlee){
+            //not following anyone or building
+            if(timer.get(timerTarget4, 40)){
+                enemy = target(unit.x, unit.y, fleeRange, true, true);
+            }
+
+            //fly away from enemy when not doing anything, but only after a delay
+            if((retreatTimer += Time.delta) >= retreatDelay || alwaysFlee){
+                if(enemy != null){
+                    unit.clearBuilding();
+                    var core = unit.closestCore();
+                    if(core != null && !unit.within(core, retreatDst)){
+                        moveTo(core, retreatDst);
+                    }
+                }
+            }
+        }
+
+        if(unit.buildPlan() != null){
+            if(unit.controller() == Vars.player && control.input instanceof DesktopInput di) di.isBuilding = true;
+            if(!alwaysFlee) retreatTimer = 0f;
+            //approach plan if building
+            BuildPlan req = unit.buildPlan();
+
+            //clear break plan if another player is breaking something
+            if(!req.breaking && timer.get(timerTarget2, 40f)){
+                for(Player player : Groups.player){
+                    if(player.isBuilder() && player.unit().activelyBuilding() && player.unit().buildPlan().samePos(req) && player.unit().buildPlan().breaking){
+                        unit.plans.removeFirst();
+                        //remove from list of plans
+                        unit.team.data().plans.remove(p -> p.x == req.x && p.y == req.y);
+                        return;
+                    }
+                }
+            }
+
+            boolean valid =
+            !(lastPlan != null && lastPlan.removed) &&
+            ((req.tile() != null && req.tile().build instanceof ConstructBuild cons && cons.current == req.block) ||
+            (req.breaking ?
+            Build.validBreak(unit.team(), req.x, req.y) :
+            Build.validPlace(req.block, unit.team(), req.x, req.y, req.rotation)));
+
+            if(valid){
+                //move toward the plan
+                moveTo(req.tile(), unit.type.buildRange - 20f);
+            }else{
+                //discard invalid plan
+                unit.plans.removeFirst();
+                lastPlan = null;
+            }
+        }else{
+
+            //follow someone and help them build
+            if(timer.get(timerTarget2, 60f)){
+                found = false;
+
+                Units.nearby(unit.team, unit.x, unit.y, buildRadius, u -> {
+                    if(found) return;
+
+                    if(u.canBuild() && u != unit && u.activelyBuilding()){
+                        BuildPlan plan = u.buildPlan();
+
+                        Building build = world.build(plan.x, plan.y);
+                        if(build instanceof ConstructBuild cons){
+                            float dist = Math.min(cons.dst(unit) - unit.type.buildRange, 0);
+
+                            //make sure you can reach the plan in time
+                            if(dist / unit.speed() < cons.buildCost * 0.9f){
+                                following = u;
+                                found = true;
+                            }
+                        }
+                    }
+                });
+            }
+
+            //find new plan
+            if(!unit.team.data().plans.isEmpty() && following == null && timer.get(timerTarget3, rebuildTime)){
+                Queue<BlockPlan> blocks = unit.team.data().plans;
+                BlockPlan block = blocks.first();
+
+                //check if it's already been placed
+                if(world.tile(block.x, block.y) != null && world.tile(block.x, block.y).block().id == block.block){
+                    blocks.removeFirst();
+                }else if(Build.validPlace(content.block(block.block), unit.team(), block.x, block.y, block.rotation) && (!alwaysFlee || !nearEnemy(block.x, block.y))){ //it's valid
+                    lastPlan = block;
+                    //add build plan
+                    unit.addBuild(new BuildPlan(block.x, block.y, block.rotation, content.block(block.block), block.config));
+                    //shift build plan to tail so next unit builds something else
+                    blocks.addLast(blocks.removeFirst());
+                }else{
+                    //shift head of queue to tail, try something else next time
+                    blocks.addLast(blocks.removeFirst());
+                }
+            }
+        }
+    }
+
+    protected boolean nearEnemy(int x, int y){
+        return Units.nearEnemy(unit.team, x * tilesize - fleeRange / 2f, y * tilesize - fleeRange / 2f, fleeRange, fleeRange);
+    }
+
+    @Override
+    public AIController fallback(){
+        return unit.type.flying ? new FlyingAI() : new GroundAI();
+    }
+
+    @Override
+    public boolean useFallback(){
+        return state.rules.waves && unit.team == state.rules.waveTeam && !unit.team.rules().rtsAi;
+    }
+
+    @Override
+    public boolean shouldShoot(){
+        return !unit.isBuilding() && unit.type.canAttack;
+    }
+}
diff --git a/core/src/mindustry/arcModule/ai/ArcMinerAI.java b/core/src/mindustry/arcModule/ai/ArcMinerAI.java
new file mode 100644
index 0000000000000000000000000000000000000000..44b2ab3ea8bc4f58cfc48833780f367213b03a35
--- /dev/null
+++ b/core/src/mindustry/arcModule/ai/ArcMinerAI.java
@@ -0,0 +1,130 @@
+package mindustry.arcModule.ai;
+
+import arc.struct.*;
+import arc.util.*;
+import mindustry.entities.units.*;
+import mindustry.gen.*;
+import mindustry.input.*;
+import mindustry.type.*;
+import mindustry.world.*;
+import mindustry.world.blocks.environment.*;
+import mindustry.world.blocks.storage.*;
+
+import static mindustry.Vars.*;
+
+public class ArcMinerAI extends AIController{
+    public static final Seq<Block> oreAllList = content.blocks().select(b -> b instanceof Floor f && !f.wallOre && f.itemDrop != null);
+    public static final Seq<Block> oreAllWallList = content.blocks().select(b -> ((b instanceof Floor f && f.wallOre) || b instanceof StaticWall) && b.itemDrop != null);
+    public static Seq<Block> oreList = content.blocks().select(b -> b instanceof Floor f && !f.wallOre && f.itemDrop != null);
+    public static Seq<Block> oreWallList = content.blocks().select(b -> ((b instanceof Floor f && f.wallOre) || b instanceof StaticWall) && b.itemDrop != null);
+
+    public Seq<Item> canMineList;
+    public boolean mining = true;
+    public Item targetItem;
+    public Tile ore;
+
+    @Override
+    public void init(){
+        if(!unit.canMine()) return;
+
+        if(unit.type.mineFloor){
+            canMineList = oreList.map(b -> b.itemDrop).select(i -> unit.canMine(i));
+        }else if(unit.type.mineWalls){
+            canMineList = oreWallList.map(b -> b.itemDrop).select(i -> unit.canMine(i));
+        }
+    }
+
+    private Item updateTargetItem(boolean canMineNonBuildable){
+        //reverse是因为min取最后一个最小的
+        if(unit.type.mineFloor){
+            canMineList = oreList.map(b -> b.itemDrop).select(i -> unit.canMine(i));
+        }else if(unit.type.mineWalls){
+            canMineList = oreWallList.map(b -> b.itemDrop).select(i -> unit.canMine(i));
+        }
+        return canMineList.select(i -> (unit.type.mineFloor ? indexer.hasOre(i) : indexer.hasOreWall(i))
+        && (canMineNonBuildable || i.buildable)
+        && unit.core().acceptItem(null, i)
+        ).reverse().min(i -> unit.core().items.get(i));
+    }
+
+    private Tile findClosetOre(Building build){
+        if(unit.type.mineFloor){
+            return indexer.findClosestOre(build.x, build.y, targetItem);
+        }
+        return indexer.findClosestWallOre(build.x, build.y, targetItem);
+    }
+
+    @Override
+    public void updateMovement(){
+        if(!unit.canMine() || canMineList.isEmpty() || unit.core() == null) return;
+
+        CoreBlock.CoreBuild core = unit.closestCore();
+        //变量命名不知道叫啥了
+        //最近的可以塞入非建筑物品的核心
+        CoreBlock.CoreBuild core2 = unit.team.data().cores.select(c -> !((CoreBlock)c.block).incinerateNonBuildable).min(c -> unit.dst(c));
+
+        CoreBlock.CoreBuild targetCore = targetItem == null || targetItem.buildable || core2 == null ? core : core2;
+
+        if(unit.type.canBoost){
+            player.boosting = true;
+        }
+        if(mining){
+
+            if(targetItem != null && (!core.acceptItem(null, targetItem) || (core2 == null && !targetItem.buildable))){
+                unit.mineTile = null;
+                targetItem = null;
+            }
+
+            if(targetItem == null || timer.get(timerTarget2, 300f)){
+                targetItem = updateTargetItem(core2 != null);
+                if(targetItem == null) return;
+            }
+
+            if(!unit.acceptsItem(targetItem) || unit.stack.amount >= unit.type.itemCapacity){
+                mining = false;
+                return;
+            }
+
+            if(ore == null || !unit.validMine(ore, false) || ore.drop() != targetItem || timer.get(timerTarget3, 120f)){
+                ore = findClosetOre(targetCore);
+                if(ore == null) return;
+            }
+
+
+            Tmp.v1.setLength(unit.type.mineRange * 0.9f).limit(ore.dst(targetCore) - 0.5f).setAngle(ore.angleTo(targetCore)).add(ore);
+            moveTo(Tmp.v1, 0.1f);
+            if(unit.validMine(ore)){
+                unit.mineTile = ore;
+            }
+
+        }else{
+            unit.mineTile = null;
+
+            if(unit.stack.amount == 0){
+                mining = true;
+                return;
+            }
+            if(!core.acceptItem(null, unit.stack.item)){
+                unit.clearItem();
+            }
+
+            moveTo(targetCore, core.hitSize());
+            if(unit.within(targetCore, itemTransferRange) && targetCore.acceptItem(null, targetItem)){
+                if(control.input instanceof DesktopInput di){
+                    di.autoAim = true;
+                }
+                unit.aimX = core.x;
+                unit.aimY = core.y;
+                Call.transferInventory(player, core);
+                targetItem = updateTargetItem(core2 != null);
+                if(control.input instanceof DesktopInput di){
+                    Time.run(30f, () -> di.autoAim = false);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void updateVisuals(){
+    }
+}
diff --git a/core/src/mindustry/arcModule/ai/ArcRepairAI.java b/core/src/mindustry/arcModule/ai/ArcRepairAI.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e578160907e498b6ba31d63fb5c7e193aba57ea
--- /dev/null
+++ b/core/src/mindustry/arcModule/ai/ArcRepairAI.java
@@ -0,0 +1,73 @@
+package mindustry.arcModule.ai;
+
+import arc.util.*;
+import mindustry.entities.*;
+import mindustry.entities.units.*;
+import mindustry.gen.*;
+import mindustry.world.blocks.ConstructBlock.*;
+
+public class ArcRepairAI extends AIController{
+    public static float retreatDst = 160f, fleeRange = 310f, retreatDelay = Time.toSeconds * 3f;
+
+    @Nullable
+    Teamc avoid;
+    float retreatTimer;
+    Building damagedTarget;
+
+    @Override
+    public void updateMovement(){
+        if(target instanceof Building){
+            boolean shoot = false;
+
+            if(target.within(unit, unit.type.range)){
+                unit.aim(target);
+                shoot = true;
+            }
+
+            unit.controlWeapons(shoot);
+        }else if(target == null){
+            unit.controlWeapons(false);
+        }
+
+        if(target != null){
+            if(!target.within(unit, unit.type.range * 0.65f) && target instanceof Building b && b.team == unit.team){
+                moveTo(target, unit.type.range * 0.65f);
+            }
+
+            unit.lookAt(target);
+        }
+
+        //not repairing
+        if(!(target instanceof Building)){
+            if(timer.get(timerTarget4, 40)){
+                avoid = target(unit.x, unit.y, fleeRange, true, true);
+            }
+
+            if((retreatTimer += Time.delta) >= retreatDelay){
+                //fly away from enemy when not doing anything
+                if(avoid != null){
+                    var core = unit.closestCore();
+                    if(core != null && !unit.within(core, retreatDst)){
+                        moveTo(core, retreatDst);
+                    }
+                }
+            }
+        }else{
+            retreatTimer = 0f;
+        }
+    }
+
+    @Override
+    public void updateTargeting(){
+        if(timer.get(timerTarget, 15)){
+            damagedTarget = Units.findDamagedTile(unit.team, unit.x, unit.y);
+            if(damagedTarget instanceof ConstructBuild) damagedTarget = null;
+        }
+
+        if(damagedTarget == null){
+            super.updateTargeting();
+        }else{
+            this.target = damagedTarget;
+        }
+    }
+}
diff --git a/core/src/mindustry/arcModule/draw/ARCBuilds.java b/core/src/mindustry/arcModule/draw/ARCBuilds.java
new file mode 100644
index 0000000000000000000000000000000000000000..8834de1bc8824519fa1101e183398d23e7938972
--- /dev/null
+++ b/core/src/mindustry/arcModule/draw/ARCBuilds.java
@@ -0,0 +1,128 @@
+package mindustry.arcModule.draw;
+
+import arc.*;
+import arc.graphics.g2d.*;
+import arc.math.*;
+import arc.math.geom.*;
+import arc.util.*;
+import mindustry.arcModule.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.type.*;
+import mindustry.world.blocks.defense.turrets.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.draw.ARCUnits.*;
+
+public class ARCBuilds{
+    static boolean targetAir = false, targetGround = false, canShoot = false;
+    static boolean turretForceShowRange = false;
+
+    static int turretShowRange = 0, turretAlertRange;
+
+    static boolean canHitPlayer = false, canHitCommand = false, canHitPlans = false, canHitMouse = false;
+
+    static boolean showTurretAmmo = false, showTurretAmmoAmount = false;
+
+    static boolean blockWeaponTargetLine = false, blockWeaponTargetLineWhenIdle = false;
+
+    static{
+        // 减少性能开销
+        Events.run(EventType.Trigger.update, () -> {
+            turretForceShowRange = Core.settings.getBool("turretForceShowRange");
+            turretShowRange = Core.settings.getInt("turretShowRange");
+
+            turretAlertRange = Core.settings.getInt("turretAlertRange") * tilesize;
+
+            showTurretAmmo = Core.settings.getBool("showTurretAmmo");
+            showTurretAmmoAmount = Core.settings.getBool("showTurretAmmoAmount");
+
+            blockWeaponTargetLine = Core.settings.getBool("blockWeaponTargetLine");
+            blockWeaponTargetLineWhenIdle = Core.settings.getBool("blockWeaponTargetLineWhenIdle");
+        });
+    }
+
+    private static void drawRange(BaseTurret.BaseTurretBuild build){
+        Draw.z(Layer.turret - 0.8f);
+        //Draw.color(build.team.color, 0.05f);
+        //Fill.circle(build.x, build.y, build.range());
+        Draw.color(build.team.color, 0.6f);
+        Lines.circle(build.x, build.y, build.range());
+        Draw.reset();
+    }
+
+    public static void arcTurret(BaseTurret.BaseTurretBuild build){
+        if(build == null || !ARCVars.arcInfoControl(build.team)) return;
+        Draw.z(Layer.turret);
+
+        Vec2 targetPos = Vec2.ZERO;
+        if(build.block instanceof Turret t){
+            targetAir = t.targetAir;
+            targetGround = t.targetGround;
+            targetPos = ((Turret.TurretBuild)build).targetPos;
+            canShoot = ((Turret.TurretBuild)build).hasAmmo();
+        }else if(build.block instanceof TractorBeamTurret t){
+            targetAir = t.targetAir;
+            targetGround = t.targetGround;
+            Unit target = ((TractorBeamTurret.TractorBeamBuild)build).target;
+            if(target != null){
+                targetPos = Tmp.v1.set(target.x, target.y);
+            }
+            canShoot = build.potentialEfficiency > 0;
+        }
+        if(build instanceof PowerTurret.PowerTurretBuild){
+            canShoot = build.efficiency > 0;
+        }
+
+        if(turretForceShowRange || canShoot){
+            if((turretShowRange == 3 || (turretShowRange == 2 && targetAir) || (turretShowRange == 1 && targetGround)))
+                drawRange(build);
+            else if(turretAlertRange > 0 && build.team != player.team()){
+                canHitPlayer = !player.unit().isNull() && player.unit().hittable() && (player.unit().isFlying() ? targetAir : targetGround)
+                && build.within(player.unit().x, player.unit().y, build.range() + turretAlertRange);
+                canHitMouse = build.within(Core.input.mouseWorldX(), Core.input.mouseWorldY(), build.range() + turretAlertRange);
+                canHitCommand = control.input.commandMode && ((selectedUnitsFlyer && targetAir) || (selectedUnitsLand && targetGround));
+                canHitPlans = (control.input.block != null || control.input.selectPlans.size > 0) && targetGround;
+                if(canHitPlayer || (canHitMouse && (canHitCommand || canHitPlans))) drawRange(build);
+            }
+
+            if(showTurretAmmo && build instanceof ItemTurret.ItemTurretBuild it && it.ammo.any()){
+                //lc参考miner代码
+                ItemTurret.ItemEntry entry = (ItemTurret.ItemEntry)it.ammo.peek();
+                Item lastAmmo = entry.item;
+
+                Draw.z(Layer.turret + 0.1f);
+
+                float size = Math.max(4f, build.block.size * tilesize / 2.5f);
+                float ammoX = build.x - (build.block.size * tilesize / 2.0F) + (size / 2);
+                float ammoY = build.y - (build.block.size * tilesize / 2.0F) + (size / 2);
+
+                Draw.rect(lastAmmo.uiIcon, ammoX, ammoY, size, size);
+
+                float leftAmmo = Mathf.lerp(0, 1, Math.min(1f, (float)entry.amount / ((ItemTurret)it.block).maxAmmo));
+                if(leftAmmo < 0.75f && showTurretAmmoAmount){
+                    Draw.alpha(0.5f);
+                    Draw.color(lastAmmo.color);
+                    Lines.stroke(Lines.getStroke() * build.block.size * 0.5f);
+                    Lines.arc(ammoX, ammoY, size * 0.5f, leftAmmo);
+                }
+
+                Draw.reset();
+            }
+            if(targetPos.x != 0 && targetPos.y != 0 && blockWeaponTargetLine && Mathf.len(targetPos.x - build.x, targetPos.y - build.y) <= 1500f){
+                if(!(build instanceof Turret.TurretBuild) || ((Turret.TurretBuild)build).isShooting() || ((Turret.TurretBuild)build).isControlled()){
+                    Draw.color(1f, 0.2f, 0.2f, 0.8f);
+                    Lines.stroke(1.5f);
+                    Lines.line(build.x, build.y, targetPos.x, targetPos.y);
+                    Lines.dashCircle(targetPos.x, targetPos.y, 8);
+                }else if(blockWeaponTargetLineWhenIdle){
+                    Draw.color(1f, 1f, 1f, 0.3f);
+                    Lines.stroke(1.5f);
+                    Lines.line(build.x, build.y, targetPos.x, targetPos.y);
+                    Lines.dashCircle(targetPos.x, targetPos.y, 8);
+                }
+            }
+        }
+    }
+}
diff --git a/core/src/mindustry/arcModule/draw/ARCUnits.java b/core/src/mindustry/arcModule/draw/ARCUnits.java
new file mode 100644
index 0000000000000000000000000000000000000000..fbf0a71993389878c0f783346205433e172e78a0
--- /dev/null
+++ b/core/src/mindustry/arcModule/draw/ARCUnits.java
@@ -0,0 +1,333 @@
+package mindustry.arcModule.draw;
+
+import arc.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.math.*;
+import arc.math.geom.*;
+import arc.util.*;
+import mindustry.ai.types.*;
+import mindustry.arcModule.*;
+import mindustry.entities.units.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.world.blocks.payloads.*;
+import mindustryX.features.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.maxBuildPlans;
+import static mindustry.arcModule.DrawUtilities.drawNSideRegion;
+
+public class ARCUnits{
+    private static boolean alwaysShowPlayerUnit, alwaysShowUnitRTSAi, unitHealthBar, unitLogicMoveLine, unitLogicTimerBars, unithitbox, unitBuildPlan;
+    private static float defaultUnitTrans, unitDrawMinHealth, unitBarDrawMinHealth;
+    private static float unitWeaponRange, unitWeaponRangeAlpha;
+    public static boolean selectedUnitsFlyer, selectedUnitsLand;
+
+    private static float curStroke;
+    private static int unitTargetType, superUnitEffect;
+    private static boolean arcBuildInfo;
+
+    static{
+        // 减少性能开销
+        Events.run(EventType.Trigger.update, () -> {
+            alwaysShowPlayerUnit = Core.settings.getBool("alwaysShowPlayerUnit");
+            alwaysShowUnitRTSAi = Core.settings.getBool("alwaysShowUnitRTSAi");
+            unitHealthBar = Core.settings.getBool("unitHealthBar");
+            unitLogicMoveLine = Core.settings.getBool("unitLogicMoveLine");
+            unitLogicTimerBars = Core.settings.getBool("unitLogicTimerBars");
+            unithitbox = Core.settings.getBool("unithitbox");
+            unitBuildPlan = Core.settings.getBool("unitbuildplan");
+
+            defaultUnitTrans = RenderExt.unitHide ? 0 : Core.settings.getInt("unitTransparency") / 100f;
+            unitDrawMinHealth = Core.settings.getInt("unitDrawMinHealth");
+            unitBarDrawMinHealth = Core.settings.getInt("unitBarDrawMinHealth");
+
+            unitWeaponRange = Core.settings.getInt("unitWeaponRange") * tilesize;
+            unitWeaponRangeAlpha = Core.settings.getInt("unitWeaponRangeAlpha") / 100f;
+
+            selectedUnitsFlyer = control.input.selectedUnits.contains(Flyingc::isFlying);
+            selectedUnitsLand = control.input.selectedUnits.contains(unit -> !unit.isFlying());
+
+            curStroke = (float)Core.settings.getInt("playerEffectCurStroke") / 10f;
+            unitTargetType = Core.settings.getInt("unitTargetType");
+            superUnitEffect = Core.settings.getInt("superUnitEffect");
+            arcBuildInfo = Core.settings.getBool("arcBuildInfo");
+        });
+    }
+
+    public static float drawARCUnits(Unit unit){
+        if(unit.controller() instanceof Player){
+            drawPlayerEffect(unit);
+            if(alwaysShowPlayerUnit){
+                drawUnitBar(unit);
+                return 100f;
+            }
+        }
+        if((unit.maxHealth + unit.shield) < unitDrawMinHealth) return 0f;
+        if((unit.maxHealth + unit.shield) >= unitBarDrawMinHealth) drawUnitBar(unit);
+        return defaultUnitTrans;
+    }
+
+    private static void drawUnitBar(Unit unit){
+        if(ARCVars.arcInfoControl(unit.team())){
+            drawWeaponRange(unit);
+            drawRTSAI(unit);
+            drawHealthBar(unit);
+            drawLogic(unit);
+            drawBuildPlan(unit);
+        }
+        drawHitBox(unit);
+    }
+
+    private static void drawPlayerEffect(Unit unit){
+        Color effectColor = unit.controller() == player ? ARCVars.getPlayerEffectColor() : unit.team.color;
+
+        boolean drawCircle = (unit.controller() == player && superUnitEffect != 0) || (unit.controller() instanceof Player && superUnitEffect == 2);
+        if(drawCircle){
+            // 射程圈
+            Lines.stroke(Lines.getStroke() * curStroke);
+
+            Draw.z(Layer.effect - 2f);
+            Draw.color(effectColor);
+
+            Tmp.v1.trns(unit.rotation - 90, unit.x, unit.y).add(unit.x, unit.y);
+
+            if(curStroke > 0){
+                for(int i = 0; i < 5; i++){
+                    float rot = unit.rotation + i * 360f / 5 + Time.time * 0.5f;
+                    Lines.arc(unit.x, unit.y, unit.type.maxRange, 0.14f, rot, (int)(50 + unit.type.maxRange / 10));
+                }
+            }
+        }
+        // 武器圈
+        if(unitTargetType > 0){
+            Draw.z(Layer.effect);
+            Draw.color(effectColor, 0.8f);
+            Lines.stroke(1f);
+            Lines.line(unit.x, unit.y, unit.aimX, unit.aimY);
+            switch(unitTargetType){
+                case 1:
+                    Lines.dashCircle(unit.aimX, unit.aimY, 8);
+                    break;
+                case 2:
+                    Drawf.target(unit.aimX, unit.aimY, 6f, 0.7f, effectColor);
+                    break;
+                case 3:
+                    Drawf.target2(unit.aimX, unit.aimY, 6f, 0.7f, effectColor);
+                    break;
+                case 4:
+                    Drawf.targetc(unit.aimX, unit.aimY, 6f, 0.7f, effectColor);
+                    break;
+                case 5:
+                    Drawf.targetd(unit.aimX, unit.aimY, 6f, 0.7f, effectColor);
+                    break;
+            }
+        }
+
+        //玩家专属特效
+        if(unit.controller() == player){
+            detailBuildMode();
+        }
+    }
+
+    private static void drawWeaponRange(Unit unit){
+        if(unitWeaponRange == 0 || unitWeaponRangeAlpha == 0) return;
+        if(unitWeaponRange == 30){
+            drawWeaponRange(unit, unitWeaponRangeAlpha);
+        }else if(unit.team != player.team()){
+            boolean canHitPlayer = !player.unit().isNull() && player.unit().hittable() && (player.unit().isFlying() ? unit.type.targetAir : unit.type.targetGround)
+            && unit.within(player.unit().x, player.unit().y, unit.type.maxRange + unitWeaponRange);
+            boolean canHitCommand = control.input.commandMode && ((selectedUnitsFlyer && unit.type.targetAir) || (selectedUnitsLand && unit.type.targetGround));
+            boolean canHitPlans = (control.input.block != null || control.input.selectPlans.size > 0) && unit.type.targetGround;
+            boolean canHitMouse = unit.within(Core.input.mouseWorldX(), Core.input.mouseWorldY(), unit.type.maxRange + unitWeaponRange);
+            if(canHitPlayer || (canHitMouse && (canHitCommand || canHitPlans)))
+                drawWeaponRange(unit, unitWeaponRangeAlpha);
+        }
+    }
+
+    private static void drawWeaponRange(Unit unit, float alpha){
+        Draw.color(unit.team.color);
+        Draw.alpha(alpha);
+        Lines.dashCircle(unit.x, unit.y, unit.type.maxRange);
+        Draw.reset();
+    }
+
+    private static void drawRTSAI(Unit unit){
+        if(!control.input.commandMode && alwaysShowUnitRTSAi && unit.isCommandable() && unit.command().command != null && unit.command().command.name.equals("move")){
+            Draw.z(Layer.effect);
+            CommandAI ai = unit.command();
+            //draw target line
+            if(ai.targetPos != null){
+                Position lineDest = ai.attackTarget != null ? ai.attackTarget : ai.targetPos;
+                Draw.color(unit.team.color);
+                Drawf.limitLineColor(unit, lineDest, unit.hitSize / 2f, 3.5f, unit.team.color);
+
+                if(ai.attackTarget == null){
+                    Draw.color(unit.team.color);
+                    Drawf.square(lineDest.getX(), lineDest.getY(), 3.5f, unit.team.color);
+                }
+            }
+
+            if(ai.attackTarget != null){
+                Draw.color(unit.team.color);
+                Drawf.target(ai.attackTarget.getX(), ai.attackTarget.getY(), 6f, unit.team.color);
+            }
+            Draw.color();
+        }
+        Draw.reset();
+    }
+
+    private static void drawHealthBar(Unit unit){
+        if(!unitHealthBar) return;
+        Draw.z(Layer.shields + 6f);
+        float y_corr = 0f;
+        if(unit.hitSize < 30f && unit.hitSize > 20f && unit.controller().isBeingControlled(player.unit())) y_corr = 2f;
+        if(unit.health < unit.maxHealth){
+            Draw.reset();
+            Lines.stroke(4f);
+            Draw.color(unit.team.color, 0.5f);
+            Lines.line(unit.x - unit.hitSize() * 0.6f, unit.y + (unit.hitSize() / 2f) + y_corr, unit.x + unit.hitSize() * 0.6f, unit.y + (unit.hitSize() / 2f) + y_corr);
+            Lines.stroke(2f);
+            Draw.color(Pal.health, 0.8f);
+            Lines.line(
+            unit.x - unit.hitSize() * 0.6f, unit.y + (unit.hitSize() / 2f) + y_corr,
+            unit.x + unit.hitSize() * (Math.min(Mathf.maxZero(unit.health), unit.maxHealth) * 1.2f / unit.maxHealth - 0.6f), unit.y + (unit.hitSize() / 2f) + y_corr);
+            Lines.stroke(2f);
+        }
+        if(unit.shield > 0 && unit.shield < 1e20){
+            for(int didgt = 1; didgt <= Mathf.digits((int)(unit.shield / unit.maxHealth)) + 1; didgt++){
+                Draw.color(Pal.shield, 0.8f);
+                float shieldAmountScale = unit.shield / (unit.maxHealth * Mathf.pow(10f, (float)didgt - 1f));
+                if(didgt > 1){
+                    Lines.line(unit.x - unit.hitSize() * 0.6f,
+                    unit.y + (unit.hitSize() / 2f) + (float)didgt * 2f + y_corr,
+                    unit.x + unit.hitSize() * ((Mathf.ceil((shieldAmountScale - Mathf.floor(shieldAmountScale)) * 10f) - 1f + 0.0001f) * 1.2f * (1f / 9f) - 0.6f),
+                    unit.y + (unit.hitSize() / 2f) + (float)didgt * 2f + y_corr);
+                    //(s-1)*(1/9)because line(0) will draw length of 1
+                }else{
+                    Lines.line(unit.x - unit.hitSize() * 0.6f,
+                    unit.y + (unit.hitSize() / 2f) + (float)didgt * 2f + y_corr,
+                    unit.x + unit.hitSize() * ((shieldAmountScale - Mathf.floor(shieldAmountScale) - 0.001f) * 1.2f - 0.6f),
+                    unit.y + (unit.hitSize() / 2f) + (float)didgt * 2f + y_corr);
+                }
+            }
+        }
+        Draw.reset();
+
+        float index = 0f;
+        float iconSize = 4f;
+        int iconColumns = Math.max((int)(unit.hitSize() / (iconSize + 1f)), 4);
+        float iconWidth = Math.min(unit.hitSize() / iconColumns, iconSize + 1f);
+        for(var entry : unit.statuses()){
+            Draw.rect(entry.effect.uiIcon,
+            unit.x - unit.hitSize() * 0.6f + iconWidth * (index % iconColumns),
+            unit.y + (unit.hitSize() / 2f) + 3f + iconSize * Mathf.floor(index / iconColumns),
+            iconSize, iconSize);
+            index++;
+        }
+
+        index = 0f;
+        if(unit instanceof Payloadc payload && payload.payloads().any()){
+            for(Payload p : payload.payloads()){
+                Draw.rect(p.icon(),
+                unit.x - unit.hitSize() * 0.6f + 0.5f * iconSize * index,
+                unit.y + (unit.hitSize() / 2f) - 4f,
+                4f, 4f);
+                index++;
+            }
+        }
+        Draw.reset();
+    }
+
+    private static void drawLogic(Unit unit){
+        if(unit.controller() instanceof LogicAI logicai){
+            if(unitLogicMoveLine && Mathf.len(logicai.moveX - unit.x, logicai.moveY - unit.y) <= 1200f){
+                Lines.stroke(1f);
+                Draw.color(0.2f, 0.2f, 1f, 0.9f);
+                Lines.dashLine(unit.x, unit.y, logicai.moveX, logicai.moveY, (int)(Mathf.len(logicai.moveX - unit.x, logicai.moveY - unit.y) / 8));
+                Lines.dashCircle(logicai.moveX, logicai.moveY, logicai.moveRad);
+                Draw.reset();
+            }
+            if(unitLogicTimerBars){
+                Lines.stroke(2f);
+                Draw.color(Pal.heal);
+                Lines.line(unit.x - (unit.hitSize() / 2f), unit.y - (unit.hitSize() / 2f), unit.x - (unit.hitSize() / 2f), unit.y + unit.hitSize() * (logicai.controlTimer / LogicAI.logicControlTimeout - 0.5f));
+                Draw.reset();
+            }
+        }
+    }
+
+    private static void drawBuildPlan(Unit unit){
+        if(unitBuildPlan && !unit.plans().isEmpty()){
+            int counter = 0;
+            if(unit != player.unit()){
+                for(BuildPlan b : unit.plans()){
+                    unit.drawPlan(b, 0.5f);
+                    counter += 1;
+                    if(counter >= maxBuildPlans) break;
+                }
+            }
+            counter = 0;
+            Draw.color(Pal.gray);
+            Lines.stroke(2f);
+            float x = unit.x, y = unit.y, s = unit.hitSize / 2f;
+            for(BuildPlan b : unit.plans()){
+                Tmp.v2.trns(Angles.angle(x, y, b.drawx(), b.drawy()), s);
+                Tmp.v3.trns(Angles.angle(x, y, b.drawx(), b.drawy()), b.block.size * 2f);
+                Lines.circle(b.drawx(), b.drawy(), b.block.size * 2f);
+                Lines.line(x + Tmp.v2.x, y + Tmp.v2.y, b.drawx() - Tmp.v3.x, b.drawy() - Tmp.v3.y);
+                x = b.drawx();
+                y = b.drawy();
+                s = b.block.size * 2f;
+                counter += 1;
+                if(counter >= maxBuildPlans) break;
+            }
+
+            counter = 0;
+            Draw.color(unit.team.color);
+            Lines.stroke(0.75f);
+            x = unit.x;
+            y = unit.y;
+            s = unit.hitSize / 2f;
+            for(BuildPlan b : unit.plans()){
+                Tmp.v2.trns(Angles.angle(x, y, b.drawx(), b.drawy()), s);
+                Tmp.v3.trns(Angles.angle(x, y, b.drawx(), b.drawy()), b.block.size * 2f);
+                Lines.circle(b.drawx(), b.drawy(), b.block.size * 2f);
+                Draw.color(unit.team.color);
+                Lines.line(x + Tmp.v2.x, y + Tmp.v2.y, b.drawx() - Tmp.v3.x, b.drawy() - Tmp.v3.y);
+                x = b.drawx();
+                y = b.drawy();
+                s = b.block.size * 2f;
+                counter += 1;
+                if(counter >= maxBuildPlans) break;
+            }
+            Draw.reset();
+        }
+    }
+
+    private static void drawHitBox(Unit unit){
+        if(unithitbox){
+            Draw.color(unit.team.color, 0.5f);
+            Lines.circle(unit.x, unit.y, unit.hitSize / 2f);
+            Draw.reset();
+        }
+    }
+
+    private static void detailBuildMode(){
+        if(!arcBuildInfo) return;
+        if(control.input.droppingItem){
+            Color color = player.within(Core.input.mouseWorld(control.input.getMouseX(), control.input.getMouseY()), itemTransferRange) ? Color.gold : Color.red;
+            drawNSideRegion(player.unit().x, player.unit().y, 3, player.unit().type.buildRange, player.unit().rotation, color, 0.25f, player.unit().stack.item.uiIcon, false);
+        }else if(control.input.isBuilding || control.input.selectedBlock() || !player.unit().plans().isEmpty()){
+            drawNSideRegion(player.unit().x, player.unit().y, 3, player.unit().type.buildRange, player.unit().rotation, Pal.heal, 0.25f, Icon.wrench.getRegion(), true);
+        }
+    }
+
+    public static void drawControlTurret(){
+        if(player.unit() instanceof BlockUnitc unitc){
+            unitc.tile().drawSelect();
+        }
+    }
+}
diff --git a/core/src/mindustry/arcModule/toolpack/arcChatPicture.java b/core/src/mindustry/arcModule/toolpack/arcChatPicture.java
new file mode 100644
index 0000000000000000000000000000000000000000..42c442b48f7d5f7f0fda60c081738a13ab58a28a
--- /dev/null
+++ b/core/src/mindustry/arcModule/toolpack/arcChatPicture.java
@@ -0,0 +1,205 @@
+package mindustry.arcModule.toolpack;
+
+import arc.*;
+import arc.files.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.scene.event.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.util.*;
+import mindustry.arcModule.*;
+import mindustry.arcModule.ui.dialogs.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.arcModule.RFuncs.getPrefix;
+
+public class arcChatPicture{
+
+    public static final String ShareType = "[yellow]<Picture>";
+    private static Pixmap oriImage;
+    static Table tTable = new Table(Tex.button);
+    static Fi figureFile;
+    static TextField figureLink;
+
+    static final int maxPicture = 10;
+    static int curPicture = 0;
+
+    public static boolean resolveMessage(String text, @Nullable Player playersender){
+        if(!Core.settings.getBool("arcShareMedia")) return false;
+        if(!text.contains(ShareType) || !text.contains("http")){
+            return false;
+        }
+
+        if(!checkPic()) return true;
+
+        int Indexer = text.indexOf(ShareType) + ShareType.length();
+        Indexer = text.indexOf("http", Indexer);
+        String url = text.substring(Indexer);
+
+        MessageDialog.addMsg(new MessageDialog.advanceMsg(MessageDialog.arcMsgType.arcChatPicture, text));
+
+        Http.get(url, res -> {
+            byte[] data = res.getResult();
+            new Thread(() -> {
+                try{
+                    Pixmap pix = new Pixmap(data);
+                    Timer.schedule(() -> new floatFigure(pix, playersender), 0.01f);
+                }catch(Exception e){
+                    Log.err(e);
+                    arcui.arcInfo("[orange]图片读取失败");
+                }
+            }).start();
+        });
+
+        return true;
+    }
+
+    public static void arcSharePicture(){
+
+        Dialog dialog = new BaseDialog("图片分享器");
+        dialog.cont.table(t -> {
+            t.button("[cyan]选择图片[white](png)", () -> platform.showFileChooser(false, "png", file -> {
+                figureFile = file;
+                try{
+                    byte[] bytes = file.readBytes();
+                    oriImage = new Pixmap(bytes);
+                    rebuildShare();
+                    if(oriImage.width > 500 || oriImage.height > 500)
+                        arcui.arcInfo("[orange]警告：图片可能过大，请尝试压缩图片", 5);
+                }catch(Throwable e){
+                    arcui.arcInfo("读取图片失败，请尝试更换图片\n" + e);
+                }
+            })).size(240, 50).padBottom(20f).row();
+            t.table(a -> tTable = a);
+            t.row();
+            figureLink = t.field("在此输入图片网址api", text -> {
+            }).width(400f).get();
+            t.button("♐", () -> {
+                Call.sendChatMessage(getPrefix("yellow", "Picture").append(figureLink.getText()).toString().replace(" ", ""));
+                figureLink.clear();
+            }).disabled(disable -> !figureLink.getText().startsWith("http"));
+            t.row();
+            t.button("[orange]随机二次元(大雾)", () -> {
+                try{
+                    Http.get("https://api.yimian.xyz/img/?type=moe", res -> {
+                        Pixmap pix = new Pixmap(res.getResult());
+                        Timer.schedule(() -> new floatFigure(pix, player), 0.01f);
+                    });
+                }catch(Exception e){
+                    Log.err(e);
+                    Core.app.post(() -> arcui.arcInfo("[orange]图片读取失败"));
+                }
+
+            }).padTop(30f).width(400f);
+            t.row();
+            t.add("关闭识别方法：中央监控室——设置" + (mobile ? "" : "\nPC端可通过[cyan]扫描模式[white]来隐藏附属信息"));
+        });
+
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    private static void rebuildShare(){
+        tTable.clear();
+        tTable.table(t -> {
+            t.add("名称").color(Pal.accent).padRight(25f).padBottom(10f);
+            t.add(figureFile.name()).padBottom(10f).row();
+            t.add("大小").color(Pal.accent).padRight(25f);
+            t.add(oriImage.width + "\uE815" + oriImage.height);
+        });
+        tTable.row();
+        tTable.add("操作图片").pad(25f);
+        tTable.row();
+        tTable.table(t -> {
+            t.button("添加到本地", () -> new floatFigure(oriImage, player)).width(300f).row();
+            t.button("上传到云以分享", () -> RFuncs.uploadToWeb(figureFile, s -> figureLink.setText(s))).width(300f);
+        });
+    }
+
+    private static boolean checkPic(){
+        if(curPicture >= maxPicture){
+            Core.app.post(() -> arcui.arcInfo("当前图片已达上限，仅允许自己添加图片", 10));
+            return false;
+        }else
+            return true;
+    }
+
+    public static class floatFigure{
+        private final Table t;
+        private final Table pic = new Table();
+        private final Pixmap pix;
+        private float sizeM = 1f;
+        private final @Nullable Player sender;
+        private final TextureRegion cache;
+
+        floatFigure(Pixmap pixmap, @Nullable Player playersender){
+            curPicture += 1;
+
+            pix = pixmap;
+            t = new Table(Styles.black3);
+            sender = playersender;
+            cache = new TextureRegion(new Texture(pix));
+
+            t.add(pic);
+            t.visible = false;
+            t.setPosition(Core.graphics.getWidth() / 3f * 2, Core.graphics.getHeight() / 3f * 2, Align.center);
+            t.pack();
+            t.act(0.1f);
+            t.update(() -> {
+                if(!state.isGame()) clear();
+            });
+            Core.scene.add(t);
+            buildTable();
+            arcui.arcInfo("已收到图片!，来源：" + (playersender != null ? playersender.isNull() ? "" : playersender.name : "") + "\n[gray]使用参考中央监控室-图片分享器");
+            pix.dispose();
+        }
+
+        private void buildTable(){
+            pic.clear();
+            float ratio = Math.max(pix.width, pix.height) / 500f / sizeM;
+            t.visible = true;
+            pic.image(cache).size(pix.width / ratio, pix.height / ratio).get();
+            pic.row();
+            pic.table(tp -> {
+                if(sender != null) tp.add("[cyan]来源：" + sender.name()).fontScale(sizeM).row();
+                tp.table(tpa -> {
+                    tpa.button("\uE879", Styles.cleart, this::saveFig).size(40);
+                    tpa.button("-", Styles.cleart, () -> {
+                        sizeM = sizeM / 1.2f;
+                        buildTable();
+                    }).size(40);
+                    tpa.button("+", Styles.cleart, () -> {
+                        sizeM = sizeM * 1.2f;
+                        buildTable();
+                    }).size(40);
+                    tpa.button("[red]x", Styles.cleart, this::clear).size(40);
+                });
+            }).visible(() -> mobile || control.input.arcScanMode);
+            t.addListener(new ElementGestureListener(){
+                @Override
+                public void pan(InputEvent event, float x, float y, float deltaX, float deltaY){
+                    t.setPosition(t.x + deltaX / 2, t.y + deltaY / 2);
+                }
+            });
+        }
+
+        private void clear(){
+            t.visible = false;
+            t.clearListeners();
+            t.remove();
+            curPicture -= 1;
+        }
+
+        private void saveFig(){
+            platform.export("图片-" + Time.millis(), "png", file -> PixmapIO.writePng(file, pix));
+            arcui.arcInfo("[cyan]已保存图片");
+        }
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/toolpack/arcScanMode.java b/core/src/mindustry/arcModule/toolpack/arcScanMode.java
new file mode 100644
index 0000000000000000000000000000000000000000..7081c140bdd2182966d7acdad7053f92a5c52318
--- /dev/null
+++ b/core/src/mindustry/arcModule/toolpack/arcScanMode.java
@@ -0,0 +1,449 @@
+package mindustry.arcModule.toolpack;
+
+import arc.*;
+import arc.func.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.math.*;
+import arc.math.geom.*;
+import arc.scene.event.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.ai.types.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.input.*;
+import mindustry.type.*;
+import mindustry.ui.*;
+import mindustry.world.*;
+import mindustry.world.blocks.distribution.*;
+import mindustry.world.blocks.liquid.*;
+import mindustry.world.blocks.production.*;
+import mindustry.world.blocks.storage.*;
+import mindustry.world.meta.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.RFuncs.*;
+import static mindustry.arcModule.draw.ARCUnits.drawControlTurret;
+import static mindustry.arcModule.toolpack.arcWaveSpawner.*;
+
+public class arcScanMode{
+    private static final Table ct = new Table(Styles.none);
+    private static final Table ctTable = new Table();
+    /** spawner */
+    private static final Table spt;
+    private static final Table sfpt;
+    private static final Table spawnerTable = new Table();
+    private static final Table flyerTable = new Table();
+    static int totalAmount = 0, totalHealth = 0, totalEffHealth = 0, totalDps = 0;
+
+    /**
+     * conveyor
+     */
+    static final int maxLoop = 200;
+
+
+    static{
+        {
+            ct.touchable = Touchable.disabled;
+            ct.visible = false;
+            ct.add(ctTable).margin(8f);
+            ct.pack();
+            ct.update(() -> ct.visible = ct.visible && state.isPlaying());
+            Core.scene.add(ct);
+        }
+        {
+            spt = new Table();
+            spt.touchable = Touchable.disabled;
+            spt.visible = false;
+            spt.add(spawnerTable).margin(8f);
+            spt.pack();
+            spt.update(() -> spt.visible = spt.visible && state.isPlaying());
+            Core.scene.add(spt);
+
+            sfpt = new Table();
+            sfpt.touchable = Touchable.disabled;
+            sfpt.visible = false;
+            sfpt.add(flyerTable).margin(8f);
+            sfpt.pack();
+            sfpt.update(() -> sfpt.visible = sfpt.visible && state.isPlaying());
+            Core.scene.add(sfpt);
+        }
+    }
+
+    public static void arcScan(){
+        detailCursor();
+        detailSpawner();
+        //detailTransporter();
+        detailTransporter2();
+        findLogic();
+        drawControlTurret();    //按理来说不应该放这，但不知道放哪了。
+    }
+
+    private static void detailCursor(){
+        ct.visible = ct.visible && state.isPlaying();
+        ctTable.clear();
+        if(!control.input.arcScanMode){
+            ct.visible = false;
+            return;
+        }
+        ct.setPosition(Core.input.mouseX(), Core.input.mouseY());
+        ct.visible = true;
+        ctTable.table(ctt -> {
+            ctt.add((int)(Core.input.mouseWorldX() / 8) + "," + (int)(Core.input.mouseWorldY() / 8));
+            ctt.row();
+            ctt.add("距离：" + (int)(Mathf.dst(player.x, player.y, Core.input.mouseWorldX(), Core.input.mouseWorldY()) / 8));
+        });
+    }
+
+    private static void detailSpawner(){
+        spt.visible = spt.visible && state.isPlaying();
+        sfpt.visible = sfpt.visible && state.isPlaying();
+        spawnerTable.clear();
+        flyerTable.clear();
+        if(!control.input.arcScanMode || arcWave.isEmpty()){
+            spt.visible = false;
+            sfpt.visible = false;
+            return;
+        }
+        totalAmount = 0;
+        totalHealth = 0;
+        totalEffHealth = 0;
+        totalDps = 0;
+        checkInit();
+        waveInfo thisWave = arcWave.get(Math.min(state.wave - 1, Math.max(arcWave.size - 1, 0)));
+        for(Tile tile : spawner.getSpawns()){
+            if(Mathf.dst(tile.worldx(), tile.worldy(), Core.input.mouseWorldX(), Core.input.mouseWorldY()) < state.rules.dropZoneRadius){
+                float curve = Mathf.curve(Time.time % 240f, 120f, 240f);
+                Draw.z(Layer.effect - 2f);
+                Draw.color(state.rules.waveTeam.color);
+                Lines.stroke(4f);
+                //flyer
+                float flyerAngle = Angles.angle(world.width() / 2f, world.height() / 2f, tile.x, tile.y);
+                float trns = Math.max(world.width(), world.height()) * Mathf.sqrt2 * tilesize;
+                float spawnX = Mathf.clamp(world.width() * tilesize / 2f + Angles.trnsx(flyerAngle, trns), 0, world.width() * tilesize);
+                float spawnY = Mathf.clamp(world.height() * tilesize / 2f + Angles.trnsy(flyerAngle, trns), 0, world.height() * tilesize);
+
+                if(hasFlyer){
+                    Lines.line(tile.worldx(), tile.worldy(), spawnX, spawnY);
+                    Tmp.v1.set(spawnX - tile.worldx(), spawnY - tile.worldy());
+                    Tmp.v1.setLength(Tmp.v1.len() * curve);
+                    Fill.circle(tile.worldx() + Tmp.v1.x, tile.worldy() + Tmp.v1.y, 8f);
+
+                    Vec2 v = Core.camera.project(spawnX, spawnY);
+                    sfpt.setPosition(v.x, v.y);
+                    sfpt.visible = true;
+
+                    flyerTable.table(Styles.black3, tt -> {
+                        tt.add(calWaveTimer()).row();
+                        thisWave.specLoc(tile.pos(), group -> group.type.flying);
+                        tt.add(thisWave.proTable(false));
+                        tt.row();
+                        tt.add(thisWave.unitTable(tile.pos(), group -> group.type.flying)).maxWidth(mobile ? 400f : 750f).growX();
+                    });
+                }
+                //ground
+                totalAmount = 0;
+                totalHealth = 0;
+                totalEffHealth = 0;
+                totalDps = 0;
+
+                if(curve > 0)
+                    Lines.circle(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius * Interp.pow3Out.apply(curve));
+                Lines.circle(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius);
+                Lines.arc(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius - 3f, state.wavetime / state.rules.waveSpacing, 90f);
+                float angle = Mathf.pi / 2 + state.wavetime / state.rules.waveSpacing * 2 * Mathf.pi;
+                Draw.color(state.rules.waveTeam.color);
+                Fill.circle(tile.worldx() + state.rules.dropZoneRadius * Mathf.cos(angle), tile.worldy() + state.rules.dropZoneRadius * Mathf.sin(angle), 8f);
+
+                Vec2 v = Core.camera.project(tile.worldx(), tile.worldy());
+                spt.setPosition(v.x, v.y);
+                spt.visible = true;
+                spawnerTable.table(Styles.black3, tt -> {
+                    tt.add(calWaveTimer()).row();
+                    thisWave.specLoc(tile.pos(), group -> !group.type.flying);
+                    tt.add(thisWave.proTable(false));
+                    tt.row();
+                    tt.add(thisWave.unitTable(tile.pos(), group -> !group.type.flying)).maxWidth(mobile ? 400f : 750f).growX();
+                });
+                return;
+            }
+        }
+
+        spt.visible = false;
+        spawnerTable.clear();
+    }
+
+    private static void findLogic(){
+        if(!Core.input.keyTap(Binding.select) || !control.input.arcScanMode) return;
+        Tile hoverTile = world.tileWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
+        if(hoverTile != null){
+            //if the tile has a building, display it
+            if(hoverTile.build != null && hoverTile.build.displayable() && !hoverTile.build.inFogTo(player.team())
+            && hoverTile.build.lastLogicController != null){
+                arcSetCamera(hoverTile.build.lastLogicController);
+            }
+        }
+        Unit u = control.input.selectedUnit();
+        if(u != null && u.controller() instanceof LogicAI ai && ai.controller != null && ai.controller.isValid()){
+            arcSetCamera(ai.controller);
+        }
+    }
+
+    private static boolean canAccept(Block block){
+        if(block.group == BlockGroup.transportation) return true;
+        for(Item item : content.items()){
+            if(block.consumesItem(item) || block.itemCapacity > 0){
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static Seq<Point> path = new Seq<>();
+
+    public static void detailTransporter2(){
+        if(!control.input.arcScanMode) return;
+
+        //check tile being hovered over
+        Tile hoverTile = world.tileWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
+        if(hoverTile == null || hoverTile.build == null || !hoverTile.build.isDiscovered(player.team())){
+            return;
+        }
+
+        path.clear();
+        travelPath(new Point(hoverTile.build, null), arcScanMode::getPrevious);
+        drawPath(false);
+
+        path.clear();
+        travelPath(new Point(hoverTile.build, null), arcScanMode::getNext);
+        drawPath(true);
+    }
+
+    public static void travelPath(Point point, Func<Point, Seq<Point>> getNext){
+        if(point.build == null || path.size > maxLoop) return;
+        if(!point.trans) return;
+
+        Point same = path.find(other -> point.build == other.build && (other.from == null || point.from.build == other.from.build));
+        if(same != null){
+            if(point.conduit >= same.conduit) return;
+            else path.replace(same, point);
+        }else path.add(point);
+
+        getNext.get(point).each(p -> travelPath(p, getNext));
+    }
+
+    public static Seq<Point> getPrevious(Point point){
+        Building build = point.build;
+        if(build == null) return new Seq<>();
+        Seq<Point> previous = new Seq<>();
+        //质驱
+        if(build instanceof MassDriver.MassDriverBuild){
+            //暂时搞不定
+        }//桥
+        else if(build instanceof ItemBridge.ItemBridgeBuild bridge && !(build instanceof LiquidBridge.LiquidBridgeBuild)){
+            bridge.incoming.each(pos -> previous.add(new Point(world.tile(pos).build, point)));
+        }//导管桥
+        else if(build instanceof DirectionBridge.DirectionBridgeBuild bridge){
+            for(Building b : bridge.occupied){
+                if(b != null){
+                    previous.add(new Point(b, point));
+                }
+            }
+        }
+        for(Building b : build.proximity){
+            Point from = new Point(b, b.relativeTo(build), b.block.instantTransfer ? point.conduit + 1 : 0, point);
+            if(canInput(point, b, true) && canOutput(from, build, false)){
+                previous.add(from);
+            }else if(canOutput(from, build, false)){
+                from.trans = false;
+                previous.add(from);
+            }
+        }
+        return previous;
+    }
+
+    public static Seq<Point> getNext(Point point){
+        Building build = point.build;
+        if(build == null) return new Seq<>();
+        Seq<Point> next = new Seq<>();
+        //质驱
+        if(build instanceof MassDriver.MassDriverBuild massDriverBuild){
+            if(massDriverBuild.arcLinkValid()){
+                next.add(new Point(world.build(massDriverBuild.link), point));
+            }
+        }//桥
+        else if(build instanceof ItemBridge.ItemBridgeBuild itemBridgeBuild && !(build instanceof LiquidBridge.LiquidBridgeBuild)){
+            if(itemBridgeBuild.arcLinkValid()){
+                next.add(new Point(world.build(itemBridgeBuild.link), point));
+            }
+        }//导管桥
+        else if(build instanceof DirectionBridge.DirectionBridgeBuild directionBridgeBuild){
+            DirectionBridge.DirectionBridgeBuild link = directionBridgeBuild.findLink();
+            if(link != null){
+                next.add(new Point(link, point));
+            }
+        }
+
+        for(Building b : build.proximity){
+            Point to = new Point(b, build.relativeTo(b), b.block.instantTransfer ? point.conduit + 1 : 0, point);
+            if(canInput(to, build, false) && canOutput(point, b, true)){
+                next.add(to);
+            }else if(canInput(to, build, false)){
+                to.trans = false;
+                next.add(to);
+            }
+        }
+        return next;
+    }
+
+    public static boolean canInput(Point point, Building from, boolean active){
+        Building build = point.build;
+        if(build == null || from == null) return false;
+        if(from.block.instantTransfer && point.conduit > 2) return false;
+        //装甲传送带
+        if(build instanceof ArmoredConveyor.ArmoredConveyorBuild){
+            return from != build.front() && (from instanceof Conveyor.ConveyorBuild || from == build.back());
+        }//装甲导管
+        else if(build instanceof Duct.DuctBuild ductBuild && ((Duct)ductBuild.block).armored){
+            return from != build.front() && (from.block.isDuct || from == build.back());
+        }//传送带和导管
+        else if(build instanceof Conveyor.ConveyorBuild || build instanceof Duct.DuctBuild){
+            return from != build.front();
+        }//塑钢带
+        else if(build instanceof StackConveyor.StackConveyorBuild stackConveyorBuild){
+            return switch(stackConveyorBuild.state){
+                case 2 -> from == build.back() && from instanceof StackConveyor.StackConveyorBuild;
+                case 1 -> from != build.front();
+                default -> from instanceof StackConveyor.StackConveyorBuild;
+            };
+        }//交叉器
+        else if(build instanceof Junction.JunctionBuild){
+            return point.facing == -1 || from.relativeTo(build) == point.facing;
+        }//分类
+        else if(build instanceof Sorter.SorterBuild sorterBuild){
+            return !active || build.relativeTo(from) != point.facing && (sorterBuild.sortItem != null || (from.relativeTo(build) == point.facing) == ((Sorter)sorterBuild.block).invert);
+        }//溢流
+        else if(build instanceof OverflowGate.OverflowGateBuild){
+            return !active || build.relativeTo(from) != point.facing;
+        }//导管路由器与导管溢流
+        else if(build instanceof DuctRouter.DuctRouterBuild || build instanceof OverflowDuct.OverflowDuctBuild){
+            return from == build.back();
+        }//桥
+        else if(build instanceof ItemBridge.ItemBridgeBuild itemBridgeBuild){
+            return itemBridgeBuild.arcCheckAccept(from);
+        }//导管桥
+        else if(build instanceof DirectionBridge.DirectionBridgeBuild directionBridgeBuild){
+            return directionBridgeBuild.arcCheckAccept(from);
+        }else if(build instanceof Router.RouterBuild){
+            return true;
+        }else if(canAccept(build.block)){
+            point.trans = false;
+            return true;
+        }
+        return false;
+    }
+
+    public static boolean canOutput(Point point, Building to, boolean active){
+        Building build = point.build;
+        if(build == null || to == null) return false;
+        if(to.block.instantTransfer && point.conduit > 2) return false;
+        //传送带和导管
+        if(build instanceof Conveyor.ConveyorBuild || build instanceof Duct.DuctBuild){
+            return to == build.front();
+        }//塑钢带
+        else if(build instanceof StackConveyor.StackConveyorBuild stackConveyor){
+            if(stackConveyor.state == 2 && ((StackConveyor)stackConveyor.block).outputRouter){
+                return to != build.back();
+            }
+            return to == build.front();
+        }//交叉器
+        else if(build instanceof Junction.JunctionBuild){
+            return point.facing == -1 || build.relativeTo(to) == point.facing;
+        }//分类
+        else if(build instanceof Sorter.SorterBuild sorterBuild){
+            return !active || to.relativeTo(build) != point.facing && (sorterBuild.sortItem != null || (build.relativeTo(to) == point.facing) == ((Sorter)sorterBuild.block).invert);
+        }//溢流
+        else if(build instanceof OverflowGate.OverflowGateBuild){
+            return !active || to.relativeTo(build) != point.facing;
+        }//导管路由器与导管溢流
+        else if(build instanceof DuctRouter.DuctRouterBuild || build instanceof OverflowDuct.OverflowDuctBuild){
+            return to != build.back();
+        }//桥
+        else if(build instanceof ItemBridge.ItemBridgeBuild bridge){
+            return bridge.arcCheckDump(to);
+        }//导管桥
+        else if(build instanceof DirectionBridge.DirectionBridgeBuild directionBridgeBuild){
+            DirectionBridge.DirectionBridgeBuild link = directionBridgeBuild.findLink();
+            return link == null && build.relativeTo(to) == build.rotation;
+        }else if(build instanceof Router.RouterBuild || build instanceof Unloader.UnloaderBuild){
+            return true;
+        }else if(build instanceof GenericCrafter.GenericCrafterBuild){
+            point.trans = false;
+            return true;
+        }
+        return false;
+    }
+
+    public static void drawPath(boolean forward){
+        Color mainColor = forward ? Color.valueOf("80ff00") : Color.valueOf("ff8000");
+        Color highlightColor = forward ? Color.valueOf("00cc00") : Color.red;
+        path.each(p -> {
+            if(p.from != null && p.trans){
+                float x1 = p.build.tile.drawx(), y1 = p.build.tile.drawy();
+                float x2 = p.from.build.tile.drawx(), y2 = p.from.build.tile.drawy();
+
+                Draw.color(mainColor);
+                Draw.color(Tmp.c1.set(mainColor).a(Mathf.absin(4f, 1f) * 0.4f + 0.6f));
+                Lines.stroke(1.5f);
+                Lines.line(x1, y1, x2, y2);
+            }else{
+                Drawf.selected(p.build, Tmp.c1.set(highlightColor).a(Mathf.absin(4f, 1f) * 0.5f + 0.5f));
+            }
+            Draw.reset();
+        });
+        path.each(p -> {
+            if(p.from != null && p.trans){
+                float x1 = p.build.tile.drawx(), y1 = p.build.tile.drawy();
+                float x2 = p.from.build.tile.drawx(), y2 = p.from.build.tile.drawy();
+                float dst = Mathf.dst(x1, y1, x2, y2);
+
+                Draw.color(highlightColor);
+                Fill.circle(x1, y1, 1.8f);
+
+                if(dst > tilesize){
+                    Draw.color(highlightColor);
+                    if(forward){
+                        Drawf.simpleArrow(x2, y2, x1, y1, dst / 2, 3f);
+                    }else{
+                        Drawf.simpleArrow(x1, y1, x2, y2, dst / 2, 3f);
+                    }
+                }
+            }
+            Draw.reset();
+        });
+    }
+
+    public static class Point{
+        public Building build;
+        public byte facing = -1;
+        public int conduit = 0;
+        //用于记录端点方块
+        public boolean trans = true;
+
+        public Point from;
+
+        public Point(Building build, Point from){
+            this.build = build;
+            this.from = from;
+        }
+
+        public Point(Building build, byte facing, int conduit, Point from){
+            this.build = build;
+            this.facing = facing;
+            this.conduit = conduit;
+            this.from = from;
+        }
+    }
+}
diff --git a/core/src/mindustry/arcModule/toolpack/arcScanner.java b/core/src/mindustry/arcModule/toolpack/arcScanner.java
new file mode 100644
index 0000000000000000000000000000000000000000..fc010ec59df1250f89434bcc312628bd29c150ae
--- /dev/null
+++ b/core/src/mindustry/arcModule/toolpack/arcScanner.java
@@ -0,0 +1,256 @@
+package mindustry.arcModule.toolpack;
+
+import arc.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.math.*;
+import arc.scene.event.*;
+import arc.scene.ui.layout.*;
+import arc.util.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.input.*;
+import mindustry.ui.*;
+import mindustry.world.*;
+import mindustry.world.blocks.storage.*;
+import mindustryX.features.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.DrawUtilities.drawText;
+
+public class arcScanner{
+
+    /** 基础缩放倍率，最重要的参数 */
+    private static final float ratio = 10f;
+    private static final float unitSize = 0.1f;
+    private static final float markerSize = 15f * tilesize;
+    /** 范围倍率 */
+    private static final int basicRadarCir = 25;
+    private static final Table t = new Table(Styles.black3);
+    public static boolean mobileRadar = false;
+    /** 真实大小 */
+    private static float rRatio;
+    private static float rMarkerSize;
+    /** 每多少范围一个雷达圈 */
+    private static float radarCir = 25f;
+    /** 默认扫描时间，仅用于特效 */
+    private static float scanTime = 5;
+    /** 当前扫描的百分比 */
+    private static float scanRate = 0;
+    /** 扫描线旋转倍率 */
+    private static final float scanSpeed = -0.02f;
+    /** 实际扫描范围，不是参数 */
+    private static float curScanRange = 0;
+    private static float expandRate = 1f;
+    private static float time = 0;
+
+    static{
+        t.touchable = Touchable.disabled;
+        t.margin(8f).add(">> 雷达扫描中 <<").color(Pal.accent).style(Styles.outlineLabel).labelAlign(Align.center);
+        t.visible = false;
+        t.update(() -> t.setPosition(Core.graphics.getWidth() / 2f, Core.graphics.getHeight() * 0.1f, Align.center));
+        t.pack();
+        t.act(0.1f);
+        t.update(() -> t.visible = t.visible && state.isPlaying());
+
+        Core.scene.add(t);
+
+        Events.on(EventType.WorldLoadEvent.class, event -> scanTime = Math.max(Mathf.dst(world.width(), world.height()) / 20f, 7.5f));
+    }
+
+    public static void drawScanner(){
+        if(Core.settings.getInt("radarMode") == 0) return;
+        float extendSpd = Core.settings.getInt("radarMode") * 0.2f;
+        Draw.reset();
+
+        if(mobile){
+            if(extendSpd >= 6){
+                t.visible = mobileRadar;
+                scanRate = t.visible ? 1f : 0f;
+            }else{
+                if(mobileRadar){
+                    t.visible = true;
+                    if(scanRate < 1f) scanRate = Math.min(scanRate + 1 / 60f / scanTime * extendSpd, 1f);
+                }else{
+                    t.visible = false;
+                    if(scanRate > 0f) scanRate = Math.max(scanRate - 3 / 60f / scanTime * extendSpd, 0f);
+                }
+            }
+        }else{
+            if(extendSpd >= 6){
+                if(Core.input.keyDown(Binding.arcDetail) && Time.time - time > 60f){
+                    time = Time.time;
+                    t.visible = !t.visible;
+                    scanRate = t.visible ? 1f : 0f;
+                }
+            }else{
+                if(Core.input.keyDown(Binding.arcDetail)){
+                    t.visible = true;
+                    if(scanRate < 1f) scanRate = Math.min(scanRate + 1 / 60f / scanTime * extendSpd, 1f);
+                }else{
+                    t.visible = false;
+                    if(scanRate > 0f) scanRate = Math.max(scanRate - 3 / 60f / scanTime * extendSpd, 0f);
+                }
+            }
+        }
+
+        if(scanRate <= 0) return;
+
+        float playerToBorder = Math.max(Math.max(Math.max(Mathf.dst(player.tileX(), player.tileY()), Mathf.dst(world.width() - player.tileX(), player.tileY())), Mathf.dst(world.width() - player.tileX(), world.height() - player.tileY())), Mathf.dst(player.tileX(), world.height() - player.tileY()));
+        float worldSize = Math.min(playerToBorder, (int)(Mathf.dst(world.width(), world.height()) / radarCir) * radarCir);
+
+        float playerSize = Math.min(world.width(), world.height()) * tilesize * 0.03f;
+
+        /** 整体缩放倍率，最重要的可调参数 */
+        float sizeRate = Core.settings.getInt("radarSize") == 0 ? 1f : Core.settings.getInt("radarSize") * 0.1f / renderer.getScale();
+        sizeRate *= Math.min(Core.scene.getHeight() / (world.height() * tilesize), Core.scene.getWidth() / (world.width() * tilesize)) * 2f;
+        rRatio = ratio / sizeRate;
+        float rUnitSize = unitSize * sizeRate;
+        rMarkerSize = markerSize * sizeRate;
+
+
+        expandRate = worldSize / basicRadarCir / 10 + 1;
+        radarCir = (int)expandRate * basicRadarCir;  //地图越大，radar间隔越大。此处选择最多10圈
+        curScanRange = worldSize * tilesize * scanRate;
+
+        expandRate *= sizeRate;
+
+        for(int i = 1; i < curScanRange / radarCir / tilesize + 1; i++){
+            Draw.color(player.team().color, 0.45f);
+            Lines.stroke(expandRate * 0.75f);
+            Lines.circle(player.x, player.y, (radarCir * i * tilesize) / rRatio);
+            float cirRatio = (radarCir * i * tilesize) / rRatio + 2f;
+            drawText(i * (int)radarCir + "", 0.2f / Scl.scl(1f) * expandRate, player.x, player.y + cirRatio, Pal.accent, Align.center);
+            drawText(i * (int)radarCir + "", 0.2f / Scl.scl(1f) * expandRate, player.x + cirRatio * Mathf.cos(Mathf.PI * 7 / 6), player.y + cirRatio * Mathf.sin(Mathf.PI * 7 / 6), Pal.accent, Align.center);
+            drawText(i * (int)radarCir + "", 0.2f / Scl.scl(1f) * expandRate, player.x + cirRatio * Mathf.cos(Mathf.PI * 11 / 6), player.y + cirRatio * Mathf.sin(Mathf.PI * 11 / 6), Pal.accent, Align.center);
+        }
+
+        if(scanRate < 1f){
+            Draw.color(player.team().color, 0.8f);
+            Lines.stroke(expandRate);
+            Lines.circle(player.x, player.y, curScanRange / rRatio);
+            Draw.color(player.team().color, 0.1f);
+            Fill.circle(player.x, player.y, curScanRange / rRatio);
+        }else{
+            curScanRange = (int)(curScanRange / radarCir / tilesize + 1) * radarCir * tilesize;
+
+            Draw.color(player.team().color, 0.1f);
+            Fill.circle(player.x, player.y, curScanRange / rRatio);
+
+            Draw.color(player.team().color, 0.6f);
+            float curve = Mathf.curve(Time.time % 360f, 120f, 360f);
+            Lines.stroke(expandRate * 1.5f);
+            Lines.circle(player.x, player.y, curScanRange / rRatio);
+            Lines.stroke(expandRate * 1.5f);
+            Lines.circle(player.x, player.y, curScanRange * Interp.pow3Out.apply(curve) / rRatio);
+            Lines.stroke(expandRate * 1.5f);
+
+            Draw.color(player.team().color, 0.1f);
+            Fill.rect(player.x - player.x / rRatio + world.width() * tilesize / rRatio / 2, player.y - player.y / rRatio + world.height() * tilesize / rRatio / 2, world.width() * tilesize / rRatio, world.height() * tilesize / rRatio);
+            Draw.color(player.team().color, 0.85f);
+            Lines.rect(player.x - player.x / rRatio, player.y - player.y / rRatio, world.width() * tilesize / rRatio, world.height() * tilesize / rRatio);
+        }
+
+        Draw.color(player.team().color, 0.8f);
+        Lines.line(player.x, player.y, player.x + curScanRange * Mathf.cos(Time.time * scanSpeed) / rRatio, player.y + curScanRange * Mathf.sin(Time.time * scanSpeed) / rRatio);
+        Draw.reset();
+
+        // 出怪点
+        if(spawner.countSpawns() < 25 && !state.rules.pvp){
+            for(Tile tile : spawner.getSpawns()){
+                if(scanRate < 1f && Mathf.dst(tile.worldx() - player.x, tile.worldy() - player.y) > curScanRange)
+                    continue;
+
+                Draw.color(state.rules.waveTeam.color, 1f);
+                arcDrawNearby(Icon.units.getRegion(), tile, Math.max(6 * expandRate, state.rules.dropZoneRadius / rRatio / 2), state.rules.waveTeam.color);
+
+                float curve = Mathf.curve(Time.time % 200f, 60f, 200f);
+                Draw.color(state.rules.waveTeam.color, 1f);
+                Lines.stroke(expandRate);
+                Lines.circle(transX(tile.worldx()), transY(tile.worldy()), state.rules.dropZoneRadius * Interp.pow3Out.apply(curve) / rRatio);
+                Draw.color(state.rules.waveTeam.color, 0.5f);
+                Lines.stroke(expandRate * 0.8f);
+                Lines.dashCircle(transX(tile.worldx()), transY(tile.worldy()), state.rules.dropZoneRadius / rRatio);
+            }
+        }
+        //绘制核心
+        for(Team team : Team.all){
+            for(CoreBlock.CoreBuild core : team.cores()){
+                if(state.rules.pvp && core.inFogTo(player.team())) continue;
+                if(scanRate < 1f && Mathf.dst(core.x - player.x, core.y - player.y) > curScanRange) continue;
+                Draw.color(core.team.color, 1f);
+                Draw.rect(core.block.fullIcon, transX(core.tile.worldx()), transY(core.tile.worldy()), 4 * expandRate, 4 * expandRate);
+
+            }
+        }
+        //绘制搜索的方块
+        for(Building build : ui.hudfrag.quickToolTable.advanceBuildTool.buildingSeq){
+            if(scanRate < 1f && Mathf.dst(build.x - player.x, build.y - player.y) > curScanRange) continue;
+            Draw.color(build.team.color, 1f);
+            Draw.rect(build.block.fullIcon, transX(build.tile.worldx()), transY(build.tile.worldy()), 4 * expandRate, 4 * expandRate);
+        }
+        //绘制单位
+        for(Unit unit : Groups.unit){
+            if(scanRate < 1f && Mathf.dst(unit.x - player.x, unit.y - player.y) > curScanRange) continue;
+            Draw.color(unit.team.color, 0.6f);
+            Fill.circle(transX(unit.x), transY(unit.y), unit.hitSize * rUnitSize);
+        }
+        //绘制玩家
+        for(Player unit : Groups.player){
+            if(player.dead() || player.unit().health <= 0) continue;
+            if(scanRate < 1f && Mathf.dst(unit.x - player.x, unit.y - player.y) > curScanRange) continue;
+
+            Draw.color(unit.team().color, 0.9f);
+
+            float angle = unit.unit().rotation * Mathf.degreesToRadians;
+            Fill.tri(transX(unit.x + Mathf.cos(angle) * playerSize), transY(unit.y + Mathf.sin(angle) * playerSize),
+            transX(unit.x + Mathf.cos(angle + Mathf.PI * 2 / 3) * playerSize * 0.75f), transY(unit.y + Mathf.sin(angle + Mathf.PI * 2 / 3) * playerSize * 0.75f),
+            transX(unit.x + Mathf.cos(angle + Mathf.PI * 4 / 3) * playerSize * 0.75f), transY(unit.y + Mathf.sin(angle + Mathf.PI * 4 / 3) * playerSize * 0.75f));
+        }
+        //绘制arc标记
+        MarkerType.eachActive(a -> {
+            Draw.color(a.color);
+            Lines.stroke(expandRate * (1 - (Time.time % 180 + 30) / 210));
+
+            Lines.circle(transX(a.x), transY(a.y), rMarkerSize / rRatio * (Time.time % 180) / 180);
+            Lines.stroke(expandRate);
+            Lines.circle(transX(a.x), transY(a.y), rMarkerSize / rRatio);
+            Lines.arc(transX(a.x), transY(a.y), (rMarkerSize - expandRate) / rRatio, 1 - (Time.time - a.time) / MarkerType.retainTime);
+            Draw.reset();
+        });
+    }
+
+    /**
+     * 以玩家为中心，绘制一个环绕的图标圈
+     */
+
+    public static void arcDrawNearbyRot(TextureRegion region, Tile tile, float size, boolean rotate, Color color){
+        float range = Mathf.dst(tile.worldy() - player.y, tile.worldx() - player.x);
+        if(range > curScanRange) return;
+
+        float rot = (float)Math.atan2(tile.worldy() - player.y, tile.worldx() - player.x);
+        float nx = player.x + Mathf.cos(rot) * range / rRatio;
+        float ny = player.y + Mathf.sin(rot) * range / rRatio;
+        if(rotate) Draw.rect(region, nx, ny, size, size, (float)Math.toDegrees(rot));
+        else Draw.rect(region, nx, ny, size, size);
+        drawText((int)(range / 8f) + "", 0.2f / Scl.scl(1f) * expandRate, nx, ny + size / 2, color, Align.center);
+    }
+
+    public static void arcDrawNearby(TextureRegion region, Tile tile, float size, Color color){
+        float range = Mathf.dst(tile.worldy() - player.y, tile.worldx() - player.x);
+        if(range > curScanRange) return;
+        float nx = player.x + (tile.worldx() - player.x) / rRatio;
+        float ny = player.y + (tile.worldy() - player.y) / rRatio;
+        Draw.rect(region, nx, ny, size, size);
+    }
+
+    private static float transX(float x){
+        return player.x + (x - player.x) / rRatio;
+    }
+
+    private static float transY(float y){
+        return player.y + (y - player.y) / rRatio;
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/toolpack/arcWaveSpawner.java b/core/src/mindustry/arcModule/toolpack/arcWaveSpawner.java
new file mode 100644
index 0000000000000000000000000000000000000000..09eb4cf9c500cd1dea69a39261ec9011b74d8763
--- /dev/null
+++ b/core/src/mindustry/arcModule/toolpack/arcWaveSpawner.java
@@ -0,0 +1,243 @@
+package mindustry.arcModule.toolpack;
+
+import arc.*;
+import arc.func.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.math.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.content.*;
+import mindustry.core.*;
+import mindustry.game.*;
+import mindustry.world.*;
+import mindustryX.features.ui.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.DrawUtilities.arcDashCircling;
+
+public class arcWaveSpawner{
+
+    public static boolean hasFlyer = true;
+
+    public static float flyerSpawnerRadius = 5f * tilesize;
+
+    static float spawnerMargin = tilesize * 11f;
+
+    public static Seq<waveInfo> arcWave = new Seq<>();
+
+    static{
+        Events.on(EventType.WorldLoadEvent.class, event -> {
+            hasFlyer = false;
+            for(SpawnGroup sg : state.rules.spawns){
+                if(sg.type.flying){
+                    hasFlyer = true;
+                    break;
+                }
+            }
+            initArcWave();
+        });
+    }
+
+    public static void drawSpawner(){
+        if(state.hasSpawns()){
+            Lines.stroke(2f);
+            Draw.color(Color.gray, Color.lightGray, Mathf.absin(Time.time, 8f, 1f));
+
+            if(Core.settings.getBool("alwaysshowdropzone")){
+                Draw.alpha(0.8f);
+                for(Tile tile : spawner.getSpawns()){
+                    arcDashCircling(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius, -flyerSpawnerRadius / state.rules.dropZoneRadius * 0.1f);
+                }
+            }else{
+                for(Tile tile : spawner.getSpawns()){
+                    if(tile.within(player.x, player.y, state.rules.dropZoneRadius + spawnerMargin)){
+                        Draw.alpha(Mathf.clamp(1f - (player.dst(tile) - state.rules.dropZoneRadius) / spawnerMargin));
+                        Lines.dashCircle(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius);
+                    }
+                }
+            }
+            if(hasFlyer && Core.settings.getBool("showFlyerSpawn") && spawner.countSpawns() < 20){
+                for(Tile tile : spawner.getSpawns()){
+                    float angle = Angles.angle(world.width() / 2f, world.height() / 2f, tile.x, tile.y);
+                    float trns = Math.max(world.width(), world.height()) * Mathf.sqrt2 * tilesize;
+                    float spawnX = Mathf.clamp(world.width() * tilesize / 2f + Angles.trnsx(angle, trns), 0, world.width() * tilesize);
+                    float spawnY = Mathf.clamp(world.height() * tilesize / 2f + Angles.trnsy(angle, trns), 0, world.height() * tilesize);
+                    if(Core.settings.getBool("showFlyerSpawnLine")){
+                        Draw.color(Color.red, 0.5f);
+                        Lines.line(tile.worldx(), tile.worldy(), spawnX, spawnY);
+                    }
+                    Draw.color(Color.gray, Color.lightGray, Mathf.absin(Time.time, 8f, 1f));
+                    Draw.alpha(0.8f);
+                    arcDashCircling(spawnX, spawnY, flyerSpawnerRadius, 0.1f);
+
+                    Draw.color();
+                    Draw.alpha(0.5f);
+                    Draw.rect(UnitTypes.zenith.fullIcon, spawnX, spawnY);
+                }
+            }
+            Draw.reset();
+        }
+    }
+
+
+    /* 用于检查可能未成功的初始化 */
+    public static void checkInit(){
+        if(arcWave.size == 0) initArcWave();
+    }
+
+    public static void initArcWave(){
+        initArcWave((int)(calWinWave() * 1.5f));
+    }
+
+    public static void initArcWave(int wave){
+        arcWave = new Seq<>();
+        for(int waveN = 0; waveN < wave; waveN++){
+            arcWave.add(new waveInfo(waveN));
+        }
+    }
+
+    public static int calWinWave(){
+        if(state.rules.winWave >= 1) return state.rules.winWave;
+        int maxwave = 0;
+        for(SpawnGroup group : state.rules.spawns){
+            if(group.end > 99999) continue;
+            maxwave = Math.max(maxwave, group.end);
+        }
+        if(maxwave > 5000) return 200;
+        if(maxwave < 2 && state.rules.waveSpacing > 30f) return (int)(1800000 / state.rules.waveSpacing);
+        return maxwave + 1;
+    }
+
+    /**
+     * 单一波次详情
+     */
+    public static class waveInfo{
+        public int waveIndex;
+        public Seq<waveGroup> groups = new Seq<>();
+
+        public int amount = 0, amountL = 0;
+
+        public float health = 0, effHealth = 0, dps = 0;
+        /**
+         * 临时数据记录
+         */
+        public long healthL = 0, effHealthL = 0, dpsL = 0;
+
+        waveInfo(int waveIndex){
+            this.waveIndex = waveIndex;
+            for(SpawnGroup group : state.rules.spawns){
+                int amount = group.getSpawned(waveIndex);
+                if(amount == 0) continue;
+                groups.add(new waveGroup(waveIndex, group));
+            }
+            initProperty();
+        }
+
+        private void initProperty(){
+            groups.each(group -> {
+                amount += group.amountT;
+                health += group.healthT;
+                effHealth += group.effHealthT;
+                dps += group.dpsT;
+            });
+        }
+
+        public void specLoc(int spawn, Boolf<SpawnGroup> pre){
+            amountL = 0;
+            healthL = 0;
+            effHealthL = 0;
+            dpsL = 0;
+            groups.each(waveGroup -> (spawn == -1 || waveGroup.group.spawn == -1 || waveGroup.group.spawn == spawn) && pre.get(waveGroup.group),
+            group -> {
+                amountL += group.amountT;
+                healthL += group.healthT;
+                effHealthL += group.effHealthT;
+                dpsL += group.dpsT;
+            });
+        }
+
+        public Table proTable(boolean doesRow){
+            if(amountL == 0) return new Table(t -> t.add("该波次没有敌人"));
+            return new Table(t -> {
+                t.add("\uE86D").width(50f);
+                t.add("[accent]" + amountL).growX().padRight(50f);
+                if(doesRow) t.row();
+                t.add("\uE813").width(50f);
+                t.add("[accent]" + UI.formatAmount(healthL)).growX().padRight(50f);
+                if(doesRow) t.row();
+                if(effHealthL != healthL){
+                    t.add("\uE810").width(50f);
+                    t.add("[accent]" + UI.formatAmount(effHealthL)).growX().padRight(50f);
+                    if(doesRow) t.row();
+                }
+                t.add("\uE86E").width(50f);
+                t.add("[accent]" + UI.formatAmount(dpsL)).growX();
+            });
+        }
+
+        public Table unitTable(int spawn, Boolf<SpawnGroup> pre){
+            return unitTable(spawn, pre, 10);
+        }
+
+        public Table unitTable(int spawn, Boolf<SpawnGroup> pre, int perCol){
+            int[] count = new int[1];
+            return new Table(t -> groups.each(waveGroup -> (spawn == -1 || waveGroup.group.spawn == -1 || waveGroup.group.spawn == spawn) && pre.get(waveGroup.group), wg -> {
+                count[0]++;
+                if(count[0] % perCol == 0) t.row();
+                t.table(tt -> {
+                    tt.table(ttt -> {
+                        ttt.image(wg.group.type.uiIcon).size(30);
+                        ttt.add(wg.group.type.typeColor() + wg.amount).fillX();
+                    }).row();
+                    StringBuilder groupInfo = new StringBuilder();
+                    if(wg.shield > 0f)
+                        groupInfo.append(FormatDefault.format(wg.shield));
+                    groupInfo.append("\n[]");
+                    if(wg.group.spawn != -1 && spawn == -1) groupInfo.append("*");
+                    if(wg.group.effect != null && wg.group.effect != StatusEffects.none)
+                        groupInfo.append(wg.group.effect.emoji());
+                    if(wg.group.items != null && wg.group.items.amount > 0)
+                        groupInfo.append(wg.group.items.item.emoji());
+                    if(wg.group.payloads != null && wg.group.payloads.size > 0)
+                        groupInfo.append("\uE87B");
+                    tt.add(groupInfo.toString()).fill();
+                }).height(80f).width(70f);
+
+            }));
+        }
+
+    }
+
+    /**
+     * 一种更为详细的spawnGroup
+     */
+    public static class waveGroup{
+        public int waveIndex;
+        public SpawnGroup group;
+        public int amount, amountT;
+        public float shield, health, effHealth, dps;
+        public float healthT, effHealthT, dpsT;
+
+        public waveGroup(int waveIndex, SpawnGroup group){
+            this.waveIndex = waveIndex;
+            this.group = group;
+            this.amount = group.getSpawned(waveIndex);
+            this.shield = group.getShield(waveIndex);   //盾
+            this.health = (group.type.health + shield) * amount;   //盾+血
+            this.dps = group.type.estimateDps() * amount;
+            this.effHealth = health;
+            if(group.effect != null){
+                this.effHealth *= group.effect.healthMultiplier;
+                this.dps *= group.effect.damageMultiplier * group.effect.reloadMultiplier;
+            }
+
+            int multiplier = group.spawn != -1 || spawner.countSpawns() < 2 ? 1 : spawner.countSpawns();
+            this.amountT = amount * multiplier;
+            this.healthT = health * multiplier;
+            this.effHealthT = effHealth * multiplier;
+            this.dpsT = dps * multiplier;
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/mindustry/arcModule/toolpack/picToMindustry.java b/core/src/mindustry/arcModule/toolpack/picToMindustry.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a95451e8b8a3a9d81405bb6b43c420aaad5a1cc
--- /dev/null
+++ b/core/src/mindustry/arcModule/toolpack/picToMindustry.java
@@ -0,0 +1,343 @@
+package mindustry.arcModule.toolpack;
+
+import arc.*;
+import arc.files.*;
+import arc.graphics.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.*;
+import mindustry.content.*;
+import mindustry.game.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustry.world.blocks.distribution.*;
+import mindustry.world.blocks.logic.*;
+import mindustry.world.blocks.logic.CanvasBlock.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.content.Blocks.*;
+
+public class picToMindustry{
+
+    static Pixmap oriImage, image, Cimage;
+    static Integer closest = null;
+    static Table tTable;
+    static Fi originFile;
+
+    static int[] palette;
+    static int canvasSize;
+
+    static float scale = 1f;
+    static float[] scaleList = {0.02f, 0.05f, 0.1f, 0.15f, 0.2f, 0.25f, 0.3f, 0.4f, 0.5f, 0.65f, 0.8f, 1f, 1.25f, 1.5f, 2f, 3f, 5f};
+    static int colorDisFun = 0;
+    static String[] disFunList = {"基础对比", "平方对比", "LAB"};
+
+    static{
+        CanvasBlock canva = (CanvasBlock)Blocks.canvas;
+        palette = canva.palette;
+        canvasSize = canva.canvasSize;
+    }
+
+    public static void show(){
+        ptDialog().show();
+    }
+
+    public static Dialog ptDialog(){
+        Dialog pt = new BaseDialog("arc-图片转换器");
+        pt.cont.table(t -> {
+            t.add("选择并导入图片，可将其转成画板、像素画或是逻辑画").padBottom(20f).row();
+            t.button("[cyan]选择图片[white](png)", () -> Vars.platform.showFileChooser(false, "png", file -> {
+                try{
+                    originFile = file;
+                    byte[] bytes = file.readBytes();
+                    oriImage = new Pixmap(bytes);
+                    rebuilt();
+                    if(oriImage.width > 500 || oriImage.height > 500)
+                        arcui.arcInfo("[orange]警告：图片可能过大，请尝试压缩图片", 5);
+                }catch(Throwable e){
+                    arcui.arcInfo("读取图片失败，请尝试更换图片\n" + e);
+                }
+            })).size(240, 50).padBottom(20f).row();
+            t.check("自动保存为蓝图", Core.settings.getBool("autoSavePTM"), ta -> Core.settings.put("autoSavePTM", ta));
+        }).padBottom(20f).row();
+        pt.cont.table(t -> {
+            t.add("缩放: \uE815 ");
+            Label zoom = t.add(String.valueOf(scale)).padRight(20f).get();
+            t.slider(0, scaleList.length - 1, 1, 11, s -> {
+                scale = scaleList[(int)s];
+                zoom.setText(Strings.fixed(scale, 2));
+                rebuilt();
+            }).width(200f);
+        }).padBottom(20f).visible(() -> oriImage != null).row();
+        pt.cont.table(t -> {
+            t.add("色调函数: ");
+            Label zoom = t.add(disFunList[0]).padRight(20f).get();
+            t.slider(0, disFunList.length - 1, 1, 0, s -> {
+                colorDisFun = (int)s;
+                zoom.setText(disFunList[colorDisFun]);
+            }).width(200f);
+        }).padBottom(20f).visible(() -> oriImage != null).row();
+        pt.cont.table(a -> tTable = a);
+        pt.cont.row();
+        pt.cont.button("逻辑画网站 " + Blocks.logicDisplay.emoji(), () -> {
+            String imageUrl = "https://buibiu.github.io/imageToMLogicPage/#/";
+            if(!Core.app.openURI(imageUrl)){
+                ui.showErrorMessage("打开失败，网址已复制到粘贴板\n请自行在阅览器打开");
+                Core.app.setClipboardText(imageUrl);
+            }
+        }).width(200f);
+        pt.addCloseButton();
+        return pt;
+    }
+
+    private static String formatNumber(int number){
+        return formatNumber(number, 1f);
+    }
+
+    private static String formatNumber(int number, float alert){
+        if(number >= 500 * alert) return "[red]" + number + "[]";
+        else if(number >= 200 * alert) return "[orange]" + number + "[]";
+        else return String.valueOf(number);
+    }
+
+    private static void rebuilt(){
+        image = Pixmaps.scale(oriImage, scale);
+        tTable.clear();
+        tTable.table(t -> {
+            t.add("路径").color(Pal.accent).padRight(25f).padBottom(10f);
+            t.button("\uE874", () -> Core.app.setClipboardText(originFile.absolutePath()));
+            t.add(originFile.absolutePath()).padBottom(10f).row();
+
+            t.add("名称").color(Pal.accent).padRight(25f).padBottom(10f);
+            t.button("\uE874", () -> Core.app.setClipboardText(originFile.name()));
+            t.add(originFile.name()).padBottom(10f).row();
+
+            t.add("原始大小").color(Pal.accent).padRight(25f);
+            t.add(formatNumber(oriImage.width) + "\uE815" + formatNumber(oriImage.height));
+        }).padBottom(20f).row();
+        tTable.table(t -> {
+            t.table(tt -> {
+                tt.button("画板 " + canvas.emoji(), Styles.cleart, () -> {
+                    Cimage = image.copy();
+                    create_rbg(palette);
+                    canvasGenerator();
+                }).size(100, 50);
+                tt.add("大小：" + formatNumber(image.width / canvasSize, 0.5f) + "\uE815" + formatNumber(image.height / canvasSize + 1, 0.5f));
+            });
+            t.row();
+            t.table(tt -> {
+                tt.button("画板++ " + canvas.emoji(), Styles.cleart, () -> {
+                    Cimage = image.copy();
+                    canvasPlus(Cimage);
+                    canvasGenerator();
+                }).size(100, 50);
+                tt.add("大小：" + formatNumber(image.width / canvasSize, 0.5f) + "\uE815" + formatNumber(image.height / canvasSize + 1, 0.5f));
+            }).row();
+            t.table(tt -> {
+                tt.button("像素画 " + Blocks.sorter.emoji(), Styles.cleart, () -> {
+                    Cimage = image.copy();
+                    sorterGenerator();
+                }).size(100, 50);
+                tt.add("大小：" + formatNumber(image.width) + "\uE815" + formatNumber(image.height));
+            }).row();
+        });
+    }
+
+    private static float diff_rbg(Integer a, Integer b){
+        int ar = a >> 24 & 0xFF,
+        ag = a >> 16 & 0xFF,
+        ab = a >> 8 & 0xFF;
+        // get in
+        int br = b >> 24 & 0xFF,
+        bg = b >> 16 & 0xFF,
+        bb = b >> 8 & 0xFF;
+        int dr = Math.abs(ar - br),
+        dg = Math.abs(ag - bg),
+        db = Math.abs(ab - bb);
+        switch(colorDisFun){
+            case 1 -> {
+                return dr * dr + dg * dg + db * db;
+            }
+            case 2 -> {
+                float Rmean = (ar + br) / 2f;
+                return (float)Math.sqrt((2 + Rmean / 256) * (dr * dr) + 4 * (dg * dg) + (2 + (255 - Rmean) / 256) * (db * db));
+            }
+            default -> {
+                return dr + dg + db;
+            }
+        }
+    }
+
+    private static void create_rbg(int[] colorBar){
+        for(int x = 0; x < image.width; x++){
+            for(int y = 0; y < image.height; y++){
+                Integer pixel = image.get(x, y);
+                float egg = 1000;
+                for(int other : colorBar){
+                    float h = diff_rbg(pixel, other);
+                    if(h < egg){
+                        closest = other;
+                        egg = h;
+                    }
+                }
+                Cimage.set(x, y, closest);
+            }
+        }
+    }
+
+    private static void canvasGenerator(){
+        int width = Cimage.width / canvasSize, height = Cimage.height / canvasSize + 1;
+        Seq<Schematic.Stile> tiles = new Seq<>();
+        for(int y = 0; y < height; y++){
+            for(int x = 0; x < width; x++){
+                // add canvas to the schematic
+                CanvasBuild build = (CanvasBuild)canvas.newBuilding();
+                // get max 12x12 region of the image
+                Pixmap region = Cimage.crop(x * canvasSize, (height - y - 1) * canvasSize, canvasSize, canvasSize);
+                // convert pixel data of the region
+                byte[] bytes = build.packPixmap(region);
+                Schematic.Stile stile = new Schematic.Stile(canvas, x * 2, y * 2, bytes, (byte)0);
+                tiles.add(stile);
+            }
+        }
+        StringMap tags = new StringMap();
+        tags.put("name", originFile.name());
+        Schematic schem = new Schematic(tiles, tags, width * 2, height * 2);
+        saveSchem(schem, canvas.emoji());
+    }
+
+    private static void saveSchem(Schematic schem, String l){
+        schem.labels.add(l);
+        if(Core.settings.getBool("autoSavePTM")){
+            Vars.schematics.add(schem);
+            arcui.arcInfo("已保存蓝图：" + originFile.name(), 10);
+        }
+        if(state.isGame()){
+            Vars.ui.schematics.hide();
+            Vars.control.input.useSchematic(schem);
+        }
+    }
+
+    private static void sorterGenerator(){
+        Seq<Schematic.Stile> tiles = new Seq<>();
+        for(int y = 0; y < image.height; y++){
+            for(int x = 0; x < image.width; x++){
+                if(image.get(x, y) == 0) continue;
+                Sorter.SorterBuild build = (Sorter.SorterBuild)sorter.newBuilding();
+                final float[] closestItem = {99999};
+                int finalX = x;
+                int finalY = y;
+                content.items().each(t -> {
+                    float dst = diff_rbg(t.color.rgba(), image.get(finalX, finalY));
+                    if(dst > closestItem[0]) return;
+                    build.sortItem = t;
+                    closestItem[0] = dst;
+                });
+                Schematic.Stile stile = new Schematic.Stile(sorter, x, image.height - y - 1, build.config(), (byte)0);
+                tiles.add(stile);
+            }
+        }
+        StringMap tags = new StringMap();
+        tags.put("name", originFile.name());
+        Schematic schem = new Schematic(tiles, tags, image.width, image.height);
+        saveSchem(schem, sorter.emoji());
+    }
+
+    private static int trans(RGB c1, RGB c2, int mul){
+        return c1.add(c2.cpy().mul(mul).mv(4)).rgba();
+    }
+
+    private static void canvasPlus(Pixmap image){
+        for(int y = 0; y < image.height; y++){
+            for(int x = 0; x < image.width; x++){
+                RGB pix = new RGB(image.get(x, y));
+                int nearest = findNearestColor(pix);
+                image.set(x, y, nearest);
+                pix.sub(new RGB(nearest));
+                if(x + 1 < image.width){
+                    image.set(x + 1, y, trans(new RGB(image.get(x + 1, y)), pix, 7));
+                }
+                if(y + 1 < image.height){
+                    if(x - 1 > 0){
+                        image.set(x - 1, y + 1, trans(new RGB(image.get(x - 1, y + 1)), pix, 3));
+                    }
+                    image.set(x, y + 1, trans(new RGB(image.get(x, y + 1)), pix, 5));
+                    if(x + 1 < image.width){
+                        image.set(x + 1, y + 1, trans(new RGB(image.get(x + 1, y + 1)), pix, 1));
+                    }
+                }
+            }
+        }
+    }
+
+    private static int findNearestColor(RGB color){
+        int max = 255 * 255 + 255 * 255 + 255 * 255 + 1;
+        int output = 0;
+        for(int i : palette){
+            int delta = color.cpy().sub(new RGB(i)).pow();
+            if(delta < max){
+                max = delta;
+                output = i;
+            }
+        }
+        return output;
+    }
+
+    private static class RGB{
+        int r, g, b;
+
+        RGB(int r, int g, int b){
+            this.r = r;
+            this.g = g;
+            this.b = b;
+        }
+
+        RGB(int rgba){
+            this(rgba >> 24 & 0xff, rgba >> 16 & 0xff, rgba >> 8 & 0xff);
+        }
+
+        public RGB sub(RGB c){
+            r = r - c.r;
+            g = g - c.g;
+            b = b - c.b;
+            return this;
+        }
+
+        public RGB add(RGB c){
+            r = Math.max(Math.min(c.r + r, 255), 0);
+            g = Math.max(Math.min(c.g + g, 255), 0);
+            b = Math.max(Math.min(c.b + b, 255), 0);
+            return this;
+        }
+
+        public RGB mul(int m){
+            r *= m;
+            g *= m;
+            b *= m;
+            return this;
+        }
+
+        public RGB mv(int s){
+            r >>= s;
+            g >>= s;
+            b >>= s;
+            return this;
+        }
+
+        public int pow(){
+            return r * r + g * g + b * b;
+        }
+
+        public int rgba(){
+            return r << 24 | g << 16 | b << 8 | 0xff;
+        }
+
+        public RGB cpy(){
+            return new RGB(r, g, b);
+        }
+    }
+}
diff --git a/core/src/mindustry/arcModule/ui/ARCUI.java b/core/src/mindustry/arcModule/ui/ARCUI.java
new file mode 100644
index 0000000000000000000000000000000000000000..5682631f7d739796faeafe9fc1fcee46bff52493
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/ARCUI.java
@@ -0,0 +1,46 @@
+package mindustry.arcModule.ui;
+
+import arc.*;
+import arc.graphics.*;
+import arc.math.*;
+import arc.scene.actions.*;
+import arc.scene.event.*;
+import arc.scene.ui.layout.*;
+import arc.util.*;
+import mindustry.arcModule.ui.dialogs.*;
+import mindustry.ui.*;
+
+import static mindustry.arcModule.toolpack.arcWaveSpawner.initArcWave;
+
+public class ARCUI{
+    public AchievementsDialog achievements;
+    //public MindustryWikiDialog mindustrywiki;
+    public mindustry.arcModule.ui.dialogs.MessageDialog MessageDialog;
+    public mindustry.arcModule.ui.dialogs.MusicDialog MusicDialog;
+
+
+    /** Display text in the upper of the screen, then fade out. */
+    public void arcInfo(String text, float duration){
+        Table t = new Table(Styles.black3);
+        t.touchable = Touchable.disabled;
+        t.margin(8f).add(text).style(Styles.outlineLabel).labelAlign(Align.center);
+        t.update(() -> t.setPosition(Core.graphics.getWidth() / 2f, Core.graphics.getHeight() / 4f, Align.center));
+        t.actions(Actions.fadeOut(duration, Interp.pow4In), Actions.remove());
+        t.pack();
+        t.act(0.1f);
+        Core.scene.add(t);
+    }
+
+    public void arcInfo(String text){
+        arcInfo(text, 3);
+    }
+
+    public void init(){
+        achievements = new AchievementsDialog();
+        //mindustrywiki = new MindustryWikiDialog();
+        MessageDialog = new MessageDialog();
+        MusicDialog = new MusicDialog();
+
+        initArcWave();
+    }
+}
diff --git a/core/src/mindustry/arcModule/ui/ArcWaveInfoDialog.java b/core/src/mindustry/arcModule/ui/ArcWaveInfoDialog.java
new file mode 100644
index 0000000000000000000000000000000000000000..89b3eb0a743a435d2406bd68251191deac4855a4
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/ArcWaveInfoDialog.java
@@ -0,0 +1,1115 @@
+package mindustry.arcModule.ui;
+
+import arc.*;
+import arc.func.*;
+import arc.math.*;
+import arc.math.geom.*;
+import arc.scene.event.*;
+import arc.scene.style.*;
+import arc.scene.ui.*;
+import arc.scene.ui.TextField.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.ai.types.*;
+import mindustry.arcModule.toolpack.*;
+import mindustry.content.*;
+import mindustry.core.*;
+import mindustry.editor.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.io.*;
+import mindustry.type.*;
+import mindustry.type.unit.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+
+import java.util.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.RFuncs.*;
+import static mindustry.arcModule.toolpack.arcWaveSpawner.*;
+import static mindustry.game.SpawnGroup.never;
+import static mindustry.ui.Styles.*;
+
+public class ArcWaveInfoDialog extends BaseDialog{
+    private int start = 0, displayed = 20, graphSpeed = 1, maxGraphSpeed = 16;
+    Seq<SpawnGroup> groups = new Seq<>();
+    private SpawnGroup expandedGroup;
+
+    private Table table, nTable, oTable, iTable, eTable, uTable;
+    private int search = -1;
+    private int maxVisible = 30;
+    private int filterHealth, filterBegin = -1, filterEnd = -1, filterAmount, filterAmountWave;
+    private boolean expandPane = false, filterHealthMode = false, filterStrict = false;
+    private UnitType lastType = UnitTypes.dagger;
+    private StatusEffect filterEffect = StatusEffects.none;
+    private Sort sort = Sort.begin;
+    private boolean reverseSort = false;
+    private float updateTimer, updatePeriod = 1f;
+    private TextField amountField = new TextField();
+    private boolean checkedSpawns;
+    private WaveGraph graph = new WaveGraph();
+
+    public int arcWaveIndex = 0;
+    private float handerSize = 40f;
+    /**
+     * 是否显示波次界面。如果否，则显示原图
+     */
+    private boolean waveInfo = true;
+    private float waveMulti = 1f;
+
+    private int winWave;
+
+    //波次生成
+    Float difficult = 1f;
+    Seq<UnitType> spawnUnit = content.units().copy().retainAll(unitType -> !(unitType instanceof MissileUnitType || unitType.controller instanceof BuilderAI || unitType.controller instanceof MinerAI || unitType.controller instanceof RepairAI));
+    Seq<UnitType> allowUnit = content.units().copy().retainAll(unitType -> !(unitType instanceof MissileUnitType));
+    boolean surplusUnit = true, ErekirUnit = true;
+    boolean showUnitSelect = true;
+    boolean flyingUnit = true, navalUnit = true, supportUnit = true;
+
+    public ArcWaveInfoDialog(){
+        super("ARC-波次编辑器");
+
+        shown(() -> {
+            checkedSpawns = false;
+            winWave = calWinWave();
+
+            setup();
+        });
+        hidden(() -> state.rules.spawns = groups);
+
+        addCloseListener();
+
+        onResize(this::setup);
+
+        addCloseButton();
+
+        buttons.button("@waves.edit", Icon.pencil, () -> {
+            BaseDialog dialog = new BaseDialog("@waves.edit");
+            dialog.addCloseButton();
+            dialog.setFillParent(false);
+            dialog.cont.table(Tex.button, t -> {
+                var style = Styles.flatt;
+                t.defaults().size(210f, 58f);
+
+                t.button("@waves.copy", Icon.copy, style, () -> {
+                    ui.showInfoFade("@waves.copied");
+                    Core.app.setClipboardText(maps.writeWaves(groups));
+                    dialog.hide();
+                }).disabled(b -> groups == null).marginLeft(12f).row();
+
+                t.button("@waves.load", Icon.download, style, () -> {
+                    try{
+                        groups = maps.readWaves(Core.app.getClipboardText());
+                        buildGroups();
+                    }catch(Exception e){
+                        e.printStackTrace();
+                        ui.showErrorMessage("@waves.invalid");
+                    }
+                    dialog.hide();
+                }).marginLeft(12f).disabled(b -> Core.app.getClipboardText() == null || Core.app.getClipboardText().isEmpty()).row();
+
+                t.button("@settings.reset", Icon.upload, style, () -> ui.showConfirm("@confirm", "@settings.clear.confirm", () -> {
+                    groups = JsonIO.copy(waves.get());
+                    buildGroups();
+                    dialog.hide();
+                })).marginLeft(12f).row();
+
+                t.button("@clear", Icon.cancel, style, () -> ui.showConfirm("@confirm", "@settings.clear.confirm", () -> {
+                    groups.clear();
+                    buildGroups();
+                    dialog.hide();
+                })).marginLeft(12f);
+            });
+
+            dialog.show();
+        }).size(250f, 64f);
+
+        buttons.defaults().width(60f);
+
+        buttons.button("切换显示模式", () -> {
+            waveInfo = !waveInfo;
+            waveMulti = 1;
+            setup();
+        }).size(250f, 64f);
+
+        if(true){
+            buttons.button("随机", Icon.refresh, this::arcSpawner).width(200f);
+        }
+    }
+
+    void view(int amount){
+        updateTimer += Time.delta;
+        if(updateTimer >= updatePeriod){
+            displayed += amount;
+            if(displayed < 5) displayed = 5;
+            updateTimer = 0f;
+            updateWaves();
+        }
+    }
+
+    void shift(int amount){
+        updateTimer += Time.delta;
+        if(updateTimer >= updatePeriod){
+            start += amount;
+            if(start < 0) start = 0;
+            updateTimer = 0f;
+            updateWaves();
+        }
+    }
+
+    void setup(){
+        groups = JsonIO.copy(state.rules.spawns.isEmpty() ? waves.get() : state.rules.spawns);
+
+        cont.clear();
+        cont.stack(new Table(Tex.clear, main -> {
+            main.table(s -> {
+                s.image(Icon.zoom).padRight(8);
+                s.field(search < 0 ? "" : search + "", TextFieldFilter.digitsOnly, text -> {
+                    search = !text.isEmpty() ? Math.max(Strings.parseInt(text) - 1, -1) : -1;
+                    start = Math.max(search - (displayed / 2) - (displayed % 2), 0);
+                    buildGroups();
+                }).growX().maxTextLength(8).get().setMessageText("@waves.search");
+                s.button(Icon.filter, Styles.emptyi, this::showFilter).size(46f).tooltip("@waves.filter");
+            }).fillX().pad(6f).row();
+            main.pane(t -> table = t).growX().growY().padRight(8f).scrollX(false);
+            main.row();
+            main.table(f -> {
+                f.button("@add", () -> {
+                    if(groups == null) groups = new Seq<>();
+                    SpawnGroup newGroup = new SpawnGroup(lastType);
+                    groups.add(newGroup);
+                    expandedGroup = newGroup;
+                    showUpdate(newGroup, false);
+                    buildGroups();
+                    clearFilter();
+                }).growX().height(70f);
+                f.button(Icon.filter, () -> {
+                    BaseDialog dialog = new BaseDialog("@waves.sort");
+                    dialog.setFillParent(false);
+                    dialog.cont.table(Tex.button, t -> {
+                        for(Sort s : Sort.all){
+                            t.button("@waves.sort." + s, Styles.cleart, () -> {
+                                sort = s;
+                                dialog.hide();
+                                buildGroups();
+                            }).size(150f, 60f).checked(s == sort);
+                        }
+                    }).row();
+                    dialog.cont.check("@waves.sort.reverse", b -> {
+                        reverseSort = b;
+                        buildGroups();
+                    }).padTop(4).checked(reverseSort).padBottom(8f);
+                    dialog.addCloseButton();
+                    dialog.show();
+                    buildGroups();
+                }).size(64f, 70f).padLeft(4f);
+            }).fillX();
+        }), new Label("@waves.none"){{
+            visible(() -> groups.isEmpty());
+            this.touchable = Touchable.disabled;
+            setWrap(true);
+            setAlignment(Align.center, Align.center);
+        }}).width(390f).growY();
+        cont.table(tb -> {
+            if(waveInfo){
+                tb.table(t -> {
+                    t.table(buttons -> {
+                        buttons.clear();
+                        buttons.button("<<", cleart, () -> {
+                            arcWaveIndex -= 10;
+                            if(arcWaveIndex < 0) arcWaveIndex = 0;
+                            setup();
+                        }).size(handerSize);
+
+                        buttons.button("<", cleart, () -> {
+                            arcWaveIndex -= 1;
+                            if(arcWaveIndex < 0) arcWaveIndex = 1;
+                            setup();
+                        }).size(handerSize);
+
+                        TextField sField = buttons.field((arcWaveIndex + 1) + "", text -> {
+                            if(Strings.canParseInt(text)){
+                                arcWaveIndex = Integer.parseInt(text) - 1;
+                                setup();
+                            }
+                        }).get();
+
+                        buttons.button(">", cleart, () -> {
+                            arcWaveIndex += 1;
+                            setup();
+                        }).size(handerSize);
+
+                        buttons.button(">>", cleart, () -> {
+                            arcWaveIndex += 10;
+                            setup();
+                        }).size(handerSize);
+
+                        buttons.button("×", cleart, () -> {
+                            arcWaveIndex = 0;
+                            setup();
+                        }).size(handerSize);
+
+                        buttons.slider(0, winWave, 1, res -> {
+                            arcWaveIndex = (int)res;
+                            sField.setText((arcWaveIndex + 1) + "");
+                        });
+
+                    }).left().row();
+                    t.pane(waveInfo -> {
+                        waveInfo.clear();
+                        waveInfo.table(wi -> {
+                            int curInfoWave = arcWaveIndex;
+                            for(SpawnGroup group : state.rules.spawns){
+                                int amount = group.getSpawned(curInfoWave);
+                                if(amount > 0){
+                                    StringBuilder groupInfo = new StringBuilder();
+                                    groupInfo.append(group.type.emoji()).append("\n");
+                                    groupInfo.append(amount).append("\n");
+                                    if(group.getShield(curInfoWave) > 0f)
+                                        groupInfo.append(UI.formatAmount((long)group.getShield(curInfoWave))).append("\n");
+                                    if(group.effect != null && group.effect != StatusEffects.none)
+                                        groupInfo.append(group.effect.emoji()).append("\n");
+                                    wi.button(groupInfo.toString(), cleart, () -> unitSettingDialog(group)).height(130f).width(50f);
+                                }
+                            }
+                        });
+                    }).scrollY(false).left();
+                }).growX();
+                tb.row();
+                tb.add(graph = new WaveGraph()).grow();
+                tb.row();
+                tb.table(tbt -> {
+                    tbt.button("<", () -> {
+                    }).update(t -> {
+                        if(t.getClickListener().isPressed()){
+                            shift(-graphSpeed);
+                        }
+                    }).width(150f);
+                    tbt.button(">", () -> {
+                    }).update(t -> {
+                        if(t.getClickListener().isPressed()){
+                            shift(graphSpeed);
+                        }
+                    }).width(150f);
+
+                    tbt.button("-", () -> {
+                    }).update(t -> {
+                        if(t.getClickListener().isPressed()){
+                            view(-graphSpeed);
+                        }
+                    }).width(150f);
+                    tbt.button("+", () -> {
+                    }).update(t -> {
+                        if(t.getClickListener().isPressed()){
+                            view(graphSpeed);
+                        }
+                    }).width(150f);
+
+                    tbt.button("x" + graphSpeed, () -> {
+                        graphSpeed *= 2;
+                        if(graphSpeed > maxGraphSpeed) graphSpeed = 1;
+                    }).update(b -> b.setText("x" + graphSpeed)).width(150f);
+                }).growX();
+            }else{
+                tb.pane(p -> {
+                    initArcWave((int)(winWave * waveMulti + 1));
+                    p.table(Tex.button, t -> {
+                        p.margin(0).defaults().pad(5).growX();
+                        t.add("\uE86D 为单位数量；\uE813 为单位血+盾；\uE810 为计算buff的血+盾；\uE86E 为预估DPS。在游戏中时会考虑地图出怪点数目").color(Pal.accent);
+                    }).scrollX(false).growX().row();
+                    for(int wave = 0; wave < winWave * waveMulti; wave++){
+                        arcWaveSpawner.waveInfo thisWave = arcWave.get(wave);
+                        thisWave.specLoc(-1, group -> true);
+                        int finalWave = wave;
+                        p.table(Tex.button, t -> {
+                            t.table(tt -> {
+                                tt.add("第[accent]" + (finalWave + 1) + "[]波");
+                                tt.row();
+                                float firstWaveTime = state.rules.initialWaveSpacing <= 0 ? (2 * state.rules.waveSpacing) : state.rules.initialWaveSpacing;
+                                int thisTime = (int)(finalWave * state.rules.waveSpacing + firstWaveTime);
+                                tt.add(fixedTime(thisTime, false)).row();
+                                Label waveTime = tt.add("").get();
+                                tt.update(() -> {
+                                    if(!state.isGame()) waveTime.setText("");
+                                    else{
+                                        int deltaTime = thisTime - (int)(state.wave <= 1 ? (firstWaveTime - state.wavetime) : (firstWaveTime + state.rules.waveSpacing * (state.wave - 1) - state.wavetime));
+                                        waveTime.setText(arcColorTime(deltaTime, false));
+                                    }
+                                });
+                            }).width(120f).left();
+                            if(thisWave.amount == 0) t.add("该波次没有敌人");
+                            else{
+                                t.add(thisWave.proTable(true));
+                                t.pane(thisWave.unitTable(-1, group -> true, mobile ? 8 : 15)).scrollX(true).scrollY(false).growX();
+                            }
+                        }).growX().row();
+                        p.margin(0).defaults().pad(5).growX();
+                    }
+                }).scrollX(false).growX().row();
+                tb.table(tbb -> {
+                    tbb.button("刷新波次显示", this::setup).width(200f);
+                    TextField sField = tbb.field(winWave * (int)waveMulti + "", text -> waveMulti = (Float.parseFloat(text) / winWave)).valid(Strings::canParsePositiveFloat).width(200f).get();
+                    tbb.slider(0.25f, 10f, 0.25f, 1f, t -> {
+                        waveMulti = t;
+                        sField.setText(winWave * (int)waveMulti + "");
+                    }).width(300f);
+                });
+            }
+        }).grow();
+
+
+        buildGroups();
+    }
+
+    void buildGroups(){
+        table.clear();
+        table.top();
+        table.margin(10f);
+
+        if(groups != null){
+            groups.sort(sort.sort);
+            if(reverseSort) groups.reverse();
+
+            for(SpawnGroup group : groups){
+                if((search >= 0 && group.getSpawned(search) <= 0)
+                || (filterHealth != 0 && !(filterHealthMode ? group.type.health * (search >= 0 ? group.getSpawned(search) : 1) > filterHealth : group.type.health * (search >= 0 ? group.getSpawned(search) : 1) < filterHealth))
+                || (filterBegin >= 0 && !(filterStrict ? group.begin == filterBegin : group.begin - 2 <= filterBegin && group.begin + 2 >= filterBegin))
+                || (filterEnd >= 0 && !(filterStrict ? group.end == filterEnd : group.end - 2 <= filterEnd && group.end + 2 >= filterEnd))
+                || (filterAmount != 0 && !(filterStrict ? group.getSpawned(filterAmountWave) == filterAmount : filterAmount - 5 <= group.getSpawned(filterAmountWave) && filterAmount + 5 >= group.getSpawned(filterAmountWave)))
+                || (filterEffect != StatusEffects.none && group.effect != filterEffect)) continue;
+
+                table.table(Tex.button, t -> {
+                    t.margin(0).defaults().pad(3).padLeft(5f).growX().left();
+                    t.button(b -> {
+                        b.left();
+                        b.image(group.type.uiIcon).size(32f).padRight(3).scaling(Scaling.fit);
+                        b.add(group.type.typeColor() + group.type.localizedName);
+                        if(group.effect != null && group.effect != StatusEffects.none)
+                            b.image(group.effect.uiIcon).size(20f).padRight(3).scaling(Scaling.fit);
+                        if(group.items != null && group.items.amount > 0)
+                            b.image(group.items.item.uiIcon).size(20f).padRight(3).scaling(Scaling.fit);
+                        if(group.payloads != null && group.payloads.size > 0)
+                            b.image(Icon.uploadSmall).size(20f).padRight(3).scaling(Scaling.fit);
+
+                        b.add().growX();
+
+                        b.label(() -> {
+                            StringBuilder builder = new StringBuilder();
+                            builder.append("[lightgray]").append(group.begin + 1);
+                            if(group.begin == group.end) return builder.toString();
+                            if(group.end > 999999) builder.append("+");
+                            else builder.append("~").append(group.end + 1);
+                            if(group.spacing > 1) builder.append("[white]|[lightgray]").append(group.spacing);
+                            return builder.append("  ").toString();
+                        }).minWidth(45f).labelAlign(Align.left).left();
+
+                        b.button(Icon.settingsSmall, Styles.emptyi, () -> unitSettingDialog(group)).pad(-6).size(46f);
+                        b.button(Icon.unitsSmall, Styles.emptyi, () -> showUpdate(group, false)).pad(-6).size(46f);
+                        b.button(Icon.cancel, Styles.emptyi, () -> {
+                            if(expandedGroup == group) expandedGroup = null;
+                            groups.remove(group);
+                            table.getCell(t).pad(0f);
+                            t.remove();
+                            buildGroups();
+                        }).pad(-6).size(46f).padRight(-12f);
+                    }, () -> {
+                        expandedGroup = expandedGroup == group ? null : group;
+                        buildGroups();
+                    }).height(46f).pad(-6f).padBottom(0f).row();
+
+                    if(expandedGroup == group){
+                        t.table(spawns -> {
+                            spawns.field("" + (group.begin + 1), TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.begin = Strings.parseInt(text) - 1;
+                                    updateWaves();
+                                }
+                            }).width(100f);
+                            spawns.add("@waves.to").padLeft(4).padRight(4);
+                            spawns.field(group.end == never ? "" : (group.end + 1) + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.end = Strings.parseInt(text) - 1;
+                                    updateWaves();
+                                }else if(text.isEmpty()){
+                                    group.end = never;
+                                    updateWaves();
+                                }
+                            }).width(100f).get().setMessageText("∞");
+                        }).row();
+
+                        t.table(p -> {
+                            p.add("@waves.every").padRight(4);
+                            p.field(group.spacing + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text) && Strings.parseInt(text) > 0){
+                                    group.spacing = Strings.parseInt(text);
+                                    updateWaves();
+                                }
+                            }).width(100f);
+                            p.add("@waves.waves").padLeft(4);
+                        }).row();
+
+                        t.table(a -> {
+                            a.field(group.unitAmount + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.unitAmount = Strings.parseInt(text);
+                                    updateWaves();
+                                }
+                            }).width(80f);
+
+                            a.add(" + ");
+                            a.field(Strings.fixed(Math.max((Mathf.zero(group.unitScaling) ? 0 : 1f / group.unitScaling), 0), 2), TextFieldFilter.floatsOnly, text -> {
+                                if(Strings.canParsePositiveFloat(text)){
+                                    group.unitScaling = 1f / Strings.parseFloat(text);
+                                    updateWaves();
+                                }
+                            }).width(80f);
+                            a.add("@waves.perspawn").padLeft(4);
+                        }).row();
+
+                        t.table(a -> {
+                            a.field(group.max + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.max = Strings.parseInt(text);
+                                    updateWaves();
+                                }
+                            }).width(80f);
+
+                            a.add("@waves.max").padLeft(5);
+                        }).row();
+
+                        t.table(a -> {
+                            a.field((int)group.shields + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.shields = Strings.parseInt(text);
+                                    updateWaves();
+                                }
+                            }).width(80f);
+
+                            a.add(" + ");
+                            a.field((int)group.shieldScaling + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.shieldScaling = Strings.parseInt(text);
+                                    updateWaves();
+                                }
+                            }).width(80f);
+                            a.add("@waves.shields").padLeft(4);
+                        }).row();
+
+                        t.table(a -> {
+                            a.add("@waves.spawn").padRight(8);
+
+                            a.button("", () -> {
+                                if(!checkedSpawns){
+                                    //recalculate waves when changed
+                                    spawner.reset();
+                                    checkedSpawns = true;
+                                }
+
+                                BaseDialog dialog = new BaseDialog("@waves.spawn.select");
+                                dialog.cont.pane(p -> {
+                                    p.background(Tex.button).margin(10f);
+                                    int i = 0;
+                                    int cols = 4;
+                                    int max = 20;
+
+                                    if(spawner.getSpawns().size >= max){
+                                        p.add("[lightgray](first " + max + ")").colspan(cols).padBottom(4).row();
+                                    }
+
+                                    for(var spawn : spawner.getSpawns()){
+                                        p.button(spawn.x + ", " + spawn.y, Styles.flatTogglet, () -> {
+                                            group.spawn = Point2.pack(spawn.x, spawn.y);
+                                            dialog.hide();
+                                        }).size(110f, 45f).checked(spawn.pos() == group.spawn);
+
+                                        if(++i % cols == 0){
+                                            p.row();
+                                        }
+
+                                        //only display first 20 spawns, you don't need to see more.
+                                        if(i >= 20){
+                                            break;
+                                        }
+                                    }
+
+                                    p.button("@waves.spawn.all", Styles.flatTogglet, () -> {
+                                        group.spawn = -1;
+                                        dialog.hide();
+                                    }).size(110f, 45f).checked(-1 == group.spawn);
+
+                                    if(spawner.getSpawns().isEmpty()){
+                                        p.add("@waves.spawn.none");
+                                    }
+                                });
+                                dialog.setFillParent(false);
+                                dialog.addCloseButton();
+                                dialog.show();
+                            }).width(160f).height(36f).get().getLabel().setText(() -> group.spawn == -1 ? "@waves.spawn.all" : Point2.x(group.spawn) + ", " + Point2.y(group.spawn));
+
+                        }).padBottom(8f).row();
+                    }
+                }).width(350f).pad(8);
+
+                table.row();
+            }
+        }else{
+            table.add("@editor.default");
+        }
+
+        updateWaves();
+    }
+
+    void showUpdate(SpawnGroup group, boolean payloads){
+        BaseDialog dialog = new BaseDialog("");
+        dialog.setFillParent(true);
+        if(payloads && group.payloads == null) group.payloads = Seq.with();
+        if(payloads) dialog.cont.table(e -> {
+            uTable = e;
+            updateIcons(group);
+        }).padBottom(6f).row();
+        dialog.cont.pane(p -> {
+            int i = 0;
+            for(UnitType type : content.units()){
+                if(type.internal) continue;
+                if(type.isHidden() && !(Core.settings.getBool("developmode"))) continue;
+                p.button(t -> {
+                    t.left();
+                    t.image(type.uiIcon).size(8 * 4).scaling(Scaling.fit).padRight(2f);
+                    t.add(type.localizedName);
+                }, () -> {
+                    if(payloads){
+                        group.payloads.add(type);
+                        updateIcons(group);
+                    }else{
+                        group.type = lastType = type;
+                        updateIcons(group);
+                        dialog.hide();
+                    }
+                    if(group.payloads != null && group.type.payloadCapacity <= 8) group.payloads.clear();
+                    if(group.items != null)
+                        group.items.amount = Mathf.clamp(group.items.amount, 0, group.type.itemCapacity);
+                    buildGroups();
+                }).pad(2).margin(12f).fillX();
+                if(++i % 5 == 0) p.row();
+            }
+        });
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    void showEffect(SpawnGroup group){
+        BaseDialog dialog = new BaseDialog("");
+        dialog.setFillParent(true);
+        dialog.cont.pane(p -> {
+            int i = 0;
+            for(StatusEffect effect : content.statusEffects()){
+                if(effect != StatusEffects.none && effect.reactive) continue;
+
+                p.button(t -> {
+                    t.left();
+                    if(effect.uiIcon != null && effect != StatusEffects.none){
+                        t.image(effect.uiIcon).size(8 * 4).scaling(Scaling.fit).padRight(2f);
+                    }else{
+                        t.image(Icon.none).size(8 * 4).scaling(Scaling.fit).padRight(2f);
+                    }
+
+                    if(effect != StatusEffects.none){
+                        t.add(effect.localizedName);
+                    }else{
+                        t.add("@settings.resetKey");
+                    }
+                }, () -> {
+                    if(group == null){
+                        filterEffect = effect;
+                    }else{
+                        group.effect = effect;
+                    }
+                    updateIcons(group);
+                    dialog.hide();
+                    buildGroups();
+                }).pad(2).margin(12f).fillX();
+                if(++i % 3 == 0) p.row();
+            }
+        });
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    void showItems(SpawnGroup group){
+        BaseDialog dialog = new BaseDialog("");
+        dialog.setFillParent(true);
+        dialog.cont.table(items -> {
+            items.add(Core.bundle.get("filter.option.amount") + ":");
+            amountField = items.field(group.items != null ? group.items.amount + "" : "", TextFieldFilter.digitsOnly, text -> {
+                if(Strings.canParsePositiveInt(text) && group.items != null){
+                    group.items.amount = Strings.parseInt(text) <= 0 ? group.type.itemCapacity : Mathf.clamp(Strings.parseInt(text), 0, group.type.itemCapacity);
+                }
+            }).width(120f).pad(2).margin(12f).maxTextLength((group.type.itemCapacity + "").length() + 1).get();
+            amountField.setMessageText(group.type.itemCapacity + "");
+        }).padBottom(6f).row();
+        dialog.cont.pane(p -> {
+            int i = 1;
+            p.defaults().pad(2).margin(12f).minWidth(200f).fillX();
+            p.button(icon -> {
+                icon.left();
+                icon.image(Icon.none).size(8 * 4).scaling(Scaling.fit).padRight(2f);
+                icon.add("@settings.resetKey");
+            }, () -> {
+                group.items = null;
+                updateIcons(group);
+                dialog.hide();
+                buildGroups();
+            });
+            for(Item item : content.items()){
+                p.button(t -> {
+                    t.left();
+                    if(item.uiIcon != null) t.image(item.uiIcon).size(8 * 4).scaling(Scaling.fit).padRight(2f);
+                    t.add(item.localizedName);
+                }, () -> {
+                    group.items = new ItemStack(item, Strings.parseInt(amountField.getText()) <= 0 ? group.type.itemCapacity : Mathf.clamp(Strings.parseInt(amountField.getText()), 0, group.type.itemCapacity));
+                    updateIcons(group);
+                    dialog.hide();
+                    buildGroups();
+                });
+                if(++i % 3 == 0) p.row();
+            }
+        });
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    void showFilter(){
+        BaseDialog dialog = new BaseDialog("@waves.filter");
+        dialog.setFillParent(false);
+        dialog.cont.defaults().size(210f, 64f);
+        dialog.cont.add(Core.bundle.get("waves.sort.health") + ":");
+        dialog.cont.table(filter -> {
+            filter.button(">", Styles.cleart, () -> {
+                filterHealthMode = !filterHealthMode;
+                buildGroups();
+            }).update(b -> b.setText(filterHealthMode ? ">" : "<")).size(40f).padRight(4f);
+            filter.defaults().width(170f);
+            numField("", filter, f -> filterHealth = f, () -> filterHealth, 15);
+        }).row();
+
+        dialog.cont.add("@waves.filter.begin");
+        dialog.cont.table(filter -> {
+            filter.defaults().maxWidth(120f);
+            numField("", filter, f -> filterBegin = f - 1, () -> filterBegin + 1, 8);
+            numField("@waves.to", filter, f -> filterEnd = f - 1, () -> filterEnd + 1, 8);
+        }).row();
+
+        dialog.cont.add(Core.bundle.get("waves.filter.amount") + ":");
+        dialog.cont.table(filter -> {
+            filter.defaults().maxWidth(120f);
+            numField("", filter, f -> filterAmount = f, () -> filterAmount, 12);
+            numField("@waves.filter.onwave", filter, f -> filterAmountWave = f, () -> filterAmountWave, 8);
+        }).row();
+
+        dialog.cont.table(t -> {
+            eTable = t;
+            updateIcons(null);
+        }).row();
+        dialog.row();
+        dialog.check("@waves.filter.strict", b -> {
+            filterStrict = b;
+            buildGroups();
+        }).checked(filterStrict).padBottom(10f).row();
+
+        dialog.table(p -> {
+            p.defaults().size(210f, 64f).padLeft(4f).padRight(4f);
+            p.button("@back", Icon.left, dialog::hide);
+            p.button("@clear", Icon.refresh, () -> {
+                clearFilter();
+                buildGroups();
+                dialog.hide();
+            });
+        });
+        dialog.addCloseListener();
+        dialog.show();
+    }
+
+    void unitSettingDialog(SpawnGroup group){
+        BaseDialog dialog = new BaseDialog("设置出怪组");
+        dialog.setFillParent(false);
+        dialog.cont.table(Tex.button, a -> nTable = a).row();
+        dialog.cont.table(Tex.button, a -> oTable = a).row();
+        dialog.cont.table(Tex.button, a -> iTable = a).row();
+        dialog.cont.table(c -> {
+            c.defaults().size(210f, 64f).pad(2f);
+            c.button("@waves.duplicate", Icon.copy, () -> {
+                SpawnGroup newGroup = group.copy();
+                groups.add(newGroup);
+                expandedGroup = newGroup;
+                buildGroups();
+                dialog.hide();
+            });
+            c.button("@settings.resetKey", Icon.refresh, () -> ui.showConfirm("@confirm", "@settings.clear.confirm", () -> {
+                group.effect = StatusEffects.none;
+                group.payloads = Seq.with();
+                group.items = null;
+                buildGroups();
+                dialog.hide();
+            }));
+        });
+        buildGroups();
+        updateIcons(group);
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    void updateIcons(SpawnGroup group){
+        if(nTable != null && group != null){
+            nTable.clear();
+            nTable.defaults().size(400f, 50f).pad(2f);
+            nTable.table(t -> {
+                t.image(group.type.uiIcon).size(32f).padRight(5).scaling(Scaling.fit).get();
+                //if(group.effect != null && group.effect != StatusEffects.none) b.image(group.effect.uiIcon).size(20f).padRight(3).scaling(Scaling.fit);
+                t.add(group.type.localizedName).padRight(20).color(Pal.accent);
+                t.button(Icon.units, Styles.emptyi, () -> showUpdate(group, false)).pad(-6).size(50f);
+            }).growX().row();
+        }
+
+        if(oTable != null && group != null){
+            oTable.clear();
+            oTable.defaults().size(400f, 250f).pad(2f);
+            oTable.table(t -> {
+                t.table(spawns -> {
+                    spawns.field("" + (group.begin + 1), TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.begin = Strings.parseInt(text) - 1;
+                            updateWaves();
+                        }
+                    }).width(150f);
+                    spawns.add("@waves.to").padLeft(4).padRight(4);
+                    spawns.field(group.end == never ? "" : (group.end + 1) + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.end = Strings.parseInt(text) - 1;
+                            updateWaves();
+                        }else if(text.isEmpty()){
+                            group.end = never;
+                            updateWaves();
+                        }
+                    }).width(150f).get().setMessageText("∞");
+                }).row();
+
+                t.table(p -> {
+                    p.add("@waves.every").padRight(4);
+                    p.field(group.spacing + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text) && Strings.parseInt(text) > 0){
+                            group.spacing = Strings.parseInt(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+                    p.add("@waves.waves").padLeft(4);
+                }).row();
+
+                t.table(a -> {
+                    a.field(group.unitAmount + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.unitAmount = Strings.parseInt(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+
+                    a.add(" + ");
+                    a.field(Strings.fixed(Math.max((Mathf.zero(group.unitScaling) ? 0 : 1f / group.unitScaling), 0), 2), TextFieldFilter.floatsOnly, text -> {
+                        if(Strings.canParsePositiveFloat(text)){
+                            group.unitScaling = 1f / Strings.parseFloat(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+                    a.add("@waves.perspawn").padLeft(4);
+                }).row();
+
+                t.table(a -> {
+                    a.field(group.max + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.max = Strings.parseInt(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+
+                    a.add("@waves.max").padLeft(5);
+                }).row();
+
+                t.table(a -> {
+                    a.field((int)group.shields + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.shields = Strings.parseInt(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+
+                    a.add(" + ");
+                    a.field((int)group.shieldScaling + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.shieldScaling = Strings.parseInt(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+                    a.add("@waves.shields").padLeft(4);
+                }).row();
+
+                t.table(a -> {
+                    a.add("@waves.spawn").padRight(8);
+
+                    a.button("", () -> {
+                        if(!checkedSpawns){
+                            //recalculate waves when changed
+                            spawner.reset();
+                            checkedSpawns = true;
+                        }
+
+                        BaseDialog dialog = new BaseDialog("@waves.spawn.select");
+                        dialog.cont.pane(p -> {
+                            p.background(Tex.button).margin(10f);
+                            int i = 0;
+                            int cols = 4;
+                            int max = 20;
+
+                            if(spawner.getSpawns().size >= max){
+                                p.add("[lightgray](first " + max + ")").colspan(cols).padBottom(4).row();
+                            }
+
+                            for(var spawn : spawner.getSpawns()){
+                                p.button(spawn.x + ", " + spawn.y, Styles.flatTogglet, () -> {
+                                    group.spawn = Point2.pack(spawn.x, spawn.y);
+                                    dialog.hide();
+                                }).size(110f, 45f).checked(spawn.pos() == group.spawn);
+
+                                if(++i % cols == 0){
+                                    p.row();
+                                }
+
+                                //only display first 20 spawns, you don't need to see more.
+                                if(i >= 20){
+                                    break;
+                                }
+                            }
+
+                            p.button("@waves.spawn.all", Styles.flatTogglet, () -> {
+                                group.spawn = -1;
+                                dialog.hide();
+                            }).size(110f, 45f).checked(-1 == group.spawn);
+
+                            if(spawner.getSpawns().isEmpty()){
+                                p.add("@waves.spawn.none");
+                            }
+                        });
+                        dialog.setFillParent(false);
+                        dialog.addCloseButton();
+                        dialog.show();
+                    }).width(160f).height(36f).get().getLabel().setText(() -> group.spawn == -1 ? "@waves.spawn.all" : Point2.x(group.spawn) + ", " + Point2.y(group.spawn));
+
+                }).padBottom(8f).row();
+
+
+            }).growX().row();
+        }
+
+        if(iTable != null && group != null){
+            iTable.clear();
+            iTable.defaults().size(200f, 60f).pad(2f);
+            iTable.button(icon -> {
+                icon.add("状态");
+                if(group.effect != null && group.effect != StatusEffects.none){
+                    icon.image(group.effect.uiIcon).padLeft(6f);
+                }else{
+                    icon.image(Icon.logic).padLeft(6f);
+                }
+            }, Styles.cleart, () -> showEffect(group));
+            if(group.type.payloadCapacity > 0) iTable.button("添加载荷", Styles.cleart, () -> showUpdate(group, true));
+            iTable.button(icon -> {
+                icon.add("物品");
+                if(group.items != null){
+                    icon.image(group.items.item.uiIcon).padLeft(6f);
+                    icon.add("" + group.items.amount).padLeft(6f);
+                }else{
+                    icon.image(Icon.effect).padLeft(6f);
+                }
+
+            }, Styles.cleart, () -> showItems(group));
+        }
+
+        if(eTable != null){
+            eTable.clear();
+            eTable.add(Core.bundle.get("waves.filter.effect") + ":");
+            eTable.button(filterEffect != null && filterEffect != StatusEffects.none ?
+            new TextureRegionDrawable(filterEffect.uiIcon) :
+            Icon.logic, () -> showEffect(null)).padLeft(30f).size(60f);
+        }
+
+        if(uTable != null && group != null && group.payloads != null){
+            uTable.clear();
+            uTable.left();
+            uTable.defaults().pad(3);
+            uTable.table(units -> {
+                int i = 0;
+                for(UnitType payl : group.payloads){
+                    if(i < maxVisible || expandPane) units.table(Tex.button, s -> {
+                        s.image(payl.uiIcon).size(45f);
+                        s.button(Icon.cancelSmall, Styles.emptyi, () -> {
+                            group.payloads.remove(payl);
+                            updateIcons(group);
+                            buildGroups();
+                        }).size(20f).padRight(-9f).padLeft(-6f);
+                    }).pad(2).margin(12f).fillX();
+                    if(++i % 10 == 0) units.row();
+                }
+            });
+            uTable.table(b -> {
+                b.defaults().pad(2);
+                if(group.payloads.size > 1) b.button(Icon.cancel, () -> {
+                    group.payloads.clear();
+                    updateIcons(group);
+                    buildGroups();
+                }).tooltip("@clear").row();
+                if(group.payloads.size > maxVisible) b.button(expandPane ? Icon.eyeSmall : Icon.eyeOffSmall, () -> {
+                    expandPane = !expandPane;
+                    updateIcons(group);
+                }).size(45f).tooltip(expandPane ? "@server.shown" : "@server.hidden");
+            }).padLeft(6f);
+        }
+    }
+
+    void numField(String text, Table t, Intc cons, Intp prov, int maxLength){
+        if(!text.isEmpty()) t.add(text);
+        t.field(prov.get() + "", TextFieldFilter.digitsOnly, input -> {
+            if(Strings.canParsePositiveInt(input)){
+                cons.get(!input.isEmpty() ? Strings.parseInt(input) : 0);
+                buildGroups();
+            }
+        }).maxTextLength(maxLength);
+    }
+
+    void clearFilter(){
+        filterHealth = filterAmount = filterAmountWave = 0;
+        filterStrict = filterHealthMode = false;
+        filterBegin = filterEnd = -1;
+        filterEffect = StatusEffects.none;
+    }
+
+    enum Sort{
+        begin(Structs.comps(Structs.comparingFloat(g -> g.begin), Structs.comparingFloat(g -> g.type.id))),
+        health(Structs.comps(Structs.comparingFloat(g -> g.type.health), Structs.comparingFloat(g -> g.begin))),
+        type(Structs.comps(Structs.comparingFloat(g -> g.type.id), Structs.comparingFloat(g -> g.begin)));
+
+        static final Sort[] all = values();
+
+        final Comparator<SpawnGroup> sort;
+
+        Sort(Comparator<SpawnGroup> sort){
+            this.sort = sort;
+        }
+    }
+
+    void updateWaves(){
+        graph.groups = groups;
+        graph.from = start;
+        graph.to = start + displayed;
+        graph.rebuild();
+    }
+
+    void arcSpawner(){
+        BaseDialog dialog = new BaseDialog("ARC-随机生成器");
+
+        Table table = dialog.cont;
+        Runnable[] rebuild = {null};
+        rebuild[0] = () -> {
+
+            table.clear();
+            table.table(c -> {
+                c.table(ct -> {
+                    ct.add("难度：").width(100f);
+                    ct.field(difficult + "", text -> difficult = Float.parseFloat(text)).valid(Strings::canParsePositiveFloat).width(200f);
+                }).width(300f);
+                c.row();
+                c.button("单位设置", showUnitSelect ? Icon.upOpen : Icon.downOpen, Styles.togglet, () -> {
+                    showUnitSelect = !showUnitSelect;
+                    rebuild[0].run();
+                }).fillX().minWidth(400f).row();
+                c.row();
+                if(showUnitSelect){
+                    c.table(list -> {
+                        for(UnitType unit : content.units()){
+                            if(unit.internal) continue;
+                            list.button(unit.emoji(), flatToggleMenut, () -> {
+                                if(spawnUnit.contains(unit)) spawnUnit.remove(unit);
+                                else spawnUnit.add(unit);
+                                rebuild[0].run();
+                            }).tooltip(unit.localizedName).checked(spawnUnit.contains(unit)).size(50f);
+                            if(list.getChildren().size % 8 == 0) list.row();
+                        }
+                    }).row();
+                    c.table(ct -> {
+                        ct.add("环境").width(50f);
+                        ct.button("Surplus", flatToggleMenut, () -> {
+                            surplusUnit = !surplusUnit;
+                            for(UnitType unit : allowUnit.copy().retainAll(unitType -> !(unitType instanceof ErekirUnitType))){
+                                filterUnit(unit, surplusUnit);
+                            }
+                            rebuild[0].run();
+                        }).checked(surplusUnit).width(120f);
+                        ct.button("Erekir", flatToggleMenut, () -> {
+                            ErekirUnit = !ErekirUnit;
+                            for(UnitType unit : allowUnit.copy().retainAll(unitType -> unitType instanceof ErekirUnitType)){
+                                filterUnit(unit, ErekirUnit);
+                            }
+                            rebuild[0].run();
+                        }).checked(ErekirUnit).width(120f);
+                    });
+                    c.row();
+                    c.table(ct -> {
+                        ct.add("兵种").width(50f);
+                        ct.button("空军", flatToggleMenut, () -> {
+                            flyingUnit = !flyingUnit;
+                            for(UnitType unit : allowUnit.copy().retainAll(unitType -> unitType.flying)){
+                                filterUnit(unit, flyingUnit);
+                            }
+                            rebuild[0].run();
+                        }).checked(flyingUnit).width(70f);
+                        ct.button("海军", flatToggleMenut, () -> {
+                            navalUnit = !navalUnit;
+                            for(UnitType unit : allowUnit.copy().retainAll(unitType -> unitType.naval)){
+                                filterUnit(unit, navalUnit);
+                            }
+                            rebuild[0].run();
+                        }).checked(navalUnit).width(70f);
+                        ct.button("支援", flatToggleMenut, () -> {
+                            supportUnit = !supportUnit;
+                            for(UnitType unit : allowUnit.copy().retainAll(unitType -> unitType.controller instanceof BuilderAI || unitType.controller instanceof MinerAI || unitType.controller instanceof RepairAI)){
+                                filterUnit(unit, supportUnit);
+                            }
+                            rebuild[0].run();
+                        }).checked(supportUnit).width(70f);
+                    });
+                }
+                c.row();
+                c.button("生成！", () -> {
+                    groups.clear();
+                    groups = Waves.generate(difficult / 10, new Rand(), flyingUnit, navalUnit, supportUnit);
+                    updateWaves();
+                    buildGroups();
+                }).width(300f);
+            });
+
+        };
+        rebuild[0].run();
+        dialog.addCloseButton();
+        dialog.show();
+        ui.announce("功能制作中..请等待完成\n[orange]目前可调整：难度|空|海|辅，其他功能均无效", 15);
+    }
+
+    private void filterUnit(UnitType unit, boolean filter){
+        if(filter && !spawnUnit.contains(unit)){
+            spawnUnit.add(unit);
+        }else if(!filter && spawnUnit.contains(unit)){
+            spawnUnit.remove(unit);
+        }
+    }
+}
diff --git a/core/src/mindustry/arcModule/ui/OtherCoreItemDisplay.java b/core/src/mindustry/arcModule/ui/OtherCoreItemDisplay.java
new file mode 100644
index 0000000000000000000000000000000000000000..55e6561776575600915b82d8bbfbe847857e2bd3
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/OtherCoreItemDisplay.java
@@ -0,0 +1,225 @@
+package mindustry.arcModule.ui;
+
+import arc.*;
+import arc.func.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.*;
+import mindustry.arcModule.*;
+import mindustry.content.*;
+import mindustry.core.*;
+import mindustry.game.*;
+import mindustry.graphics.*;
+import mindustry.type.*;
+import mindustry.ui.*;
+import mindustryX.features.*;
+import mindustryX.features.ui.*;
+
+import static mindustry.Vars.*;
+import static mindustry.gen.Tex.*;
+import static mindustry.ui.Styles.*;
+
+public class OtherCoreItemDisplay extends Table{
+    public Seq<Teams.TeamData> teams = new Seq<>();
+
+    private float lastUpd = 0f;
+    private final float fontScl = 0.8f;
+    private boolean show = false, showStat = true, showItem = true, showUnit = true;
+
+    private final Table teamsTable;
+
+    private final TextButton.TextButtonStyle textStyle;
+
+    private final Seq<Teams.TeamData> forceShowTeam = new Seq<>();
+
+    public OtherCoreItemDisplay(){
+
+        textStyle = new TextButton.TextButtonStyle(){{
+            down = flatOver;
+            up = pane;
+            over = flatDownBase;
+            font = Fonts.def;
+            fontColor = Color.white;
+            disabledFontColor = Color.gray;
+            checked = flatDown;
+        }};
+
+        teamsTable = new Table();
+        rebuild();
+
+        Events.on(EventType.WorldLoadEvent.class, e -> forceShowTeam.clear());
+    }
+
+    void rebuild(){
+        clear();
+        if(!show){
+            button("[red]+", textStyle, () -> {
+                show = !show;
+                rebuild();
+            }).left().width(40f).fillY().get().left();
+        }else{
+            table(t -> {
+                t.table(buttons -> {
+                    buttons.button("[red]×", textStyle, () -> {
+                        show = !show;
+                        rebuild();
+                    }).size(40f).row();
+
+                    buttons.button("T", textStyle, () -> UIExt.teamSelect.select(team -> teams.contains(team.data()), team -> {
+                        if(forceShowTeam.contains(team.data())) forceShowTeam.remove(team.data());
+                        else forceShowTeam.add(team.data());
+                        updateTeamList();
+                        teamsRebuild();
+                    })).checked(gg -> false).size(40f).row();
+
+                    buttons.button(Blocks.worldProcessor.emoji(), textStyle, () -> {
+                        showStat = !showStat;
+                        teamsRebuild();
+                    }).checked(a -> showStat).size(40f).row();
+
+                    buttons.button(content.items().get(0).emoji(), textStyle, () -> {
+                        showItem = !showItem;
+                        teamsRebuild();
+                    }).checked(a -> showItem).size(40f).row();
+
+                    buttons.button(UnitTypes.mono.emoji(), textStyle, () -> {
+                        showUnit = !showUnit;
+                        teamsRebuild();
+                    }).checked(a -> showUnit).size(40f);
+                }).left();
+
+                teamsRebuild();
+
+                t.add(teamsTable).left();
+
+            }).left();
+        }
+    }
+
+    private void teamsRebuild(){
+        teamsTable.clear();
+        teamsTable.background(Styles.black6);
+        teamsTable.update(() -> {
+            if(Time.time - lastUpd > 120f){
+                lastUpd = Time.time;
+                updateTeamList();
+                teamsRebuild();
+            }
+        });
+        teams.sort(teamData -> -teamData.cores.size);
+
+        /**name + cores + units */
+        teamsTable.add();
+        addTeamData(teamsTable, team -> team.team.id < 6 ? team.team.localized() : String.valueOf(team.team.id));
+        addTeamData(teamsTable, Blocks.coreNucleus.uiIcon, team -> UI.formatAmount(team.cores.size));
+        addTeamData(teamsTable, UnitTypes.mono.uiIcon, team -> UI.formatAmount(team.units.size));
+        addTeamData(teamsTable, UnitTypes.gamma.uiIcon, team -> String.valueOf(team.players.size));
+
+        if(showStat){
+            teamsTable.image().color(Pal.accent).fillX().height(1).colspan(999).padTop(3).padBottom(3).row();
+            addTeamDataCheck(teamsTable, Blocks.siliconSmelter.uiIcon, team -> team.team.rules().cheat, false);
+            addTeamDataCheck(teamsTable, Blocks.arc.uiIcon, team -> state.rules.blockDamage(team.team));
+            addTeamDataCheck(teamsTable, Blocks.titaniumWall.uiIcon, team -> state.rules.blockHealth(team.team));
+            addTeamDataCheck(teamsTable, Blocks.buildTower.uiIcon, team -> state.rules.buildSpeed(team.team));
+            addTeamDataCheck(teamsTable, UnitTypes.corvus.uiIcon, team -> state.rules.unitDamage(team.team));
+            addTeamDataCheck(teamsTable, UnitTypes.oct.uiIcon, team -> state.rules.unitHealth(team.team));
+            addTeamDataCheck(teamsTable, UnitTypes.zenith.uiIcon, team -> state.rules.unitCrashDamage(team.team));
+            addTeamDataCheck(teamsTable, Blocks.tetrativeReconstructor.uiIcon, team -> state.rules.unitBuildSpeed(team.team));
+            addTeamDataCheck(teamsTable, Blocks.basicAssemblerModule.uiIcon, team -> state.rules.unitCost(team.team));
+            teamsTable.row();
+        }
+
+        if(showItem){
+            teamsTable.image().color(Pal.accent).fillX().height(1).colspan(999).padTop(3).padBottom(3).row();
+            for(Item item : content.items()){
+                boolean show = false;
+                for(Teams.TeamData team : teams){
+                    if(team.hasCore() && team.core().items.get(item) > 0)
+                        show = true;
+                }
+                if(show){
+                    addTeamData(teamsTable, item.uiIcon, team -> (team.hasCore() && team.core().items.get(item) > 0) ? UI.formatAmount(team.core().items.get(item)) : "-");
+                }
+            }
+        }
+
+        if(showUnit){
+            teamsTable.image().color(Pal.accent).fillX().height(1).colspan(999).padTop(3).padBottom(3).row();
+            for(UnitType unit : content.units()){
+                boolean show = false;
+                for(Teams.TeamData team : teams){
+                    if(team.countType(unit) > 0)
+                        show = true;
+                }
+                if(show){
+                    addTeamData(teamsTable, unit.uiIcon, team -> team.countType(unit) > 0 ? String.valueOf(team.countType(unit)) : "-");
+                }
+            }
+        }
+    }
+
+    private void updateTeamList(){
+        teams = Vars.state.teams.getActive().copy();
+        if(state.rules.waveTimer) teams.addUnique(state.rules.waveTeam.data());
+        forceShowTeam.each(team -> teams.addUnique(team));
+    }
+
+    private void addTeamDataCheck(Table table, TextureRegion icon, Floatf<Teams.TeamData> checked){
+        addTeamDataCheck(table, icon, checked, 1f);
+    }
+
+    private void addTeamDataCheck(Table table, TextureRegion icon, Floatf<Teams.TeamData> checked, float defaultValue){
+        boolean show = false;
+        boolean sameValue = true;
+        float value = -1;
+        for(Teams.TeamData teamData : teams){
+            if(checked.get(teamData) != defaultValue) show = true;
+            if(value == -1) value = checked.get(teamData);
+            else if(value != checked.get(teamData)) sameValue = false;
+        }
+        if(show){
+            if(sameValue) addTeamData(table, icon, FormatDefault.format(value));
+            else addTeamData(table, icon, team -> FormatDefault.format(checked.get(team)));
+        }
+    }
+
+    private void addTeamDataCheck(Table table, TextureRegion icon, Boolf<Teams.TeamData> checked, Boolean defaultValue){
+        /** 检测是否一样，如果一样就只显示一个数值 */
+        boolean show = false;
+        boolean sameRevert = true;
+        for(Teams.TeamData teamData : teams){
+            if(checked.get(teamData) != defaultValue) show = true;
+            else sameRevert = false;
+        }
+        if(show){
+            if(sameRevert) addTeamData(table, icon, sameRevert ? " +" : " x");
+            else addTeamData(table, icon, team -> checked.get(team) ? "+" : "×");
+        }
+    }
+
+    private void addTeamData(Table table, TextureRegion icon, String value){
+        /** 只显示一个数值 */
+        table.image(icon).size(15, 15).left();
+        table.label(() -> "[#" + Pal.accent + "]" + value).fillX().get().setFontScale(fontScl);
+        table.row();
+    }
+
+    private void addTeamData(Table table, TextureRegion icon, RFuncs.Stringf<Teams.TeamData> teamDataStringf){
+        /** 通用情况 */
+        table.image(icon).size(15, 15).left();
+        addTeamData(table, teamDataStringf);
+    }
+
+    private void addTeamData(Table table, RFuncs.Stringf<Teams.TeamData> teamDataStringf){
+        /** 通用情况 */
+        for(Teams.TeamData teamData : teams){
+            table.label(() -> "[#" + teamData.team.color + "]" + teamDataStringf.get(teamData)).get().setFontScale(fontScl);
+        }
+        table.row();
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/mindustry/arcModule/ui/PowerInfo.java b/core/src/mindustry/arcModule/ui/PowerInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..de4860d6732221c934b89eff3b33ee5673d8587c
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/PowerInfo.java
@@ -0,0 +1,93 @@
+package mindustry.arcModule.ui;
+
+import arc.*;
+import arc.math.*;
+import arc.scene.*;
+import arc.scene.ui.layout.*;
+import mindustry.*;
+import mindustry.core.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+
+public class PowerInfo{
+
+    private static final PowerInfo info = new PowerInfo();
+    public float powerbal;
+    public float stored;
+    public float capacity;
+    public float produced;
+    public float need;
+
+    public void add(float powerbal, float stored, float cap, float produced, float need){
+        this.powerbal += powerbal;
+        this.stored += stored;
+        this.capacity += cap;
+        this.produced += produced;
+        this.need += need;
+    }
+
+    private void clear(){
+        this.powerbal = 0;
+        this.stored = 0;
+        this.capacity = 0;
+        this.produced = 0;
+        this.need = 0;
+    }
+
+    public int getPowerBalance(){
+        return (int)(powerbal * 60);
+    }
+
+    public float getStored(){
+        return stored;
+    }
+
+    public float getCapacity(){
+        return capacity;
+    }
+
+    public float getSatisfaction(){
+        if(Mathf.zero(produced)){
+            return 0f;
+        }else if(Mathf.zero(need)){
+            return 1f;
+        }
+        return produced / need;
+    }
+
+
+    public static void update(){
+        info.clear();
+        Groups.powerGraph.each(item -> {
+            if(item.graph().team == Vars.player.team())
+                info.add(item.graph().getPowerBalance(), item.graph().getLastPowerStored(), item.graph().getLastCapacity(), item.graph().getLastPowerProduced(), item.graph().getLastPowerNeeded());
+        });
+    }
+
+    public static Element getBars(){
+        Table power = new Table(Tex.wavepane).marginTop(6);
+
+        Bar powerBar = new Bar(
+        () -> Core.bundle.format("bar.powerbalance", (info.getPowerBalance() >= 0 ? "+" : "") + UI.formatAmount(info.getPowerBalance())) +
+        (info.getSatisfaction() >= 1 ? "" : " [gray]" + (int)(info.getSatisfaction() * 100) + "%"),
+        () -> Pal.powerBar,
+        info::getSatisfaction);
+        Bar batteryBar = new Bar(
+        () -> Core.bundle.format("bar.powerstored", UI.formatAmount((long)info.getStored()), UI.formatAmount((long)info.getCapacity())),
+        () -> Pal.powerBar,
+        () -> info.getStored() / info.getCapacity());
+
+        power.clicked(() -> {
+            int arccoreitems = Core.settings.getInt("arccoreitems");
+            Core.settings.put("arccoreitems", (arccoreitems + 1) % 4);
+        });
+        power.margin(0);
+        power.add(powerBar).height(18).growX().padBottom(1);
+        power.row();
+        power.add(batteryBar).height(18).growX().padBottom(1);
+
+        power.update(PowerInfo::update);
+        return power;
+    }
+}
\ No newline at end of file
diff --git a/core/src/mindustry/arcModule/ui/RCoreItemsDisplay.java b/core/src/mindustry/arcModule/ui/RCoreItemsDisplay.java
new file mode 100644
index 0000000000000000000000000000000000000000..ffb76ff3a20244adbf930c84d2b24efda42341cf
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/RCoreItemsDisplay.java
@@ -0,0 +1,180 @@
+package mindustry.arcModule.ui;
+
+import arc.*;
+import arc.func.*;
+import arc.scene.event.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.*;
+import mindustry.core.*;
+import mindustry.entities.*;
+import mindustry.type.*;
+import mindustry.ui.*;
+import mindustry.world.*;
+import mindustry.world.blocks.power.*;
+import mindustry.world.blocks.storage.*;
+import mindustry.world.blocks.storage.CoreBlock.*;
+
+import static mindustry.Vars.*;
+
+public class RCoreItemsDisplay extends CoreItemsDisplay{
+    private final Interval timer = new Interval(), timer2 = new Interval();
+    private final ObjectSet<Item> usedItems = new ObjectSet<>();
+    private final ObjectSet<UnitType> usedUnits = new ObjectSet<>();
+    private final int[] updateItems = new int[content.items().size];
+    private final int[] lastItems = new int[content.items().size];
+    private ItemSeq planItems = new ItemSeq();
+    private CoreBuild core;
+    private int arccoreitems = -1;
+    private final ObjectIntMap<Block> planBlock = new ObjectIntMap<>();
+    private final Boolf<Block> planBlockFilter = b -> b.category != Category.distribution
+    && b.category != Category.liquid
+    && !(b instanceof PowerNode)
+    && !(b instanceof BeamNode);
+
+    public RCoreItemsDisplay(){
+        arccoreitems = Core.settings.getInt("arccoreitems");
+        rebuild();
+    }
+
+    @Override
+    public void resetUsed(){
+        usedItems.clear();
+        usedUnits.clear();
+        background(null);
+    }
+
+    public void updateItems(){
+        if(core == null) return;
+        for(Item item : Vars.content.items()){
+            if(lastItems != null) updateItems[item.id] = core.items.get(item) - lastItems[item.id];
+            lastItems[item.id] = core.items.get(item);
+        }
+    }
+
+    private ItemSeq updatePlanItems(){
+        planItems = new ItemSeq();
+        control.input.allPlans().each(plan -> {
+            if(plan.block instanceof CoreBlock) return;
+            for(ItemStack stack : plan.block.requirements){
+                int planAmount = (int)(plan.breaking ? -1 * state.rules.buildCostMultiplier * state.rules.deconstructRefundMultiplier * stack.amount * plan.progress : state.rules.buildCostMultiplier * stack.amount * (1 - plan.progress));
+                planItems.add(stack.item, planAmount);
+            }
+        });
+        return planItems;
+    }
+
+    void rebuild(){
+        clear();
+        if(usedItems.size > 0 || usedUnits.size > 0){
+            background(Styles.black3);
+            margin(4);
+        }
+
+        update(() -> {
+            core = Vars.player.team().core();
+
+            if(timer.get(60f)) updateItems();
+            updatePlanItems();
+
+            if(arccoreitems != Core.settings.getInt("arccoreitems")){
+                arccoreitems = Core.settings.getInt("arccoreitems");
+                rebuild();
+            }
+
+            if(content.items().contains(item -> core != null && core.items.get(item) > 0 && usedItems.add(item))){
+                rebuild();
+            }
+
+            if(content.items().contains(item -> core != null && core.items.get(item) > 0 && usedItems.add(item)) || content.units().contains(unit -> Vars.player.team().data().countType(unit) > 0 && usedUnits.add(unit))){
+                rebuild();
+            }
+
+            if(timer2.get(2f)) rebuild();
+            touchable = Touchable.disabled;
+        });
+
+        int i = 0;
+        if(arccoreitems == 1 || arccoreitems == 3){
+            for(Item item : content.items()){
+                if(usedItems.contains(item)){
+                    if(mobile){
+                        stack(
+                        new Table(t -> t.image(item.uiIcon).size(iconSmall).padRight(3).tooltip(tooltip -> tooltip.background(Styles.black6).margin(4f).add(item.localizedName).style(Styles.outlineLabel))),
+
+                        new Table(t -> t.label(() -> {
+                            int update = updateItems[item.id];
+                            if(update == 0) return "";
+                            return (update < 0 ? "[red]" : "[green]+") + update;
+                        }).get().setFontScale(0.85f)).top().left()
+                        );
+                    }else{
+                        stack(
+                        new Table(t -> t.image(item.uiIcon).size(iconSmall).padRight(3).tooltip(tooltip -> tooltip.background(Styles.black6).margin(4f).add(item.localizedName).style(Styles.outlineLabel))),
+
+                        new Table(t -> t.label(() -> {
+                            int update = updateItems[item.id];
+                            if(update == 0) return "";
+                            return (update < 0 ? "[red]" : "[green]+") + update;
+                        }).get().setFontScale(0.85f)).top().left()
+                        );
+                    }
+
+
+                    label(() -> {
+                        if(core == null) return "";
+                        int planAmount = planItems.get(item);
+                        int amount = core.items.get(item);
+                        if(planAmount == 0)
+                            return (amount >= player.team().core().storageCapacity * 0.99 ? "[stat]" : "") + UI.formatAmount(amount);
+                        String planColor = (planAmount > 0 ? "[scarlet]" : "[green]");
+                        String amountColor = (amount < planAmount / 2 ? "[scarlet]" : amount < planAmount ? "[stat]" : "[green]");
+                        return amountColor + UI.formatAmount(amount) + "[white]/" + planColor + UI.formatAmount(Math.abs(planAmount));
+                    }).padRight(3).minWidth(52f).left();
+
+                    if(++i % Core.settings.getInt("arcCoreItemsCol") == 0){
+                        row();
+                    }
+                }
+            }
+        }
+
+        if(arccoreitems == 2 || arccoreitems == 3){
+            row();
+            i = 0;
+            for(UnitType unit : content.units()){
+                if(usedUnits.contains(unit)){
+                    image(unit.uiIcon).size(iconSmall).padRight(3).tooltip(t -> t.background(Styles.black6).margin(4f).add(unit.localizedName).style(Styles.outlineLabel));
+                    label(() -> {
+                        int typeCount = player.team().data().countType(unit);
+                        return (typeCount == Units.getCap(player.team()) ? "[stat]" : "") + typeCount;
+                    }).padRight(3).minWidth(52f).left();
+
+                    if(++i % Core.settings.getInt("arcCoreItemsCol") == 0){
+                        row();
+                    }
+                }
+            }
+        }
+
+        i = 0;
+        row();
+        planBlock.clear();
+        control.input.allPlans().each(p -> planBlock.put(p.block, planBlock.get(p.block, 0) + (p.breaking ? -1 : 1)));
+        for(Block block : content.blocks().select(planBlockFilter)){
+            int count = planBlock.get(block, 0);
+            if(count != 0){
+                image(block.uiIcon).size(iconMed).padRight(3);
+                label(() -> (count > 0 ? "[green]+" : "[red]") + count).padRight(3).minWidth(52f).left();
+                if(++i % Core.settings.getInt("arcCoreItemsCol") == 0){
+                    row();
+                }
+            }
+        }
+    }
+
+    public boolean hadItem(Item item){
+        return usedItems.contains(item);
+    }
+}
diff --git a/core/src/mindustry/arcModule/ui/RStyles.java b/core/src/mindustry/arcModule/ui/RStyles.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a283c2cbcd741967b2a4d650a6db309b4fe5724
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/RStyles.java
@@ -0,0 +1,86 @@
+package mindustry.arcModule.ui;
+
+import arc.graphics.*;
+import arc.scene.style.*;
+import arc.scene.ui.ImageButton.*;
+import arc.scene.ui.TextButton.*;
+import mindustry.gen.*;
+import mindustry.ui.*;
+
+import static mindustry.gen.Tex.underlineWhite;
+import static mindustry.ui.Styles.*;
+
+public class RStyles{
+    public static TextureRegionDrawable whiteuir;
+    public static Drawable black1;
+
+    public static TextButtonStyle
+    logicButton,
+    flatt,
+    clearLineNonet,
+    clearLineNoneTogglet;
+
+    public static ImageButtonStyle
+    clearAccentNonei,
+    clearAccentNoneTogglei,
+    clearLineNonei,
+    clearLineNoneTogglei;
+
+    public static void load(){
+        whiteuir = (TextureRegionDrawable)Tex.whiteui;
+
+        black1 = whiteuir.tint(0f, 0f, 0f, 0.1f);
+
+        logicButton = new TextButtonStyle(){{
+            up = none;
+            over = flatOver;
+            font = Fonts.outline;
+            fontColor = Color.white;
+        }};
+
+        flatt = new TextButtonStyle(){{
+            font = Fonts.def;
+            fontColor = Color.white;
+            down = flatOver;
+            up = black;
+            over = flatOver;
+            disabled = black;
+            disabledFontColor = Color.gray;
+        }};
+
+        clearLineNonet = new TextButtonStyle(flatt){{
+            up = none;
+            over = accentDrawable;
+            down = underlineWhite;
+        }};
+
+        clearLineNoneTogglet = new TextButtonStyle(fullTogglet){{
+            up = none;
+            over = accentDrawable;
+            down = underlineWhite;
+            checked = underlineWhite;
+            disabledFontColor = Color.white;
+        }};
+
+        clearAccentNonei = new ImageButtonStyle(clearNonei){{
+            up = none;
+            over = black3;
+            down = none;
+        }};
+
+        clearAccentNoneTogglei = new ImageButtonStyle(clearAccentNonei){{
+            checked = accentDrawable;
+        }};
+
+        clearLineNonei = new ImageButtonStyle(clearNonei){{
+            up = none;
+            over = accentDrawable;
+            down = none;
+        }};
+
+        clearLineNoneTogglei = new ImageButtonStyle(clearLineNonei){{
+            checked = underlineWhite;
+        }};
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/ui/auxilliary/AITools.java b/core/src/mindustry/arcModule/ui/auxilliary/AITools.java
new file mode 100644
index 0000000000000000000000000000000000000000..8c0e84a867e1280426890eff8ed494cd878dc20f
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/auxilliary/AITools.java
@@ -0,0 +1,125 @@
+package mindustry.arcModule.ui.auxilliary;
+
+import arc.*;
+import arc.graphics.g2d.*;
+import arc.scene.style.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.util.*;
+import mindustry.ai.types.*;
+import mindustry.arcModule.*;
+import mindustry.arcModule.ai.*;
+import mindustry.content.*;
+import mindustry.entities.units.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.ui.dialogs.*;
+import mindustry.world.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ai.ArcMinerAI.*;
+import static mindustry.arcModule.ui.RStyles.clearLineNoneTogglei;
+import static mindustry.content.UnitTypes.*;
+import static mindustry.ui.Styles.flatToggleMenut;
+
+public class AITools extends BaseToolsTable{
+    private AIController selectAI;
+
+    public AITools(){
+        super(Icon.android);
+
+        Events.run(EventType.Trigger.update, () -> {
+            if(selectAI != null){
+                selectAI.unit(player.unit());
+                selectAI.updateUnit();
+            }
+        });
+    }
+
+    @Override
+    public void setup(){
+        button(Icon.settingsSmall, clearLineNoneTogglei, 30, this::showSettingDialog);
+
+        if(false) aiButton(new ATRIAI(), Blocks.worldProcessor.region, "ATRI AI");
+        aiButton(new ArcMinerAI(), mono.region, "矿机AI");
+        aiButton(new ArcBuilderAI(), poly.region, "重建AI");
+        aiButton(new ArcRepairAI(), mega.region, "修复AI");
+        aiButton(new DefenderAI(), oct.region, "保护AI");
+    }
+
+    private void aiButton(AIController ai, TextureRegion textureRegion, String describe){
+        button(new TextureRegionDrawable(textureRegion), clearLineNoneTogglei, 30, () -> selectAI(ai))
+        .checked(b -> selectAI == ai).size(40).with(b -> ElementUtils.tooltip(b, describe));
+    }
+
+    private void selectAI(AIController ai){
+        selectAI = selectAI == ai ? null : ai;
+    }
+
+    private void showSettingDialog(){
+        int cols = (int)Math.max(Core.graphics.getWidth() / Scl.scl(480), 1);
+
+        BaseDialog dialog = new BaseDialog("ARC-AI设定器");
+
+        dialog.cont.table(t -> {
+            t.add("minerAI-矿物筛选器").color(Pal.accent).pad(cols / 2f).center().row();
+
+            t.image().color(Pal.accent).fillX().row();
+
+            t.table(c -> {
+                c.add("地表矿").row();
+
+                c.table(list -> {
+                    int i = 0;
+                    for(Block block : ArcMinerAI.oreAllList){
+                        if(indexer.floorOresCount[block.id] == 0) continue;
+                        if(i++ % 3 == 0) list.row();
+                        list.button(block.emoji() + "\n" + indexer.floorOresCount[block.id], flatToggleMenut, () -> {
+                            if(oreList.contains(block)) oreList.remove(block);
+                            else if(!oreList.contains(block)) oreList.add(block);
+                        }).tooltip(block.localizedName).checked(k -> oreList.contains(block)).width(100f).height(50f);
+                    }
+                }).row();
+
+                c.add("墙矿").row();
+
+                c.table(list -> {
+                    int i = 0;
+                    for(Block block : oreAllWallList){
+                        if(indexer.wallOresCount[block.id] == 0) continue;
+                        if(i++ % 3 == 0) list.row();
+                        list.button(block.emoji() + "\n" + indexer.wallOresCount[block.id], flatToggleMenut, () -> {
+                            if(oreWallList.contains(block)) oreWallList.remove(block);
+                            else if(!oreWallList.contains(block)) oreWallList.add(block);
+                        }).tooltip(block.localizedName).checked(k -> oreWallList.contains(block)).width(100f).height(50f);
+                    }
+                }).row();
+
+            }).growX();
+        }).growX();
+
+        dialog.cont.row();
+
+        dialog.cont.table(t -> {
+            t.add("builderAI").color(Pal.accent).pad(cols / 2f).center().row();
+
+            t.image().color(Pal.accent).fillX().row();
+
+            t.table(tt -> {
+                tt.add("重建冷却时间: ");
+
+                TextField sField = tt.field(ArcBuilderAI.rebuildTime + "", text -> ArcBuilderAI.rebuildTime = Math.max(5f, Float.parseFloat(text))).valid(Strings::canParsePositiveFloat).width(200f).get();
+
+                tt.slider(5, 200, 5, i -> {
+                    ArcBuilderAI.rebuildTime = i;
+                    sField.setText(ArcBuilderAI.rebuildTime + "");
+                }).width(200f);
+            }).growX();
+        }).growX();
+
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/ui/auxilliary/AuxilliaryTable.java b/core/src/mindustry/arcModule/ui/auxilliary/AuxilliaryTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a9c5094a0ff2412d6e32c44b16427c51a3f76f8
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/auxilliary/AuxilliaryTable.java
@@ -0,0 +1,63 @@
+package mindustry.arcModule.ui.auxilliary;
+
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import mindustry.ui.*;
+
+import static mindustry.arcModule.ui.RStyles.*;
+
+public class AuxilliaryTable extends Table{
+    private boolean shown = true;
+    private final Seq<BaseToolsTable> toolsTables = Seq.with(
+    new MapInfoTable(),
+    new WaveInfoTable(),
+    new AITools(),
+    new ScriptButtons(),
+    new MobileScriptButtons(),
+    new MarkTable()
+    );
+
+    public AuxilliaryTable(){
+        setup();
+
+        rebuild();
+    }
+
+    public void setup(){
+        for(BaseToolsTable table : toolsTables){
+            table.setup();
+        }
+    }
+
+    public void toggle(){
+        shown = !shown;
+        rebuild();
+    }
+
+    private void rebuild(){
+        clearChildren();
+
+        table(Styles.black3, buttons -> {
+            buttons.button("[acid]辅助器", clearLineNoneTogglet, this::toggle).size(80f, 40f).tooltip((shown ? "关闭" : "开启") + "辅助器");
+
+            if(shown){
+                for(BaseToolsTable table : toolsTables){
+                    table.addButton(buttons);
+                }
+            }
+        }).fillX();
+
+        row();
+
+        if(shown){
+            table(black1, body -> {
+                body.defaults().expandX().left();
+                for(BaseToolsTable table : toolsTables){
+                    table.margin(4);
+                    body.collapser(table, table::shown).row();
+                }
+            }).fillX().left();
+        }
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/ui/auxilliary/BaseToolsTable.java b/core/src/mindustry/arcModule/ui/auxilliary/BaseToolsTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e3f82ed23ace533226f5501f94389fae5ea0211
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/auxilliary/BaseToolsTable.java
@@ -0,0 +1,36 @@
+package mindustry.arcModule.ui.auxilliary;
+
+import arc.graphics.g2d.*;
+import arc.scene.style.*;
+import arc.scene.ui.layout.*;
+
+import static mindustry.arcModule.ui.RStyles.clearAccentNoneTogglei;
+
+public abstract class BaseToolsTable extends Table{
+    private boolean shown;
+    protected Drawable icon;
+
+    public BaseToolsTable(TextureRegion region){
+        this(new TextureRegionDrawable(region));
+    }
+
+    public BaseToolsTable(Drawable icon){
+        this.icon = icon;
+    }
+
+    public void addButton(Table buttons){
+        buttons.button(icon, clearAccentNoneTogglei, 30, this::toggle)
+        .size(40).checked(b -> shown);
+    }
+
+    protected abstract void setup();
+
+    public boolean shown(){
+        return shown;
+    }
+
+    public boolean toggle(){
+        return shown = !shown;
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/mindustry/arcModule/ui/auxilliary/MapInfoTable.java b/core/src/mindustry/arcModule/ui/auxilliary/MapInfoTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..9ed0af557122eef8c91ff6f75e865ac739412cf1
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/auxilliary/MapInfoTable.java
@@ -0,0 +1,152 @@
+package mindustry.arcModule.ui.auxilliary;
+
+
+import arc.*;
+import arc.graphics.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import mindustry.content.*;
+import mindustry.editor.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.input.*;
+import mindustry.ui.dialogs.*;
+import mindustry.world.*;
+import mindustry.world.blocks.environment.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.arcModule.ui.RStyles.*;
+import static mindustry.input.InputHandler.*;
+import static mindustry.ui.Fonts.stringIcons;
+import static mindustry.ui.Styles.cleart;
+
+public class MapInfoTable extends BaseToolsTable{
+    private final MapInfoDialog mapInfoDialog = new MapInfoDialog();
+    private int uiRowIndex = 0;
+
+    public MapInfoTable(){
+        super(Icon.map);
+    }
+
+    @Override
+    protected void setup(){
+        defaults().size(40);
+
+        button(Icon.map, clearAccentNonei, mapInfoDialog::show).tooltip("地图信息");
+        button(Items.copper.emoji(), clearLineNonet, this::floorStatisticDialog).tooltip("矿物信息");
+        button(Icon.chatSmall, clearAccentNonei, () -> arcui.MessageDialog.show()).tooltip("中央监控室");
+        button(Icon.playersSmall, clearAccentNonei, () -> {
+            if(ui.listfrag.players.size > 1){
+                if(control.input instanceof DesktopInput){
+                    ((DesktopInput)control.input).panning = true;
+                }
+                if(follow == null) follow = ui.listfrag.players.get(0);
+                followIndex = (followIndex + 1) >= ui.listfrag.players.size ? 0 : followIndex + 1;
+                follow = ui.listfrag.players.get(followIndex);
+                arcui.arcInfo("视角追踪：" + follow.name, 3f);
+            }
+        }).tooltip("切换跟踪玩家");
+        button(Icon.starSmall, clearAccentNonei, arcui.achievements::show).tooltip("统计与成就");
+        if(!mobile) button(Icon.editSmall, clearAccentNonei, this::uiTable).tooltip("ui大全");
+    }
+
+    private void floorStatisticDialog(){
+        BaseDialog dialog = new BaseDialog("ARC-矿物统计");
+        Table table = dialog.cont;
+        table.clear();
+
+        table.table(c -> {
+            c.add("地表矿").color(Pal.accent).center().fillX().row();
+            c.image().color(Pal.accent).fillX().row();
+            c.table(list -> {
+                int i = 0;
+                for(Block block : content.blocks().select(b -> b instanceof Floor f && !f.wallOre && f.itemDrop != null)){
+                    if(indexer.floorOresCount[block.id] == 0) continue;
+                    if(i++ % 4 == 0) list.row();
+                    list.add(block.emoji() + " " + block.localizedName + "\n" + indexer.floorOresCount[block.id]).width(100f).height(50f);
+                }
+            }).row();
+
+            c.add("墙矿").color(Pal.accent).center().fillX().row();
+            c.image().color(Pal.accent).fillX().row();
+            c.table(list -> {
+                int i = 0;
+                for(Block block : content.blocks().select(b -> ((b instanceof Floor f && f.wallOre) || b instanceof StaticWall) && b.itemDrop != null)){
+                    if(indexer.wallOresCount[block.id] == 0) continue;
+                    if(i++ % 4 == 0) list.row();
+                    list.add(block.emoji() + " " + block.localizedName + "\n" + indexer.wallOresCount[block.id]).width(100f).height(50f);
+                }
+            }).row();
+
+            c.add("液体").color(Pal.accent).center().fillX().row();
+            c.image().color(Pal.accent).fillX().row();
+            c.table(list -> {
+                int i = 0;
+                for(Block block : content.blocks().select(b -> ((b instanceof Floor f && f.liquidDrop != null)))){
+                    if(indexer.floorOresCount[block.id] == 0) continue;
+                    if(i++ % 4 == 0) list.row();
+                    list.add(block.emoji() + " " + block.localizedName + "\n" + indexer.floorOresCount[block.id]).width(100f).height(50f);
+                }
+            }).row();
+        });
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    private void uiTable(){
+        BaseDialog dialog = new BaseDialog("ARC-ui大全");
+        uiRowIndex = 0;
+        TextField sField = dialog.cont.field("", text -> {
+        }).fillX().get();
+        dialog.cont.row();
+
+        dialog.cont.pane(c -> {
+            c.add("颜色").color(Pal.accent).center().fillX().row();
+            c.image().color(Pal.accent).fillX().row();
+            c.table(ct -> {
+                for(var colorEntry : Colors.getColors()){
+                    Color value = colorEntry.value;
+                    String key = colorEntry.key;
+                    ct.button("[#" + value + "]" + key, cleart, () -> {
+                        Core.app.setClipboardText("[#" + value + "]");
+                        sField.setText(sField.getText() + "[#" + value + "]");
+                    }).size(50f).tooltip(key);
+                    uiRowIndex += 1;
+                    if(uiRowIndex % 15 == 0) ct.row();
+                }
+            }).row();
+            c.add("物品").color(Pal.accent).center().fillX().row();
+            c.image().color(Pal.accent).fillX().row();
+            c.table(ct -> {
+                uiRowIndex = 0;
+                stringIcons.copy().each((name, iconc) -> {
+                    ct.button(iconc, cleart, () -> {
+                        Core.app.setClipboardText(iconc);
+                        sField.setText(sField.getText() + iconc);
+                    }).size(50f).tooltip(name);
+                    uiRowIndex += 1;
+                    if(uiRowIndex % 15 == 0) ct.row();
+                });
+            }).row();
+            c.add("图标").color(Pal.accent).center().fillX().row();
+            c.image().color(Pal.accent).fillX().row();
+            c.table(ct -> {
+                uiRowIndex = 0;
+                for(var i : Iconc.codes){
+                    String icon = String.valueOf((char)i.value), internal = i.key;
+                    ct.button(icon, cleart, () -> {
+                        Core.app.setClipboardText(icon);
+                        sField.setText(sField.getText() + icon);
+                    }).size(50f).tooltip(internal);
+                    uiRowIndex += 1;
+                    if(uiRowIndex % 15 == 0) ct.row();
+                }
+            }).row();
+        }).row();
+
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/ui/auxilliary/MarkTable.java b/core/src/mindustry/arcModule/ui/auxilliary/MarkTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..9ab666b3609baac16fa1a423ae5adef525423b28
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/auxilliary/MarkTable.java
@@ -0,0 +1,55 @@
+package mindustry.arcModule.ui.auxilliary;
+
+import arc.*;
+import arc.input.*;
+import arc.scene.*;
+import arc.scene.event.*;
+import mindustry.gen.*;
+import mindustry.ui.fragments.*;
+import mindustryX.features.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ui.RStyles.*;
+
+public class MarkTable extends BaseToolsTable{
+    public Element mobileHitter = new Element();
+
+    public MarkTable(){
+        super(Icon.effect);
+
+        mobileHitter.addListener(new ElementGestureListener(20, 0.4f, MarkerType.heatTime / 60f, 0.15f){
+            @Override
+            public boolean longPress(Element actor, float x, float y){
+                MarkerType.selected.markWithMessage(Core.input.mouseWorld());
+                mobileHitter.remove();
+                return true;
+            }
+
+            @Override
+            public void fling(InputEvent event, float velocityX, float velocityY, KeyCode button){
+                mobileHitter.remove();
+                ui.announce("[yellow]你已退出标记模式");
+            }
+        });
+
+        mobileHitter.fillParent = true;
+    }
+
+    @Override
+    protected void setup(){
+        if(mobile){
+            button("♐ >", clearLineNonet, () -> {
+                ui.hudGroup.addChild(mobileHitter);
+                ui.announce("[cyan]你已进入标记模式,长按屏幕可进行一次标记(外划可以退出).");
+            }).height(40).width(70f).tooltip("开启手机标记");
+        }
+
+        for(var type : MarkerType.allTypes){
+            button(type.shortName(), clearLineNoneTogglet, () -> MarkerType.selected = type)
+            .checked(b -> MarkerType.selected == type).size(40).tooltip(type.localizedName);
+        }
+
+        button("T", clearLineNoneTogglet, () -> ui.chatfrag.nextMode())
+        .checked(b -> ui.chatfrag.mode == ChatFragment.ChatMode.team).size(40).tooltip("前缀添加/t");
+    }
+}
diff --git a/core/src/mindustry/arcModule/ui/auxilliary/MobileScriptButtons.java b/core/src/mindustry/arcModule/ui/auxilliary/MobileScriptButtons.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa608f08f1726e7f5c7d3891a2103dcd1aeb59da
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/auxilliary/MobileScriptButtons.java
@@ -0,0 +1,52 @@
+package mindustry.arcModule.ui.auxilliary;
+
+import arc.*;
+import arc.scene.style.*;
+import mindustry.arcModule.toolpack.*;
+import mindustry.content.*;
+import mindustry.gen.*;
+
+import static mindustry.Vars.*;
+
+/**
+ * 专为手机制备的脚本按钮
+ */
+public class MobileScriptButtons extends ScriptButtons{
+
+    public MobileScriptButtons(){
+        icon = new TextureRegionDrawable(UnitTypes.emanate.uiIcon);
+
+        if(mobile){
+            toggle();
+        }
+    }
+
+    @Override
+    protected void setup(){
+        defaults().size(40);
+
+        scriptButton(Icon.unitsSmall, "指挥模式", () -> control.input.commandMode = !control.input.commandMode).checked(b -> control.input.commandMode);
+
+        scriptButton(Icon.pause, "暂停建造", () -> control.input.isBuilding = !control.input.isBuilding).checked(b -> control.input.isBuilding);
+
+        scriptButton(Icon.up, "捡起载荷", () -> control.input.tryPickupPayload());
+
+        scriptButton(Icon.down, "丢下载荷", () -> control.input.tryDropPayload());
+
+        scriptButton(Blocks.payloadConveyor.uiIcon, "进入传送带", () -> {
+            Building build = player.buildOn();
+
+            if(build == null) return;
+
+            Unit unit = player.unit();
+            Call.unitBuildingControlSelect(unit, build);
+        });
+
+        scriptButton(Blocks.radar.uiIcon, "雷达扫描", () -> arcScanner.mobileRadar = !arcScanner.mobileRadar);
+
+        addSettingButton(StatusEffects.unmoving.uiIcon, "viewMode", "原地静止", s -> {
+            if(s) Core.camera.position.set(player);
+        });
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/ui/auxilliary/ScriptButtons.java b/core/src/mindustry/arcModule/ui/auxilliary/ScriptButtons.java
new file mode 100644
index 0000000000000000000000000000000000000000..97e957b6498573a0d16a7a6be6b255dd51f6e052
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/auxilliary/ScriptButtons.java
@@ -0,0 +1,86 @@
+package mindustry.arcModule.ui.auxilliary;
+
+import arc.*;
+import arc.func.*;
+import arc.graphics.g2d.*;
+import arc.scene.style.*;
+import arc.scene.ui.*;
+import arc.scene.ui.ImageButton.*;
+import arc.scene.ui.layout.*;
+import mindustry.arcModule.*;
+import mindustry.content.*;
+import mindustry.gen.*;
+import mindustry.input.*;
+import mindustry.ui.dialogs.*;
+import mindustryX.features.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.arcModule.ui.RStyles.clearLineNonei;
+import static mindustry.content.UnitTypes.vela;
+
+public class ScriptButtons extends BaseToolsTable{
+
+    public ScriptButtons(){
+        super(UnitTypes.gamma.uiIcon);
+    }
+
+    @Override
+    protected void setup(){
+        defaults().size(40);
+
+        scriptButton(Blocks.buildTower.uiIcon, "在建造列表加入被摧毁建筑", () -> player.buildDestroyedBlocks());
+
+        scriptButton(Blocks.message.uiIcon, "锁定上个标记点", MarkerType::lockOnLastMark);
+
+        scriptButton(Items.copper.uiIcon, "一键放置", () -> player.dropItems());
+
+        scriptButton(Icon.pencilSmall, "特效显示", () -> EffectsDialog.withAllEffects().show());
+
+        addSettingButton(Icon.modeAttack, "autotarget", "自动攻击", s -> {
+        });
+
+        addSettingButton(vela.uiIcon, "forceBoost", "强制助推", s -> {
+        });
+
+        if(!mobile){
+            addSettingButton(Icon.eyeSmall, "removePan", "视角脱离玩家", s -> {
+                if(control.input instanceof DesktopInput desktopInput){
+                    desktopInput.panning = true;
+                }
+            });
+        }
+    }
+
+    protected void addSettingButton(TextureRegion region, String settingName, String description, Boolc onClick){
+        addSettingButton(new TextureRegionDrawable(region), settingName, description, onClick);
+    }
+
+    protected void addSettingButton(Drawable icon, String settingName, String description, Boolc onClick){
+        scriptButton(icon, description, () -> {
+            boolean setting = Core.settings.getBool(settingName);
+
+            Core.settings.put("removePan", !setting);
+            arcui.arcInfo("已" + (setting ? "取消" : "开启") + description);
+
+            onClick.get(!setting);
+        }).checked(b -> Core.settings.getBool(settingName));
+    }
+
+    protected Cell<ImageButton> scriptButton(TextureRegion region, String description, Runnable runnable){
+        return scriptButton(new TextureRegionDrawable(region), description, runnable);
+    }
+
+    protected Cell<ImageButton> scriptButton(Drawable icon, String description, Runnable runnable){
+        return scriptButton(icon, clearLineNonei, description, runnable);
+    }
+
+    protected Cell<ImageButton> scriptButton(Drawable icon, ImageButtonStyle style, String description, Runnable runnable){
+        Cell<ImageButton> cell = button(icon, style, 30, runnable);
+
+        ElementUtils.tooltip(cell.get(), description);
+
+        return cell;
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/ui/auxilliary/WaveInfoTable.java b/core/src/mindustry/arcModule/ui/auxilliary/WaveInfoTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..4535aee6132c6ddad0a25d495bdae53739ad3c11
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/auxilliary/WaveInfoTable.java
@@ -0,0 +1,137 @@
+package mindustry.arcModule.ui.auxilliary;
+
+import arc.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.util.*;
+import mindustry.arcModule.*;
+import mindustry.arcModule.ui.*;
+import mindustry.content.*;
+import mindustry.core.*;
+import mindustry.game.EventType.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.type.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+
+import static mindustry.Vars.state;
+import static mindustry.arcModule.toolpack.arcWaveSpawner.calWinWave;
+import static mindustry.arcModule.ui.RStyles.*;
+
+public class WaveInfoTable extends BaseToolsTable{
+    public static float fontScl = 0.8f;
+
+    private int waveOffset = 0;
+
+    private final Table waveInfo;
+
+    private final ArcWaveInfoDialog waveInfoDialog = new ArcWaveInfoDialog();
+
+    public WaveInfoTable(){
+        super(Icon.waves);
+
+        Events.on(WorldLoadEvent.class, e -> {
+            waveOffset = 0;
+            rebuildWaveInfo();
+        });
+
+        Events.on(WaveEvent.class, e -> rebuildWaveInfo());
+
+        waveInfo = new Table(Tex.pane);
+    }
+
+    @Override
+    protected void setup(){
+        left().top();
+        waveInfo.left().top();
+
+        button(Icon.waves, clearAccentNonei, waveInfoDialog::show).size(40).tooltip("波次信息");
+
+        table(buttons -> {
+            buttons.defaults().size(40);
+
+            buttons.button("<", clearLineNonet, () -> shiftWaveOffset(-1));
+
+            buttons.button("O", clearLineNonet, () -> setWaveOffset(0));
+
+            buttons.button(">", clearLineNonet, () -> shiftWaveOffset(1));
+
+            buttons.button("Go", clearLineNonet, () -> {
+                state.wave += waveOffset;
+                setWaveOffset(0);
+            });
+
+            buttons.button("♐", clearLineNonet, () -> {
+                String message = RFuncs.arcShareWaveInfo(state.wave + waveOffset);
+                int seperator = 145;
+                for(int i = 0; i < message.length() / (float)seperator; i++){
+                    Call.sendChatMessage(message.substring(i * seperator, Math.min(message.length(), (i + 1) * seperator)));
+                }
+            }).get().setDisabled(() -> !state.rules.waves && !Core.settings.getBool("arcShareWaveInfo"));
+
+        }).left().row();
+
+        table(setWave -> {
+            setWave.label(() -> "" + getDisplayWaves()).get().setFontScale(fontScl);
+
+            setWave.row();
+
+            setWave.button(Icon.settingsSmall, clearAccentNonei, 30, () -> {
+                Dialog lsSet = new BaseDialog("波次设定");
+                lsSet.cont.add("设定查询波次").padRight(5f).left();
+                TextField field = lsSet.cont.field(state.wave + waveOffset + "", text -> waveOffset = Integer.parseInt(text) - state.wave).size(320f, 54f).valid(Strings::canParsePositiveInt).maxTextLength(100).get();
+                lsSet.cont.row();
+                lsSet.cont.slider(1, calWinWave(), 1, res -> {
+                    waveOffset = (int)res - state.wave;
+                    field.setText((int)res + "");
+                });
+                lsSet.addCloseButton();
+                lsSet.show();
+            });
+        });
+
+        pane(Styles.noBarPane, waveInfo).scrollY(false).pad(8f).maxWidth(300f).left();
+    }
+
+    private void rebuildWaveInfo(){
+        waveInfo.clearChildren();
+
+        int curInfoWave = getDisplayWaves();
+        for(SpawnGroup group : state.rules.spawns){
+            int amount = group.getSpawned(curInfoWave);
+
+            if(amount == 0) continue;
+
+            float shield = group.getShield(curInfoWave);
+            StatusEffect effect = group.effect;
+
+            waveInfo.table(groupT -> {
+                groupT.image(group.type.uiIcon).scaling(Scaling.fit).size(20).row();
+
+                groupT.add("" + amount, fontScl).row();
+
+                groupT.add((shield > 0 ? UI.formatAmount((long)shield) : ""), fontScl).row();
+
+                if(effect != null && effect != StatusEffects.none){
+                    groupT.image(effect.uiIcon).size(20);
+                }
+            }).pad(8).left().top();
+        }
+    }
+
+    private void shiftWaveOffset(int shiftCount){
+        int offset = Math.max(waveOffset + shiftCount, -state.wave + 1);
+        setWaveOffset(offset);
+    }
+
+    private void setWaveOffset(int waveOffset){
+        this.waveOffset = waveOffset;
+        rebuildWaveInfo();
+    }
+
+    private int getDisplayWaves(){
+        return state.wave - 1 + waveOffset;
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/ui/dialogs/AchievementsDialog.java b/core/src/mindustry/arcModule/ui/dialogs/AchievementsDialog.java
new file mode 100644
index 0000000000000000000000000000000000000000..060892f1c4d2d25ccc9e08adc9ba32de4f90c0c4
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/dialogs/AchievementsDialog.java
@@ -0,0 +1,155 @@
+package mindustry.arcModule.ui.dialogs;
+
+import arc.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.service.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+
+import static mindustry.Vars.ui;
+import static mindustry.arcModule.ARCVars.arcui;
+
+public class AchievementsDialog extends BaseDialog{
+    private final ObjectMap<String, TextureRegion> textureCache = new ObjectMap<>();
+    private final String searchTxt = "";
+    private Table browserTable;
+    private Table SStatTable;
+
+
+    public AchievementsDialog(){
+        super("ARC-统计与成就");
+
+        cont.pane(t -> {
+            SStatTable = t;
+            t.row();
+            browserTable = t;
+        }).scrollX(false);
+        addCloseButton();
+
+        shown(this::rebuildBrowser);
+        onResize(this::rebuildBrowser);
+    }
+
+    private void rebuildBrowser(){
+        int cols = (int)Math.max(Core.graphics.getWidth() / Scl.scl(480), 1);
+        SStatTable.clear();
+        browserTable.clear();
+
+        SStatTable.add("统计").color(Pal.accent).pad(cols / 2).center().row();
+        SStatTable.image().color(Pal.accent).fillX().row();
+        SStatTable.table(t -> {
+            for(SStat stat : SStat.values()){
+                String name = Core.bundle.get("sstat." + stat.name() + ".name");
+                t.add(name).left();
+                if(stat.name() == "arcPlayTime") t.add("                 " + formatTime(stat.get())).left();
+                else t.add("                 " + stat.get()).left();
+                t.row();
+            }
+        });
+
+        browserTable.row();
+        browserTable.add("成就").color(Pal.accent).pad(cols / 2).center().row();
+        browserTable.image().color(Pal.accent).fillX().row();
+        browserTable.table(t -> {
+            int i = 0;
+            float s = 64f;
+
+            for(Achievement ach : Achievement.all){
+                String name = Core.bundle.get("achievement." + ach.name() + ".name");
+                String desc = (ach.isAchieved() ? "[stat]" : "") + Core.bundle.get("achievement." + ach.name() + ".desc");
+                //if( !Strings.matches(searchTxt, name) && !Strings.matches(searchTxt, desc) ) continue;
+
+                t.button(con -> {
+                    con.setColor(ach.isAchieved() ? Pal.accent : Color.lightGray);
+                    con.margin(0f);
+                    con.left();
+
+                    con.add(new BorderImage(){
+                        TextureRegion last;
+
+                        {
+                            border(ach.isAchieved() ? Pal.accent : Color.lightGray);
+                            setDrawable(Tex.nomap);
+                            pad = Scl.scl(4f);
+                        }
+
+                        @Override
+                        public void draw(){
+                            super.draw();
+
+                            //TODO draw the sprite of the achievement
+
+                            //textures are only requested when the rendering happens; this assists with culling
+                        /*
+                        if(!textureCache.containsKey(repo)){
+                            textureCache.put(repo, last = Core.atlas.find("nomap"));
+                            Http.get("https://raw.githubusercontent.com/Anuken/MindustryMods/master/icons/" + repo.replace("/", "_"), res -> {
+                                Pixmap pix = new Pixmap(res.getResult());
+                                Core.app.post(() -> {
+                                    try{
+                                        var tex = new Texture(pix);
+                                        tex.setFilter(TextureFilter.linear);
+                                        textureCache.put(repo, new TextureRegion(tex));
+                                        pix.dispose();
+                                    }catch(Exception e){
+                                        Log.err(e);
+                                    }
+                                });
+                            }, err -> {});
+                        }
+                        var next = textureCache.get(repo);
+                        if(last != next){
+                            last = next;
+                            setDrawable(next);
+                        }
+                        */
+                        }
+                    }).size(s).pad(4f * 2f);
+
+                    con.add("[accent]" + name +
+                    "\n[lightgray]" + desc
+                    ).width(358f).wrap().grow().pad(4f, 2f, 4f, 6f).top().left().labelAlign(Align.topLeft);
+
+                }, Styles.flatBordert, () -> {
+                }).padRight(4f);
+
+                if(++i % cols == 0) t.row();
+            }
+
+
+        });
+
+
+        browserTable.row();
+        browserTable.table(t -> {
+            t.button("[red]重置成就", () -> ui.showConfirm("你确定要重置所有成就吗", () -> {
+                for(Achievement ach : Achievement.all){
+                    ach.uncomplete();
+                }
+                arcui.arcInfo("已移除所有成就");
+                rebuildBrowser();
+            })).height(50f).width(200f);
+            if(Core.settings.getBool("otherCheat"))
+                t.button("[red]一键完成", () -> ui.showConfirm("你确定要一键完成所有成就吗", () -> {
+                    for(Achievement ach : Achievement.all){
+                        ach.complete();
+                    }
+                    arcui.arcInfo("已完成所有成就");
+                    rebuildBrowser();
+                })).height(50f).width(200f);
+        });
+    }
+
+    private String formatTime(int time){
+        int h = time / 3600;
+        int m = (time / 60) % 60;
+        int s = time % 60;
+        return h + " : " + m + " : " + s;
+    }
+}
\ No newline at end of file
diff --git a/core/src/mindustry/arcModule/ui/dialogs/BlockSelectDialog.java b/core/src/mindustry/arcModule/ui/dialogs/BlockSelectDialog.java
new file mode 100644
index 0000000000000000000000000000000000000000..42f4525cd60ea58008e93227f13041aaa2461d66
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/dialogs/BlockSelectDialog.java
@@ -0,0 +1,58 @@
+package mindustry.arcModule.ui.dialogs;
+
+import arc.func.*;
+import arc.scene.style.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustry.world.*;
+import mindustry.world.meta.*;
+import mindustryX.features.ui.*;
+
+import static mindustry.Vars.*;
+
+public class BlockSelectDialog extends BaseDialog{
+
+    private String searchBlock = "";
+    private final Table blockTable = new Table();
+
+    public BlockSelectDialog(Boolf<Block> condition, Cons<Block> cons, Boolf<Block> checked){
+        this(condition, cons, checked, true);
+    }
+
+    public BlockSelectDialog(Boolf<Block> condition, Cons<Block> cons, Boolf<Block> checked, boolean autoHide){
+        super("方块选择器");
+        rebuild(condition, cons, checked, autoHide);
+        cont.pane(td -> {
+            td.field("", t -> {
+                searchBlock = !t.isEmpty() ? t.toLowerCase() : "";
+                rebuild(condition, cons, checked, autoHide);
+            }).maxTextLength(50).growX().get().setMessageText("搜索...");
+            td.row();
+            td.add(blockTable);
+        });
+        addCloseButton();
+    }
+
+    private void rebuild(Boolf<Block> condition, Cons<Block> cons, Boolf<Block> checked, boolean autoHide){
+        blockTable.clear();
+        blockTable.table(td -> {
+            Seq<Block> blocks = content.blocks().select(block -> condition.get(block) && (searchBlock.length() == 0 || block.name.contains(searchBlock) || block.localizedName.contains(searchBlock)) && (block.privileged || AdvanceToolTable.allBlocksReveal || !block.isHidden())).sort(block -> block.group.ordinal());
+            Seq<BlockGroup> blockGroups = blocks.map(block -> block.group).distinct();
+            blockGroups.each(blockGroup -> {
+                td.row();
+                td.add(blockGroup.toString()).row();
+                td.image().color(Pal.accent).fillX().row();
+                td.table(ttd -> blocks.select(block1 -> block1.group == blockGroup).each(block1 -> {
+                    ttd.button(new TextureRegionDrawable(block1.uiIcon), Styles.cleari, iconSmall, () -> {
+                        cons.get(block1);
+                        if(autoHide) hide();
+                    }).tooltip(block1.localizedName).pad(3f).checked(b -> checked.get(block1)).size(50f);
+                    if(ttd.getChildren().size % 10 == 0) ttd.row();
+                }));
+            });
+        });
+    }
+}
diff --git a/core/src/mindustry/arcModule/ui/dialogs/MessageDialog.java b/core/src/mindustry/arcModule/ui/dialogs/MessageDialog.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f3c297c7ceadd20b44e6884b2e2dba945734787
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/dialogs/MessageDialog.java
@@ -0,0 +1,425 @@
+package mindustry.arcModule.ui.dialogs;
+
+import arc.*;
+import arc.graphics.*;
+import arc.math.geom.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.*;
+import mindustry.arcModule.*;
+import mindustry.arcModule.toolpack.*;
+import mindustry.arcModule.ui.*;
+import mindustry.core.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.input.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustry.world.blocks.storage.*;
+import mindustryX.features.*;
+
+import java.text.*;
+import java.util.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.ui.Styles.*;
+
+public class MessageDialog extends BaseDialog{
+
+    private boolean ignoreMark = false;
+    private int maxMsgRecorded = Math.max(Core.settings.getInt("maxMsgRecorded"), 20);
+    /**
+     * 存储的所有事件记录
+     */
+    public static Seq<advanceMsg> msgList = new Seq<>();
+
+    private Table historyTable;
+    private Boolean fieldMode = false;
+
+    public MessageDialog(){
+        super("ARC-中央监控室");
+
+        //voiceControl.voiceControlDialog();
+        cont.pane(t -> historyTable = t).growX().scrollX(false);
+
+        addCloseButton();
+        buttons.button("设置", Icon.settings, this::arcMsgSettingTable);
+        buttons.button("导出", Icon.upload, this::exportMsg).name("导出聊天记录");
+
+        buttons.row();
+        buttons.button("清空", Icon.trash, () -> {
+            clearMsg();
+            build();
+        });
+        buttons.button("图片分享器", Icon.image, arcChatPicture::arcSharePicture);
+        buttons.button("松鼠音乐", () -> arcui.MusicDialog.show());
+
+        shown(this::build);
+        onResize(this::build);
+
+        Events.on(EventType.WorldLoadEvent.class, e -> {
+            addMsg(new MessageDialog.advanceMsg(arcMsgType.eventWorldLoad, "载入地图： " + state.map.name()));
+            addMsg(new MessageDialog.advanceMsg(arcMsgType.eventWorldLoad, "简介： " + state.map.description()));
+            limitMsg(maxMsgRecorded);
+        });
+
+        Events.on(EventType.WaveEvent.class, e -> {
+            if(state.wavetime < 60f) return;
+            addMsg(new MessageDialog.advanceMsg(arcMsgType.eventWave, "波次： " + state.wave + " | " + RFuncs.arcWaveInfo(state.wave - 1)));
+        });
+
+        Events.on(EventType.BlockDestroyEvent.class, e -> {
+            if(e.tile.build instanceof CoreBlock.CoreBuild)
+                addMsg(new MessageDialog.advanceMsg(arcMsgType.eventCoreDestory, "核心摧毁： " + "(" + (int)e.tile.x + "," + (int)e.tile.y + ")", new Vec2(e.tile.x * 8, e.tile.y * 8)));
+        });
+    }
+
+    void build(){
+        historyTable.clear();
+        historyTable.setWidth(800f);
+        if(msgList.size == 0) return;
+        for(int i = msgList.size - 1; i >= 0; i--){
+            int finalI = i;
+            if(!msgList.get(finalI).msgType.show) continue;
+            historyTable.table(Tex.whiteui, t -> {
+                advanceMsg thisMsg = msgList.get(finalI);
+                t.background(Tex.whitePane);
+                t.setColor(thisMsg.msgType.color);
+                t.marginTop(5);
+
+                t.table(Tex.whiteui, tt -> {
+                    tt.color.set(thisMsg.msgType.color);
+
+                    if(msgList.get(finalI).msgType == arcMsgType.chat)
+                        tt.add(getPlayerName(thisMsg)).style(Styles.outlineLabel).left().width(300f);
+                    else
+                        tt.add(thisMsg.msgType.name).style(Styles.outlineLabel).color(thisMsg.msgType.color).left().width(300f);
+
+                    tt.add(formatTime(thisMsg.time)).style(Styles.outlineLabel).color(thisMsg.msgType.color).left().padLeft(20f).width(100f);
+
+                    if(thisMsg.msgLoc.x != -1){
+                        tt.button("♐： " + (int)(thisMsg.msgLoc.x / tilesize) + "," + (int)(thisMsg.msgLoc.y / tilesize), RStyles.logicButton, () -> {
+                            if(Vars.control.input instanceof DesktopInput input){
+                                input.panning = true;
+                            }
+
+                            Core.camera.position.set(thisMsg.msgLoc);
+
+                            MarkerType.mark.at(Tmp.v1.scl(thisMsg.msgLoc.x, thisMsg.msgLoc.y)).color = color;
+                            hide();
+                        }).padLeft(50f).height(24f).width(150f);
+                    }
+
+                    tt.add().growX();
+                    tt.add("    " + (msgList.size - finalI)).style(Styles.outlineLabel).color(thisMsg.msgType.color).padRight(10);
+
+                    tt.button(Icon.copy, Styles.logici, () -> {
+                        Core.app.setClipboardText(thisMsg.message);
+                        ui.announce("已导出本条聊天记录");
+                    }).size(24f).padRight(6);
+                    tt.button(Icon.cancel, Styles.logici, () -> {
+                        msgList.remove(finalI);
+                        build();
+                    }).size(24f);
+
+                }).growX().height(30);
+
+                t.row();
+
+                t.table(tt -> {
+                    tt.left();
+                    tt.marginLeft(4);
+                    tt.setColor(thisMsg.msgType.color);
+                    if(fieldMode) tt.field(thisMsg.message, nodeArea, text -> {
+                    }).growX();
+                    else tt.labelWrap(getPlayerMsg(thisMsg)).growX();
+                }).pad(4).padTop(2).growX().grow();
+
+                t.marginBottom(7);
+            }).growX().maxWidth(1000f).padBottom(15f).row();
+        }
+    }
+
+    private String getPlayerName(advanceMsg msgElement){
+        int typeStart = msgElement.message.indexOf("[coral][");
+        int typeEnd = msgElement.message.indexOf("[coral]]");
+        if(typeStart == -1 || typeEnd == -1 || typeEnd <= typeStart){
+            return msgElement.msgType.name;
+        }
+
+        return msgElement.message.substring(typeStart + 20, typeEnd);
+    }
+
+    private String getPlayerMsg(advanceMsg msgElement){
+        if(msgElement.msgType != arcMsgType.normal) return msgElement.message;
+        int typeStart = msgElement.message.indexOf("[coral][");
+        int typeEnd = msgElement.message.indexOf("[coral]]");
+        if(typeStart == -1 || typeEnd == -1 || typeEnd <= typeStart){
+            return msgElement.message;
+        }
+        return msgElement.message.substring(typeEnd + 9);
+    }
+
+    private void arcMsgSettingTable(){
+        BaseDialog setDialog = new BaseDialog("中央监控室-设置");
+        if(Core.settings.getInt("maxMsgRecorded") == 0) Core.settings.put("maxMsgRecorded", 500);
+
+        setDialog.cont.table(t -> {
+
+            t.check("停止识别标记等交互信息", ignoreMark, a -> ignoreMark = !ignoreMark).left().width(300f);
+            t.row();
+
+            t.check("信息编辑模式", fieldMode, a -> {
+                fieldMode = a;
+                build();
+            }).left().width(200f);
+            t.row();
+
+            t.add("调整显示的信息").height(50f);
+            t.row();
+            t.table(tt -> {
+                tt.button("关闭全部", cleart, () -> {
+                    for(arcMsgType type : arcMsgType.values()) type.show = false;
+                }).width(200f).height(50f);
+                tt.button("默认", cleart, () -> {
+                    for(arcMsgType type : arcMsgType.values()) type.show = true;
+                    arcMsgType.serverTips.show = false;
+                }).width(200f).height(50f);
+            });
+            t.row();
+            t.table(Tex.button, tt -> tt.pane(tp -> {
+                for(arcMsgType type : arcMsgType.values()){
+
+                    CheckBox box = new CheckBox("[#" + type.color.toString() + "]" + type.name);
+
+                    box.update(() -> box.setChecked(type.show));
+                    box.changed(() -> {
+                        type.show = !type.show;
+                        build();
+                    });
+
+                    box.left();
+                    tp.add(box).left().padTop(3f).row();
+                }
+            }).maxHeight(500).width(400f));
+        });
+
+        setDialog.cont.row();
+
+        setDialog.cont.table(t -> {
+            t.add("最大储存聊天记录(过高可能导致卡顿)：");
+            t.field(maxMsgRecorded + "", text -> {
+                int record = Math.min(Math.max(Integer.parseInt(text), 1), 9999);
+                maxMsgRecorded = record;
+                Core.settings.put("maxMsgRecorded", record);
+            }).valid(Strings::canParsePositiveInt).width(200f).get();
+            t.row();
+            t.add("超出限制的聊天记录将在载入地图时清除");
+        });
+
+        setDialog.addCloseButton();
+        setDialog.button("刷新", Icon.refresh, this::build);
+
+        setDialog.show();
+    }
+
+    public String formatTime(Date time){
+        return new SimpleDateFormat("HH:mm:ss", Locale.US).format(time);
+    }
+
+    public void resolveMsg(String message, @Nullable Player playersender){
+        if(!ignoreMark){
+            if(resolveMarkMsg(message, playersender)) return;
+            if(arcChatPicture.resolveMessage(message, playersender)) return;
+            if(arcui.MusicDialog.resolveMsg(message, playersender)) return;
+            if(ui.schematics.resolveSchematic(message, playersender)) return;
+
+            if(playersender != null){
+                addMsg(new MessageDialog.advanceMsg(MessageDialog.arcMsgType.chat, message, playersender.name(), new Vec2(playersender.x, playersender.y)));
+                return;
+            }
+            if(resolveServerMsg(message)) return;
+        }
+        addMsg(new MessageDialog.advanceMsg(MessageDialog.arcMsgType.normal, message));
+    }
+
+    public boolean resolveMarkMsg(String message, @Nullable Player playersender){
+        //除了markType以外的内容
+        if(message.contains("<ARC")){
+            if(message.contains("标记了") && message.contains("Wave")){
+                addMsg(new MessageDialog.advanceMsg(arcMsgType.markWave, message));
+                return true;
+            }else if(message.contains("标记了") && message.contains("Content")){
+                addMsg(new MessageDialog.advanceMsg(arcMsgType.markContent, message));
+                return true;
+            }else if(message.contains("<AT>")){
+                addMsg(new MessageDialog.advanceMsg(arcMsgType.markPlayer, message));
+                if(message.substring(message.indexOf("AT")).contains(player.name)){
+                    if(playersender != null)
+                        ui.announce("[gold]你被[white] " + playersender.name + " [gold]戳了一下，请注意查看信息框哦~", 10);
+                    else ui.announce("[orange]你被戳了一下，请注意查看信息框哦~", 10);
+                }
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean resolveServerMsg(String message){
+        Seq<String> serverMsg = Seq.with("加入了服务器", "离开了服务器", "自动存档完成", "登录成功", "经验+", "[YELLOW]本局游戏时长:", "[YELLOW]单人快速投票", "[GREEN]回档成功",
+        "[YELLOW]PVP保护时间, 全力进攻吧", "[YELLOW]发起", "[YELLOW]你可以在投票结束前使用", "[GREEN]投票成功", "[GREEN]换图成功,当前地图",
+        "[RED]本地图禁用单位", "[RED]该地图限制空军,禁止进入敌方领空", "[yellow]本地图限制空军", "[YELLOW]火焰过多造成服务器卡顿,自动关闭火焰",
+        " [GREEN]====", "[RED]无效指令", "[RED]该技能", "切换成功",
+        "[violet][投票系统][]", "[coral][-]野生的", "[CYAN][+]野生的"   // xem相关
+        );
+        for(int i = 0; i < serverMsg.size; i++){
+            if(message.contains(serverMsg.get(i))){
+                addMsg(new MessageDialog.advanceMsg(arcMsgType.serverMsg, message));
+                return true;
+            }
+        }
+
+        if(message.contains("小贴士")){
+            addMsg(new MessageDialog.advanceMsg(arcMsgType.serverTips, message));
+            return true;
+        }
+        if(message.contains("[acid][公屏][white]")){
+            addMsg(new MessageDialog.advanceMsg(arcMsgType.serverToast, message));
+            return true;
+        }
+        if(message.contains("[YELLOW][技能]")){
+            addMsg(new MessageDialog.advanceMsg(arcMsgType.serverSkill, message));
+            return true;
+        }
+
+        return false;
+    }
+
+    public static void addMsg(advanceMsg msg){
+        msgList.add(msg);
+    }
+
+    private void clearMsg(){
+        msgList.clear();
+    }
+
+    private void limitMsg(int maxMsg){
+        // 限制信息数量
+        while(true){
+            if(msgList.size < maxMsg) return;
+            msgList.remove(0);
+        }
+    }
+
+    void exportMsg(){
+        StringBuilder messageHis = new StringBuilder();
+        messageHis.append("下面是[MDTX").append(Version.mdtXBuild).append("] 导出的游戏内聊天记录").append("\n");
+        messageHis.append("*** 当前地图名称: ").append(state.map.name()).append("（模式：").append(state.rules.modeName).append("）\n");
+        messageHis.append("*** 当前波次: ").append(state.wave).append("\n");
+
+        StringBuilder messageLs = new StringBuilder();
+        int messageCount = 0;
+        for(int i = 0; i < msgList.size; i++){
+            String msg = msgList.get(i).message;
+            messageLs.insert(0, msg + "\n");
+            messageCount += 1;
+        }
+
+        messageHis.append("成功选取共 ").append(messageCount).append(" 条记录，如下：\n");
+        messageHis.append(messageLs);
+        Core.app.setClipboardText(Strings.stripGlyphs(Strings.stripColors(messageHis.toString())));
+    }
+
+    public static class advanceMsg{
+        public arcMsgType msgType;
+        public String message;
+        public Date time;
+        public String sender;
+        public boolean selected;
+        public Vec2 msgLoc;
+
+        public advanceMsg(arcMsgType msgType, String message, Date time, String sender, Vec2 msgLoc){
+            this.msgType = msgType;
+            this.message = message;
+            this.time = time;
+            this.sender = sender;
+            this.msgLoc = new Vec2().set(msgLoc);
+        }
+
+        public advanceMsg(arcMsgType msgType, String message, String sender, Vec2 msgLoc){
+            this(msgType, message, new Date(), sender, msgLoc);
+        }
+
+        public advanceMsg(arcMsgType msgType, String message, Vec2 msgLoc){
+            this(msgType, message, "null", msgLoc);
+        }
+
+        public advanceMsg(arcMsgType msgType, String message){
+            this(msgType, message, new Vec2(-1, -1));
+        }
+
+
+        public advanceMsg sendMessage(){
+            ui.chatfrag.addMessage(msgType.arcMsgPreFix() + message);
+            return this;
+        }
+    }
+
+    public enum arcMsgType{
+        normal("消息", Color.gray),
+
+        chat("聊天", Color.valueOf("#778899")),
+        console("指令", Color.gold),
+
+        markLoc("标记", "坐标", Color.valueOf("#7FFFD4")),
+        markWave("标记", "波次", Color.valueOf("#7FFFD4")),
+        markContent("标记", "内容", Color.valueOf("#7FFFD4")),
+        markPlayer("标记", "玩家", Color.valueOf("#7FFFD4")),
+        arcChatPicture("分享", "图片", Color.yellow),
+        music("分享", "音乐", Color.pink),
+        schematic("分享", "蓝图", Color.blue),
+        district("规划区", "", Color.violet),
+
+        serverTips("服务器", "小贴士", Color.valueOf("#98FB98"), false),
+        serverMsg("服务器", "信息", Color.valueOf("#cefdce")),
+        serverToast("服务器", "通报", Color.valueOf("#00FA9A")),
+        serverSkill("服务器", "技能", Color.valueOf("#e6ffcc")),
+
+        logicNotify("逻辑", "通报", Color.valueOf("#ffccff")),
+        logicAnnounce("逻辑", "公告", Color.valueOf("#ffccff")),
+
+        eventWorldLoad("事件", "载入地图", Color.valueOf("#ff9999")),
+        eventCoreDestory("事件", "核心摧毁", Color.valueOf("#ffcccc")),
+        eventWave("事件", "波次", Color.valueOf("#ffcc99"));
+
+        public final String name;
+        public final String type;
+        public final String subClass;
+        public Color color = Color.gray;
+        public Boolean show = true;
+
+        arcMsgType(String type, String subClass, Color color, Boolean show){
+            this.name = subClass == "" ? type : (type + "~" + subClass);
+            this.type = type;
+            this.subClass = subClass;
+            this.color = color;
+            this.show = show;
+        }
+
+        arcMsgType(String type, String subClass, Color color){
+            this(type, subClass, color, true);
+        }
+
+        arcMsgType(String type, Color color){
+            this(type, "", color);
+        }
+
+        public String arcMsgPreFix(){
+            return "[#" + color.toString() + "]" + "[" + name + "][]";
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/core/src/mindustry/arcModule/ui/dialogs/MusicDialog.java b/core/src/mindustry/arcModule/ui/dialogs/MusicDialog.java
new file mode 100644
index 0000000000000000000000000000000000000000..8b58218482af774f5b5b1a1113342ff144eb59db
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/dialogs/MusicDialog.java
@@ -0,0 +1,1354 @@
+package mindustry.arcModule.ui.dialogs;
+
+import arc.*;
+import arc.audio.*;
+import arc.files.*;
+import arc.func.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.input.*;
+import arc.math.*;
+import arc.math.geom.*;
+import arc.scene.event.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.Timer;
+import arc.util.*;
+import arc.util.serialization.*;
+import mindustry.*;
+import mindustry.arcModule.*;
+import mindustry.arcModule.ui.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+
+import javax.crypto.*;
+import javax.crypto.spec.*;
+import java.math.*;
+import java.net.*;
+import java.security.*;
+import java.security.interfaces.*;
+import java.security.spec.*;
+import java.util.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.arcModule.RFuncs.getPrefix;
+
+public class MusicDialog extends BaseDialog{
+    public static final String version = "1.2.4";
+    public static final String ShareType = "[pink]<Music>";
+    public float vol;
+    public Music player, sounds;
+    private static final String E = "UTF-8";
+    private static final Seq<MusicApi> apis = new Seq<>();
+    private final Seq<MusicList> lists = new Seq<>();
+    private Table lrcTable;
+    private MusicApi api;
+    private Runnable loadStatus;
+    private float progress;
+    private Slider progressBar;
+    private MusicInfo nowMusic;
+    private boolean loaded, updating, paused, playing;
+    private BaseDialog switchDialog;
+    private float fontScale = 1f;
+    private String lrcColor, nextLrcColor, lrcLine1 = "松鼠音乐", lrcLine2 = "松鼠音乐";
+    private LYRIC lyric;
+    private Dialog settingsDialog;
+    private ListDialog listDialog;
+    private MusicList list;
+    private MessageDigest md5;
+    private Fi tmpDir;
+
+    public MusicDialog(){
+        super("松鼠音乐");
+        try{
+            md5 = MessageDigest.getInstance("MD5");
+            nowMusic = new MusicInfo();
+            progress = 0;
+            addApi(null);
+            addApi(new Squirrel());
+            addApi(new KuGouWeb());
+            try{
+                addApi(new NetEaseMusic());
+            }catch(Exception ignored){
+                addApi(null);
+            }
+            api = apis.get(2);
+            list = lists.get(2);
+            addCloseButton();
+            settingsDialog = new SettingsDialog();
+            listDialog = new ListDialog();
+            buttons.button("切换api", this::switchApi);
+            buttons.button("立即结束音乐", Icon.cancel, () -> {
+                player.stop();
+                player.setVolume(0);
+                player.pause(true);
+                player.setPosition(0);
+                player.dispose();
+                sounds.stop();
+                sounds.setVolume(0);
+                sounds.pause(true);
+                sounds.setPosition(0);
+                sounds.dispose();
+                player = new Music();
+                sounds = new Music();
+            });
+            buttons.row();
+            buttons.button("上传本地音乐", this::upload).disabled(b -> !api.canUpload);
+            buttons.button("歌单", () -> listDialog.show());
+            buttons.button(Icon.settings, () -> settingsDialog.show());
+            onResize(this::setup);
+            shown(() -> {
+                if(check()) setup();
+            });
+            player = new Music();
+            sounds = new Music();
+            vol = Core.settings.getFloat("musicVolume", 100f);
+            player.setVolume(vol / 100 * 2);
+            sounds.setVolume(vol / 100 * 2);
+            loaded = true;
+            setup();
+            switchDialog = new BaseDialog("切换api");
+            switchDialog.cont.label(() -> "当前api: (" + api.thisId + ")" + api.name);
+            switchDialog.cont.row();
+            switchDialog.cont.pane(p -> {
+                for(MusicApi a : apis){
+                    if(a != null){
+                        byte id = a.thisId;
+                        String name = a.name;
+                        p.button("(" + id + ")" + name, () -> {
+                            api = apis.get(id);
+                            list = lists.get(id);
+                            setup();
+                            switchDialog.hide();
+                        }).width(200f);
+                        p.row();
+                    }
+                }
+            }).growX().growY();
+            switchDialog.addCloseButton();
+            fontScale = Core.settings.getFloat("lrcFontScale", 1);
+            lrcColor = "[" + Core.settings.getString("lrcColor", "blue") + "]";
+            nextLrcColor = "[" + Core.settings.getString("nextLrcColor", "white") + "]";
+            buildLRC();
+            Events.run(EventType.Trigger.update, this::updateProgress);
+            netClient.addPacketHandler("forceAudio", url -> {
+                if(Core.settings.getBool("arcShareMedia") && MessageDialog.arcMsgType.music.show) Http.get(url, r -> {
+                    try{
+                        Fi tmp = tmpDir.child("server.mp3");
+                        tmp.writeBytes(r.getResult());
+                        sounds.load(tmp);
+                        sounds.play();
+                    }catch(Exception ignored){
+                    }
+                });
+            });
+            netClient.addPacketHandler("stopAudio", url -> sounds.stop());
+
+        }catch(Exception ignored){
+        }
+    }
+
+    public void addApi(MusicApi api){
+        apis.add(api);
+        lists.add(api == null ? null : new MusicList(api.thisId));
+    }
+
+    private void buildLRC(){
+        if(lrcTable != null) lrcTable.remove();
+        if(Core.settings.getBool("showLRC")){
+            lrcTable = new LRCTable();
+            Core.scene.add(lrcTable);
+        }
+    }
+
+    private void switchApi(){
+        switchDialog.show();
+    }
+
+    private boolean check(){
+        if(!loaded){
+            cont.clear();
+            cont.add("[red]松鼠音乐加载失败");
+        }
+        return loaded;
+    }
+
+    private void play(MusicInfo info){
+        stop();
+        nowMusic = info;
+        api = apis.get(info.src);
+        list = lists.get(info.src);
+        list.add(info);
+        list.set(list.indexOf(info));
+        try{
+            if(info.lrc != null) lyric = info.lrc;
+            else lyric = null;
+            Http.get(info.url, r -> {
+                Fi tmp = tmpDir.child("squirrel.mp3");
+                tmp.writeBytes(r.getResult());
+                player.stop();
+                player.pause(false);
+                player.load(tmp);
+                player.play();
+                Timer.schedule(() -> playing = true, 0.5f);//badly
+                loadStatus.run();
+            });
+        }catch(Exception e){
+            ui.showException("发生了一个错误", e);
+            playNext();
+        }
+    }
+
+    private void playDirectly(Fi f) throws Exception{
+        player.stop();
+        player.pause(false);
+        player.load(f);
+        player.play();
+        Timer.schedule(() -> playing = true, 1);
+        loadStatus.run();
+    }
+
+    private void setup(){
+        if(!loaded) return;
+        tmpDir = tmpDirectory.child("music");
+        tmpDir.mkdirs();
+        tmpDir.emptyDirectory();
+        cont.top();
+        cont.clear();
+        api.build(cont);
+        cont.row();
+        cont.table(t -> loadStatus = () -> {
+            t.clear();
+            t.bottom();
+            float width = Core.graphics.getWidth() / Scl.scl() * 0.9f;
+            t.table(tt -> {
+                tt.left();
+                Table[] img = {null};
+                tt.table(ttt -> img[0] = ttt).size(64).pad(2f);
+                if(nowMusic.imgBuf == null && nowMusic.img != null) Http.get(nowMusic.img, r -> {
+                    Pixmap pix = new Pixmap(r.getResult());
+                    Core.app.post(() -> {
+                        TextureRegion cache = new TextureRegion(new Texture(pix));
+                        nowMusic.imgBuf = cache;
+                        pix.dispose();
+                        img[0].image(cache).size(64);
+                    });
+                });
+                if(nowMusic.imgBuf != null){
+                    img[0].image(nowMusic.imgBuf).size(64);
+                }
+                tt.table(ms -> {
+                    ms.table(ttt -> {
+                        ttt.add(nowMusic.name == null ? "松鼠音乐" : (nowMusic.author + " - " + nowMusic.name)).left().wrap().style(Styles.outlineLabel).growX();
+                        ttt.button(Icon.leftSmall, RStyles.clearLineNonei, this::prev).margin(3f).padTop(6f).top().right().size(32);
+                        ttt.button(Icon.rightSmall, RStyles.clearLineNonei, this::playNext).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                        ttt.button(Icon.play, RStyles.clearLineNonei, this::play).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                        ttt.button(Icon.pause, RStyles.clearLineNonei, this::pause).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                        ttt.button(Icon.downloadSmall, RStyles.clearLineNonei, () -> {
+                            if(nowMusic.url != null){
+                                download(nowMusic);
+                            }
+                        }).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                        ttt.label(() -> "音量:" + (byte)vol);
+                        ttt.button(Icon.upSmall, RStyles.clearLineNonei, () -> {
+                            vol = Math.min(vol + 10, 100);
+                            Core.settings.put("musicVolume", vol);
+                            player.setVolume(vol / 100 * 2);
+                            sounds.setVolume(vol / 100 * 2);
+                        }).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                        ttt.button(Icon.downSmall, RStyles.clearLineNonei, () -> {
+                            vol = Math.max(vol - 10, 0);
+                            Core.settings.put("musicVolume", vol);
+                            player.setVolume(vol / 100 * 2);
+                            sounds.setVolume(vol / 100 * 2);
+                        }).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                        ttt.button(Icon.refreshSmall, RStyles.clearLineNoneTogglei, () -> {
+                            player.setLooping(!player.isLooping());
+                            ui.announce("单曲循环已" + (player.isLooping() ? "开启" : "关闭"), 1f);
+                        }).margin(3f).pad(2).padTop(6f).top().right().checked(b -> player.isLooping()).size(32);
+                        ttt.button(Icon.linkSmall, RStyles.clearLineNonei, () -> {
+                            if(nowMusic.url != null){
+                                apis.get(nowMusic.src).share(nowMusic);
+                            }
+                        }).margin(3f).pad(2).pad(6).top().right().size(32);
+                    }).growX();
+                    ms.row();
+                    progressBar = ms.slider(0.01f, nowMusic.length == 0.0 ? 0.01f : nowMusic.length, 0.01f, f -> {
+                        if(!updating){
+                            player.setPosition(0);
+                            player.setPosition(f);
+                            player.pause(false);
+                            paused = false;
+                        }
+                    }).growX().disabled(s -> nowMusic.length == 0).get();
+                    ms.row();
+                    ms.label(() -> (int)(progress / 60) + ":" + (int)(progress % 60) + (nowMusic.length == 0 ? "" : "/" + (nowMusic.length / 60) + ":" + (nowMusic.length % 60)));
+                }).growX().growY();
+            }).width(width).height(100f);
+        });
+        loadStatus.run();
+    }
+
+    private void updateLRC(double pos){
+        if(lyric == null){
+            lrcLine1 = lrcLine2 = "松鼠音乐";
+            return;
+        }
+        lyric.get(pos, (s1, s2) -> {
+            lrcLine1 = s1;
+            lrcLine2 = s2;
+        });
+    }
+
+    private void play(){
+        if(!player.isPlaying()){
+            if(paused){
+                player.pause(false);
+                paused = false;
+                playing = true;
+            }else{
+                if(nowMusic.url != null){
+                    Fi f = tmpDir.child("squirrel.mp3");
+                    if(f.exists()){
+                        try{
+                            playing = false;
+                            playDirectly(f);
+                        }catch(Exception ignored){
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void pause(){
+        player.pause(true);
+        paused = true;
+        playing = false;
+    }
+
+    private void updateProgress(){
+        if(!loaded) return;
+        updating = true;
+        float pos = player.getPosition();
+        progress = pos;
+        progressBar.setValue(progress);
+        updating = false;
+        updateLRC(pos * 1000);
+        if(pos == 0 && playing && !player.isLooping()){
+            playing = false;
+            playNext();
+        }
+    }
+
+    private void download(MusicInfo info){
+        platform.showFileChooser(false, "下载音乐", "mp3", fi -> api.getInfoOrCall(info, fullInfo -> Http.get(fullInfo.url, r -> {
+            fi.writeBytes(r.getResult());
+            Core.app.post(() -> Vars.ui.showInfo("下载成功"));
+        })));
+    }
+
+    private void upload(){
+        platform.showFileChooser(true, "选择音乐文件", "mp3", f -> {
+            ui.announce("正在上传...\n很慢!(1-2分钟)\n上传完成后会自动播放");
+            api.upload(f, info -> api.getInfoOrCall(info, this::play));
+        });
+    }
+
+    private void loadList(MusicList list){
+        if(list == null) return;
+        this.list = list;
+        list.set(0);
+        playNext(false);
+        listDialog.build();
+    }
+
+    private void stop(){
+        player.stop();
+        playing = false;
+        paused = false;
+    }
+
+    private void playNext(){
+        playNext(true);
+    }
+
+    private void playNext(boolean next){
+        stop();
+        MusicInfo info = next ? list.getNext() : list.currentMusic;
+        playOrStop(info);
+    }
+
+    private void prev(){
+        stop();
+        MusicInfo info = list.getPrev();
+        playOrStop(info);
+    }
+
+    private void playOrStop(MusicInfo info){
+        if(info == null){
+            nowMusic = new MusicInfo();
+            playing = false;
+            loadStatus.run();
+            return;
+        }
+        if(info.url == null) apis.get(info.src).getInfoOrCall(info, this::play);
+        else this.play(info);
+    }
+
+    public boolean resolveMsg(String msg, @Nullable Player sender){
+        if(!Core.settings.getBool("arcShareMedia")) return false;
+        if((!msg.contains(ShareType)) || (!loaded) || (!MessageDialog.arcMsgType.music.show)){
+            return false;
+        }
+        try{
+            MessageDialog.addMsg(new MessageDialog.advanceMsg(MessageDialog.arcMsgType.music, msg));
+            int start = msg.indexOf(' ', msg.indexOf(ShareType) + ShareType.length());
+            int split = msg.indexOf('M', start);
+            String mark = msg.substring(start + 1, split);
+            if(mark.equals("$")){
+                Core.app.post(() -> ui.showConfirm("松鼠音乐", (sender == null ? "" : sender.name) + "分享了一个歌单\n播放?", () -> Http.get("https://pastebin.com/raw/" + msg.substring(split + 1), r -> MusicList.parse(URLDecoder.decode(r.getResultAsString(), E), MusicDialog.this::loadList), e -> Core.app.post(() -> ui.showException(e)))));
+            }else{
+                byte src = Byte.parseByte(mark);
+                String id = msg.substring(split + 1);
+                if(src < 0 || src > apis.size || apis.get(src) == null && src != 0){
+                    Core.app.post(() -> arcui.arcInfo("[red]无法找到api!\n可能是学术版本太旧"));
+                }
+                MusicApi current = apis.get(src);
+                current.getMusicInfo(id, info -> Core.app.post(() -> ui.showConfirm("松鼠音乐", (sender == null ? "" : sender.name) + "分享了一首来自" + current.name + "的音乐" + (info.name == null ? "" : ":\n" + info.author + " - " + info.name) + "\n播放?", () -> current.getInfoOrCall(info, this::play))));
+            }
+        }catch(Exception e){
+            Log.err(e);
+            Core.app.post(() -> arcui.arcInfo("[orange]音乐读取失败"));
+        }
+        return true;
+    }
+
+    public static class MusicInfo{
+        public String name;
+        public String author;
+        public String url;
+        public String img;
+        public TextureRegion imgBuf;
+        public String id;
+        public byte src;
+        public int length;
+        public LRC lrc;
+    }
+
+    public static class MusicSet{
+        public byte count;
+        public MusicInfo[] list;
+
+        public MusicSet(byte length){
+            list = new MusicInfo[length];
+        }
+
+        public void add(MusicInfo m){
+            list[count++] = m;
+        }
+    }
+
+    public abstract static class MusicApi{
+        public String name;
+        public byte thisId;
+        public boolean canUpload;
+
+        public void getMusicInfo(String id, Cons<MusicInfo> callback, MusicInfo src){
+            getMusicInfo(id, callback, false, src);
+        }
+
+        public void getMusicInfo(String str, Cons<MusicInfo> callback){
+            getMusicInfo(str, callback, null);
+        }
+
+        public abstract void getMusicInfo(String id, Cons<MusicInfo> callback, boolean noTip, MusicInfo src);
+
+        public void upload(Fi file, Cons<MusicInfo> callback){
+
+        }
+
+        public abstract void build(Table root);
+
+        public void getInfoOrCall(MusicInfo info, Cons<MusicInfo> cb){
+            getInfoOrCall(info, cb, false);
+        }
+
+        public void getInfoOrCall(MusicInfo info, Cons<MusicInfo> cb, boolean noTip){
+            if(info.url != null){
+                cb.get(info);
+                return;
+            }
+            getMusicInfo(info.id, cb, noTip, info);
+        }
+
+        public void share(MusicInfo info){
+            Vars.ui.showConfirm("分享", "确认分享到聊天框?", () -> getInfoOrCall(info, fullInfo -> Call.sendChatMessage(getPrefix("pink", "Music") + " " + fullInfo.src + "M" + fullInfo.id), true));
+        }
+
+        public void share(MusicList list){
+            if(list.size() == 0) return;
+            Vars.ui.showConfirm("分享", "确认分享到聊天框?", () -> {
+                try{
+                    Http.HttpRequest req = Http.post("https://pastebin.com/api/api_post.php", "api_dev_key=sdBDjI5mWBnHl9vBEDMNiYQ3IZe0LFEk&api_option=paste&api_paste_expire_date=10M&api_paste_code=" + URLEncoder.encode(list.build(), E));
+                    req.submit(r -> {
+                        String code = r.getResultAsString();
+                        Call.sendChatMessage(getPrefix("pink", "Music") + " $M" + code.substring(code.lastIndexOf('/') + 1));
+                    });
+                    req.error(e -> Core.app.post(() -> ui.showException("分享失败", e)));
+                }catch(Exception e){
+                    ui.showException("分享失败", e);
+                }
+            });
+        }
+
+        public void loadList(String str, Cons<MusicList> cb){
+            String[] all = str.split("\\$");
+            MusicList list = new MusicList(thisId);
+            getMusicInfo(all[0], info -> {
+                list.add(info);
+                for(int i = 1; i < all.length; i++) getMusicInfo(all[i], list::add, true, info);
+                cb.get(list);
+            }, true, null);
+        }
+
+        public String buildList(MusicList list){
+            return list.build();
+        }
+    }
+
+    private static class Squirrel extends MusicApi{//松鼠站
+
+        {
+            name = "松鼠站";
+            canUpload = true;
+            thisId = 1;
+        }
+
+        @Override
+        public void getMusicInfo(String rid, Cons<MusicInfo> callback, boolean noTip, MusicInfo src){
+            callback.get(new MusicInfo(){{
+                src = thisId;
+                url = "http://124.220.46.174/api/get?id=" + rid;
+                id = rid;
+            }});
+        }
+
+        @Override
+        public void upload(Fi file, Cons<MusicInfo> callback){
+            RFuncs.uploadToWebID(file, s -> {
+                Core.app.post(() -> ui.announce("上传成功"));
+                callback.get(new MusicInfo(){{
+                    src = thisId;
+                    id = String.valueOf(s);
+                }});
+            });
+        }
+
+        @Override
+        public void build(Table root){
+
+        }
+    }
+
+    private static class LRCParser{
+        public static LRC parse(String input){
+            String[] lrcs = input.replace("\r", "").split("\\n");
+            LRC output = new LRC();
+            if(!input.contains("[00:")){
+                output.add(0, "暂无歌词");
+                return output;
+            }
+            for(String now : lrcs){
+                try{
+                    output.add(parseTime(now), now.substring(10));
+                }catch(Exception ignored){
+                }
+            }
+            return output;
+        }
+
+        private static double parseTime(String raw){
+            double sum = 60 * Math.floor(Double.parseDouble(raw.substring(1, 3))) * 1000;
+            sum += 1000 * Math.floor(Double.parseDouble(raw.substring(4, 6)));
+            sum += 10 * Math.floor(Double.parseDouble(raw.substring(7, 9)));
+            if(Double.isNaN(sum)) sum = 0d;
+            return sum;
+        }
+    }
+
+    public static class LRC extends LYRIC{
+        Seq<Double> timeList;
+        Seq<String> lrcList;
+        int size, cached;
+        double last;
+
+        public LRC(){
+            timeList = new Seq<>();
+            lrcList = new Seq<>();
+            last = 0;
+            cached = 0;
+        }
+
+        public void add(double time, String line){
+            timeList.add(time);
+            lrcList.add(line);
+            size++;
+        }
+
+        public void get(double now, Cons2<String, String> callback){
+            for(int i = now > last ? cached : 0; i < size; i++){
+                if(now > timeList.get(i)){
+                    cached = i;
+                    callback.get(lrcList.get(i), i + 1 == size ? "" : lrcList.get(i + 1));
+                }
+            }
+            last = now;
+        }
+    }
+
+    public static class MusicList{
+        public final Seq<MusicInfo> list = new Seq<>();
+        public byte api;
+        public int current = 0;
+        public MusicInfo currentMusic = new MusicInfo();
+
+        public MusicList(byte api){
+            this.api = api;
+        }
+
+        public static void parse(String input, Cons<MusicList> cb){
+            try{
+                MusicApi api = apis.get(Byte.parseByte(input.substring(0, input.indexOf("$"))));
+                api.loadList(input.substring(input.indexOf("$") + 1), cb);
+            }catch(Exception e){
+                ui.showException(e);
+            }
+        }
+
+        public void add(MusicInfo info){
+            if(indexOf(info) == -1) list.add(info);
+        }
+
+        public boolean remove(int id){
+            list.remove(id);
+            if(id < current){
+                current--;
+            }
+            return id == current;
+        }
+
+        public boolean remove(MusicInfo info){
+            return remove(indexOf(info));
+        }
+
+        public int size(){
+            return list.size;
+        }
+
+        public String build(){
+            StringBuilder sb = new StringBuilder();
+            sb.append(api).append("$");
+            for(MusicInfo musicInfo : list){
+                sb.append(musicInfo.id).append("$");
+            }
+            sb.deleteCharAt(sb.length() - 1);
+            return sb.toString();
+        }
+
+        public MusicInfo get(int id){
+            return list.get(id);
+        }
+
+        public MusicInfo getNext(){
+            if(++current >= list.size) return null;
+            current = Math.min(current, list.size - 1);
+            return update();
+        }
+
+        public MusicInfo getPrev(){
+            current = Math.max(current - 1, 0);
+            return update();
+        }
+
+        public void set(int id){
+            if(id >= list.size) return;
+            current = id;
+            update();
+        }
+
+        private MusicInfo update(){
+            return currentMusic = current >= size() ? null : list.get(current);
+        }
+
+        public int indexOf(MusicInfo info){
+            for(int i = 0; i < list.size; i++){
+                if(Objects.equals(list.get(i).id, info.id)) return i;
+            }
+            return -1;
+        }
+    }
+
+    public static abstract class LYRIC{
+        public abstract void add(double time, String line);
+
+        public abstract void get(double now, Cons2<String, String> callback);
+    }
+
+    private class ListDialog extends BaseDialog{
+        public ListDialog(){
+            super("歌单列表");
+            buttons.button(Icon.trash, () -> ui.showConfirm("松鼠音乐", "是否清空歌单", () -> {
+                list = new MusicList((byte)0);
+                build();
+            }));
+            build();
+            buttons.button(Icon.link, () -> apis.get(list.api).share(list)).disabled(b -> list.size() == 0);
+            buttons.button(Icon.download, () -> platform.showFileChooser(false, "保存歌单文件", "list", f -> f.writeString(api.buildList(list)))).disabled(b -> list.size() == 0);
+            buttons.button(Icon.upload, () -> platform.showFileChooser(true, "加载歌单文件", "list", f -> MusicList.parse(f.readString(), i -> Core.app.post(() -> MusicDialog.this.loadList(i)))));
+            addCloseButton();
+            onResize(this::build);
+            shown(this::build);
+        }
+
+        public void build(){
+            cont.clear();
+            float width = Core.graphics.getWidth() / Scl.scl() * 0.9f;
+            for(MusicInfo info : list.list){
+                Button[] buttons = {null};
+                Button button = buttons[0] = cont.button(b -> {
+                }, RStyles.clearLineNonei, () -> {
+                    if(!buttons[0].childrenPressed()){
+                        MusicDialog.this.play(info);
+                    }
+                }).width(width).pad(2f).get();
+                Table inner = new Table(Tex.whiteui);
+                inner.setColor(Color.black);
+                button.clearChildren();
+                button.add(inner).growX();
+                inner.add(info.author + " - " + info.name).left().padLeft(10f).wrap().style(Styles.outlineLabel).growX();
+                inner.button(Icon.trash, RStyles.clearLineNonei, () -> {
+                    if(list.remove(info)){
+                        playNext();
+                    }
+                    build();
+                }).margin(3f).pad(2).padTop(6f).top().right();
+                inner.button(Icon.download, RStyles.clearLineNonei, () -> download(info)).margin(3f).pad(2).padTop(6f).top().right();
+                inner.button(Icon.link, RStyles.clearLineNonei, () -> apis.get(info.src).share(info)).margin(3f).pad(2).pad(6).top().right();
+                button.row();
+                button.update(() -> button.setChecked(Objects.equals(list.currentMusic.id, nowMusic.id)));
+                cont.row();
+            }
+        }
+    }
+
+    public abstract class NetApi extends MusicApi{
+        int searchPage = 1, allPage = 1;
+        Table menu;
+        String queryString = "";
+        TextField searchUI;
+
+        public abstract void getTips(String str, Cons<String[]> cb);
+
+        @Override
+        public void build(Table root){
+            root.table(s -> {
+                s.top();
+                searchUI = s.field(queryString, res -> getTips(queryString = res, st -> Core.app.post(() -> loadSearchTips(st)))).growX().get();
+                s.button(Icon.zoom, () -> {
+                    searchPage = 1;
+                    search();
+                });
+            }).fillX().padBottom(4);
+            root.row();
+            menu = root.table().growY().get();
+        }
+
+        public abstract void search(String name, int page, Cons<MusicSet> callback);
+
+        private void search(){
+            search(queryString, searchPage, s -> Core.app.post(() -> loadSearchResult(s)));
+        }
+
+        private void loadSearchTips(String[] tips){
+            menu.clear();
+            menu.pane(t -> {
+                float width = Core.graphics.getWidth() / Scl.scl() * 0.9f;
+                t.top();
+                for(String str : tips){
+                    t.button(str, RStyles.flatt, () -> {
+                        searchUI.setText(queryString = str);
+                        search();
+                    }).width(width);
+                    t.row();
+                }
+            });
+        }
+
+        private void loadSearchResult(MusicSet m){
+            menu.clear();
+            menu.pane(t -> {
+                t.top();
+                if(m.count > 0){
+                    float width = Core.graphics.getWidth() / Scl.scl() * 0.9f;
+                    t.clear();
+                    for(byte i = 0; i < m.count; i++){
+                        MusicInfo info = m.list[i];
+                        Button[] buttons = {null};
+                        Button button = buttons[0] = t.button(b -> {
+                        }, () -> {
+                            if(!buttons[0].childrenPressed()){
+                                api.getInfoOrCall(info, MusicDialog.this::play);
+                            }
+                        }).width(width).pad(2f).get();
+                        Table inner = new Table(Tex.whiteui);
+                        inner.setColor(Color.black);
+                        button.clearChildren();
+                        button.add(inner).growX();
+                        inner.add(info.author + " - " + info.name).left().padLeft(10f).wrap().style(Styles.outlineLabel).growX();
+                        inner.button(Icon.download, RStyles.clearLineNonei, () -> download(info)).margin(3f).pad(2).padTop(6f).top().right();
+                        inner.button(Icon.link, RStyles.clearLineNonei, () -> share(info)).margin(3f).pad(2).pad(6).top().right();
+                        button.row();
+                        t.row();
+                    }
+                    t.table(tt -> {
+                        tt.button(Icon.left, () -> {
+                            searchPage--;
+                            search();
+                        }).height(50f).width(150f).disabled(b -> searchPage <= 1);
+                        tt.add(searchPage + "/" + allPage);
+                        tt.button(Icon.right, () -> {
+                            searchPage++;
+                            search();
+                        }).height(50f).width(150f).disabled(b -> searchPage >= allPage);
+                    });
+                }
+            }).growY();
+        }
+    }
+
+    private class KuGouWeb extends NetApi{
+        String uuid;
+
+        {
+            name = "酷狗网页版";
+            canUpload = false;
+            thisId = 2;
+            uuid = Core.settings.getString("kguuid");
+            if(uuid == null){
+                byte[] buf = new byte[8];
+                new Rand().nextBytes(buf);
+                StringBuilder sb = new StringBuilder();
+                byte[] result = md5.digest(buf);
+                for(byte b : result){
+                    sb.append(String.format("%02x", b));
+                }
+                uuid = sb.toString();
+                Core.settings.put("kguuid", sb.toString());
+            }
+        }
+
+        @Override
+        public void getMusicInfo(String id, Cons<MusicInfo> callback, boolean noTip, MusicInfo src){
+            Http.HttpRequest req = Http.get("https://wwwapi.kugou.com/yy/index.php?r=play/getdata&encode_album_audio_id=" + id);
+            req.header("Cookie", "kg_mid=" + uuid);
+            req.submit(res -> {
+                JsonValue j = new JsonReader().parse(res.getResultAsString());
+                if(j.getByte("status") == 0){
+                    Core.app.post(() -> Vars.ui.showErrorMessage("此歌曲无法播放:\nKuGou Error: (" + j.getLong("err_code") + ")"));
+                    return;
+                }
+                JsonValue data = j.get("data");
+                if(data.getString("play_url").contains("clip") && !noTip){
+                    Core.app.post(() -> Vars.ui.showConfirm("此歌曲为vip歌曲 仅支持播放部分", () -> callback.get(new MusicInfo(){{
+                        name = data.getString("song_name");
+                        author = data.getString("author_name");
+                        url = data.getString("play_url");
+                        img = data.getString("img");
+                        id = data.getString("encode_album_audio_id");
+                        src = thisId;
+                        length = data.getInt("timelength") / 1000;
+                        lrc = LRCParser.parse(data.getString("lyrics"));
+                    }})));
+                }else{
+                    callback.get(new MusicInfo(){{
+                        name = data.getString("song_name");
+                        author = data.getString("author_name");
+                        url = data.getString("play_url");
+                        img = data.getString("img");
+                        id = data.getString("encode_album_audio_id");
+                        src = thisId;
+                        length = data.getInt("timelength") / 1000;
+                        lrc = LRCParser.parse(data.getString("lyrics"));
+                    }});
+                }
+            });
+        }
+
+        @Override
+        public void search(String name, int page, Cons<MusicSet> callback){
+            try{
+                long timestamp = new Date().getTime();
+                String data = "NVPh5oo715z5DIWAeQlhMDsWXXQV4hwtappid=1014bitrate=0clienttime=" + timestamp + "clientver=1000dfid=-filter=10inputtype=0iscorrection=1isfuzzy=0keyword=" + name + "mid=" + uuid + "page=" + page + "pagesize=10platform=WebFilterprivilege_filter=0srcappid=2919userid=0uuid=" + uuid + "NVPh5oo715z5DIWAeQlhMDsWXXQV4hwt";
+                byte[] result = md5.digest(data.getBytes(E));
+                StringBuilder sb = new StringBuilder();
+                for(byte b : result){
+                    sb.append(String.format("%02x", b));
+                }
+                Http.get("https://complexsearch.kugou.com/v2/search/song?appid=1014&bitrate=0&clienttime=" + timestamp + "&clientver=1000&dfid=-&filter=10&inputtype=0&iscorrection=1&isfuzzy=0&keyword=" + URLEncoder.encode(name, E) + "&mid=" + uuid + "&page=" + page + "&pagesize=10&platform=WebFilter&privilege_filter=0&srcappid=2919&userid=0&uuid=" + uuid + "&signature=" + sb, res -> {
+                    JsonValue j = new JsonReader().parse(res.getResultAsString());
+                    if(j.getLong("error_code") != 0){
+                        Core.app.post(() -> Vars.ui.showErrorMessage("搜索出错:\nKuGou Error: (" + j.getLong("error_code") + ") " + j.getString("error_msg")));
+                        return;
+                    }
+                    JsonValue lists = j.get("data").get("lists");
+                    allPage = j.get("data").getInt("total") / 10 + 1;
+                    MusicSet set = new MusicSet((byte)10);
+                    for(byte i = 0; i < 10; i++){
+                        JsonValue thisMusic = lists.get(i);
+                        if(thisMusic == null){
+                            break;
+                        }
+                        set.add(new MusicInfo(){{
+                            name = thisMusic.getString("SongName");
+                            author = thisMusic.getString("SingerName");
+                            id = thisMusic.getString("EMixSongID");
+                            src = thisId;
+                        }});
+                    }
+                    callback.get(set);
+                });
+            }catch(Exception e){
+                Core.app.post(() -> ui.showException("搜索出错!", e));
+            }
+        }
+
+        @Override
+        public void getTips(String str, Cons<String[]> cb){
+            try{
+                Http.get("https://searchtip.kugou.com/getSearchTip?MusicTipCount=10&MVTipCount=0&albumcount=0&keyword=" + URLEncoder.encode(str, E), r -> {
+                    JsonValue j = new JsonReader().parse(r.getResultAsString());
+                    if(j.getByte("status") != 1) return;
+                    int count = j.get("data").get(0).getInt("RecordCount");
+                    JsonValue all = j.get("data").get(0).get("RecordDatas");
+                    String[] list = new String[count];
+                    for(int i = 0; i < count; i++){
+                        list[i] = all.get(i).getString("HintInfo");
+                    }
+                    cb.get(list);
+                });
+            }catch(Exception ignored){
+            }
+        }
+    }
+
+    private class NetEaseMusic extends NetApi{
+        NetEastEncryptor encryptor = new NetEastEncryptor();
+
+        {
+            name = "网易云网页版";
+            canUpload = false;
+            thisId = 3;
+        }
+
+        @Override
+        public void getMusicInfo(String id, Cons<MusicInfo> callback, boolean noTip, MusicInfo raw){
+            Http.HttpRequest req = Http.post("https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=");
+            try{
+                encryptor.encryptRequest(req, "{\"ids\":\"[" + id + "]\",\"level\":\"standard\",\"encodeType\":\"mp3\",\"csrf_token\":\"\"}");
+            }catch(Exception e){
+                ui.showException("获取歌曲信息错误", e);
+            }
+            req.submit(r -> {
+                JsonValue j = new JsonReader().parse(r.getResultAsString());
+                if(j.getInt("code") != 200){
+                    Core.app.post(() -> ui.showErrorMessage("网易云状态码错误:\n" + j.getInt("code")));
+                }
+                JsonValue data = j.get("data").get(0);
+                if(data.getInt("code") != 200){
+                    Core.app.post(() -> ui.showInfo("此歌曲为vip专属 无法播放"));
+                    return;
+                }
+                Http.HttpRequest lr = Http.post("https://music.163.com/weapi/song/lyric?csrf_token=");
+                encryptor.encryptRequest(lr, "{\"id\":" + data.getString("id") + ",\"lv\":-1,\"tv\":-1,\"csrf_token\":\"\"}");
+                lr.submit(rr -> {
+                    JsonValue lrcData = new JsonReader().parse(rr.getResultAsString());
+                    if(lrcData.getInt("code") != 200 || !lrcData.get("lrc").has("lyric")){
+                        if(raw == null) callback.get(new MusicInfo(){{
+                            name = data.getString("name");
+                            url = data.getString("url");
+                            id = data.getString("id");
+                            src = thisId;
+                            length = data.getInt("time") / 1000;
+                        }});
+                        else callback.get(new MusicInfo(){{
+                            name = raw.name;
+                            author = raw.author;
+                            url = data.getString("url");
+                            id = data.getString("id");
+                            src = thisId;
+                            length = data.getInt("time") / 1000;
+                        }});
+                    }
+                    if(raw == null) callback.get(new MusicInfo(){{
+                        name = data.getString("name");
+                        url = data.getString("url");
+                        id = data.getString("id");
+                        src = thisId;
+                        lrc = LRCParser.parse(lrcData.get("lrc").getString("lyric"));
+                        length = data.getInt("time") / 1000;
+                    }});
+                    else callback.get(new MusicInfo(){{
+                        name = raw.name;
+                        author = raw.author;
+                        url = data.getString("url");
+                        id = data.getString("id");
+                        src = thisId;
+                        lrc = LRCParser.parse(lrcData.get("lrc").getString("lyric"));
+                        length = data.getInt("time") / 1000;
+                    }});
+                });
+            });
+        }
+
+        @Override
+        public void search(String name, int page, Cons<MusicSet> callback){
+            try{
+                Http.HttpRequest req = Http.post("https://music.163.com/weapi/cloudsearch/get/web?csrf_token=");
+                encryptor.encryptRequest(req, "{\"s\":\"" + name.replace("\\", "\\\\").replace("\"", "\\\"") + "\",\"type\":\"1\",\"offset\":\"0\",\"total\":\"true\",\"limit\":\"30\",\"csrf_token\":\"\"}");
+                req.submit(res -> {
+                    try{
+                        JsonValue j = new JsonReader().parse(res.getResultAsString());
+                        if(j.getInt("code") != 200){
+                            Core.app.post(() -> Vars.ui.showErrorMessage("搜索出错:\n网易云 Error: (" + j.getInt("code") + ") "));
+                            return;
+                        }
+                        JsonValue lists = j.get("result").get("songs");
+                        allPage = 1;
+                        MusicSet set = new MusicSet((byte)30);
+                        for(byte i = 0; i < 30; i++){
+                            JsonValue thisMusic = lists.get(i);
+                            if(thisMusic == null){
+                                break;
+                            }
+                            StringBuilder sb = new StringBuilder();
+                            int l = thisMusic.get("ar").size;
+                            JsonValue ar = thisMusic.get("ar");
+                            for(int k = 0; k < l; k++){
+                                sb.append(ar.get(k).getString("name")).append("/");
+                            }
+                            if(sb.length() != 0) sb.deleteCharAt(sb.length() - 1);
+                            set.add(new MusicInfo(){{
+                                name = thisMusic.getString("name");
+                                author = sb.toString();
+                                id = thisMusic.getString("id");
+                                src = thisId;
+                            }});
+                        }
+                        callback.get(set);
+                    }catch(Exception e){
+                        Core.app.post(() -> ui.showException("搜索出错!", e));
+                    }
+                });
+            }catch(Exception e){
+                ui.showException("搜索出错!", e);
+            }
+        }
+
+        @Override
+        public void getTips(String str, Cons<String[]> cb){
+            try{
+                Http.HttpRequest req = Http.post("https://music.163.com/weapi/search/suggest/web?csrf_token=");
+                encryptor.encryptRequest(req, "{\"s\":\"" + str.replace("\\", "\\\\").replace("\"", "\\\"") + "\",\"limit\":\"10\",\"csrf_token\":\"\"}");
+                req.submit(r -> {
+                    JsonValue j = new JsonReader().parse(r.getResultAsString());
+                    if(j.getInt("code") != 200) return;
+                    JsonValue all = j.get("result").get("songs");
+                    int count = all.size;
+                    String[] list = new String[count];
+                    for(int i = 0; i < count; i++){
+                        list[i] = all.get(i).getString("name");
+                    }
+                    cb.get(list);
+                });
+            }catch(Exception ignored){
+            }
+        }
+
+        @Override
+        public void loadList(String str, Cons<MusicList> cb){
+            String[] all = str.split("\uf71d");
+            MusicList list = new MusicList(thisId);
+            for(String s : all){
+                String[] args = s.split("\uf6aa");
+                try{
+                    list.add(new MusicInfo(){{
+                        src = thisId;
+                        id = args[0];
+                        name = URLDecoder.decode(args[1], E);
+                        author = URLDecoder.decode(args[2], E);
+                    }});
+                }catch(Exception ignored){
+                }
+            }
+            cb.get(list);
+        }
+
+        @Override
+        public String buildList(MusicList list){
+            StringBuilder sb = new StringBuilder();
+            sb.append(thisId).append("$");
+            try{
+                for(MusicInfo musicInfo : list.list){
+                    sb.append(musicInfo.id).append("\uf6aa").append(URLEncoder.encode(musicInfo.name, E)).append("\uf6aa").append(URLEncoder.encode(musicInfo.author, E)).append("\uf71d");
+                }
+            }catch(Exception ignored){
+            }
+            sb.deleteCharAt(sb.length() - 1);
+            return sb.toString();
+        }
+
+        @Override
+        public void share(MusicInfo info){
+            Vars.ui.showConfirm("分享", "确认分享到聊天框?", () -> getInfoOrCall(info, fullInfo -> {
+                try{
+                    Call.sendChatMessage(getPrefix("pink", "Music") + " " + fullInfo.src + "M" + fullInfo.id + "\uf6aa" + URLEncoder.encode(fullInfo.name, E) + "\uf6aa" + URLEncoder.encode(fullInfo.author, E));
+                }catch(Exception ignored){
+                }
+            }));
+        }
+
+        @Override
+        public void share(MusicList list){
+            if(list.size() == 0) return;
+            Vars.ui.showConfirm("分享", "确认分享到聊天框?", () -> {
+                try{
+                    Http.HttpRequest req = Http.post("https://pastebin.com/api/api_post.php", "api_dev_key=sdBDjI5mWBnHl9vBEDMNiYQ3IZe0LFEk&api_option=paste&api_paste_expire_date=10M&api_paste_code=" + URLEncoder.encode(buildList(list), E));
+                    req.submit(r -> {
+                        String code = r.getResultAsString();
+                        Call.sendChatMessage(getPrefix("pink", "Music") + " $M" + code.substring(code.lastIndexOf('/') + 1));
+                    });
+                    req.error(e -> Core.app.post(() -> ui.showException("分享失败", e)));
+                }catch(Exception e){
+                    ui.showException("分享失败", e);
+                }
+            });
+        }
+
+        @Override
+        public void getMusicInfo(String str, Cons<MusicInfo> callback){
+            String[] n = str.split("\uf6aa");
+            try{
+                getMusicInfo(n[0], callback, new MusicInfo(){{
+                    name = URLDecoder.decode(n[1], E);
+                    author = URLDecoder.decode(n[2], E);
+                }});
+            }catch(Exception ignored){
+            }
+        }
+
+    }
+
+    static class NetEastEncryptor{
+        IvParameterSpec iv = new IvParameterSpec(new byte[]{48, 49, 48, 50, 48, 51, 48, 52, 48, 53, 48, 54, 48, 55, 48, 56});
+        BigInteger modulus = new BigInteger("1577947502671315022124768178003454981218727833333897474240115310"
+        + "2536627753526253991370180629076647918947753359785498960680319425"
+        + "3978660329941980786072432806427833685472618792592200595694346872"
+        + "9513017705807651353492595901674905361380824696806385144165942166"
+        + "29258349130257685001248172188325316586707301643237607");
+        BigInteger pk = new BigInteger("65537");
+
+        public void encryptRequest(Http.HttpRequest req, String str) throws Exception{
+            req.header("content-type", "application/x-www-form-urlencoded");
+            NetMusicData data = encryptParams(str);
+            req.content("params=" + URLEncoder.encode(data.params, E) + "&encSecKey=" + URLEncoder.encode(data.encSecKey, E));
+        }
+
+        public NetMusicData encryptParams(String raw) throws Exception{
+            String rnd = rndString();
+            String enc = encrypt(raw, "0CoJUm6Qyw8W8jud");
+            enc = encrypt(enc, rnd);
+            NetMusicData o = new NetMusicData();
+            o.params = enc;
+            rnd = new StringBuilder(rnd).reverse().toString();
+            Cipher cipher = Cipher.getInstance("RSA/ECB/nopadding");
+            RSAPublicKeySpec publicSpec = new RSAPublicKeySpec(modulus, pk);
+            RSAPublicKey key = (RSAPublicKey)KeyFactory.getInstance("RSA").generatePublic(publicSpec);
+            cipher.init(Cipher.ENCRYPT_MODE, key);
+            byte[] result = cipher.doFinal(rnd.getBytes());
+            StringBuilder sb = new StringBuilder();
+            for(byte b : result){
+                sb.append(String.format("%02x", b));
+            }
+            o.encSecKey = sb.toString();
+            return o;
+        }
+
+        public String encrypt(String raw, String key) throws Exception{
+            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
+            byte[] bytes = key.getBytes(E);
+            SecretKeySpec s = new SecretKeySpec(bytes, "AES");
+            cipher.init(Cipher.ENCRYPT_MODE, s, iv);
+            byte[] e = cipher.doFinal(raw.getBytes(E));
+            return String.valueOf(Base64Coder.encode(e));
+        }
+
+        public String rndString(){
+            String keys = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
+            StringBuilder sb = new StringBuilder();
+            for(int i = 0; i < 16; i++){
+                sb.append(keys.charAt((int)Math.floor(Math.random() * 62)));
+            }
+            return sb.toString();
+        }
+
+        static class NetMusicData{
+            public String params, encSecKey;
+        }
+    }
+
+    private class LRCTable extends Table{
+        public LRCTable(){
+            setColor(new Color(127, 127, 127, 255));
+            margin(0f);
+            touchable = Touchable.enabled;
+            table(Styles.black3, t -> {
+                t.color.set(new Color(127, 127, 127, 255));
+                t.addListener(new HandCursorListener());
+                t.margin(6f);
+                t.touchable = Touchable.enabled;
+                t.table(tt -> {
+                    tt.label(() -> nowMusic.name == null ? "松鼠音乐" : (nowMusic.author + " - " + nowMusic.name));
+                    tt.button(Icon.leftSmall, RStyles.clearLineNonei, MusicDialog.this::prev).margin(3f).padTop(6f).top().right().size(32);
+                    tt.button(Icon.rightSmall, RStyles.clearLineNonei, MusicDialog.this::playNext).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                    tt.button(Icon.play, RStyles.clearLineNonei, MusicDialog.this::play).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                    tt.button(Icon.pause, RStyles.clearLineNonei, MusicDialog.this::pause).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                    tt.button(Icon.downloadSmall, RStyles.clearLineNonei, () -> {
+                        if(nowMusic.url != null){
+                            download(nowMusic);
+                        }
+                    }).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                    tt.label(() -> "音量:" + (byte)vol);
+                    tt.button(Icon.upSmall, RStyles.clearLineNonei, () -> {
+                        vol = Math.min(vol + 10, 100);
+                        Core.settings.put("musicVolume", vol);
+                        player.setVolume(vol / 100 * 2);
+                        sounds.setVolume(vol / 100 * 2);
+                    }).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                    tt.button(Icon.downSmall, RStyles.clearLineNonei, () -> {
+                        vol = Math.max(vol - 10, 0);
+                        Core.settings.put("musicVolume", vol);
+                        player.setVolume(vol / 100 * 2);
+                        sounds.setVolume(vol / 100 * 2);
+                    }).margin(3f).pad(2).padTop(6f).top().right().size(32);
+                    tt.button(Icon.refreshSmall, RStyles.clearLineNoneTogglei, () -> {
+                        player.setLooping(!player.isLooping());
+                        ui.announce("单曲循环已" + (player.isLooping() ? "开启" : "关闭"), 1f);
+                    }).margin(3f).pad(2).padTop(6f).top().right().checked(b -> player.isLooping()).size(32);
+                    tt.button(Icon.linkSmall, RStyles.clearLineNonei, () -> {
+                        if(nowMusic.url != null){
+                            apis.get(nowMusic.src).share(nowMusic);
+                        }
+                    }).margin(3f).pad(2).pad(6).top().right().size(32);
+                    tt.button(Icon.homeSmall, RStyles.clearLineNonei, MusicDialog.this::show).margin(3f).padTop(6f).top().right().size(32);
+                });
+                t.add().growX();
+                translation.set(Core.settings.getFloat("lrcX", 200f), Core.settings.getFloat("lrcY", 200f));
+                t.addListener(new InputListener(){
+                    float lastx, lasty;
+
+                    @Override
+                    public boolean touchDown(InputEvent event, float x, float y, int pointer, KeyCode button){
+                        Vec2 v = localToParentCoordinates(Tmp.v1.set(x, y));
+                        lastx = v.x;
+                        lasty = v.y;
+                        toFront();
+                        return true;
+                    }
+
+                    @Override
+                    public void touchDragged(InputEvent event, float x, float y, int pointer){
+                        Vec2 v = localToParentCoordinates(Tmp.v1.set(x, y));
+                        translation.add(v.x - lastx, v.y - lasty);
+                        Core.settings.put("lrcX", translation.x);
+                        Core.settings.put("lrcY", translation.y);
+                        lastx = v.x;
+                        lasty = v.y;
+                    }
+                });
+                t.row();
+                t.table(tt -> {
+                    t.label(() -> "").update(l -> {
+                        l.setFontScale(fontScale);
+                        l.setText(lrcColor + lrcLine1);
+                    }).center();
+                    t.row();
+                    t.label(() -> "").update(l -> {
+                        l.setFontScale(fontScale);
+                        l.setText(nextLrcColor + lrcLine2);
+                    }).center();
+                });
+            });
+        }
+    }
+
+    private class SettingsDialog extends BaseDialog{
+        public SettingsDialog(){
+            super("松鼠音乐设置");
+            CheckBox box = new CheckBox("显示歌词");
+            box.update(() -> box.setChecked(Core.settings.getBool("showLRC")));
+            box.changed(() -> {
+                Core.settings.put("showLRC", !Core.settings.getBool("showLRC"));
+                buildLRC();
+            });
+            cont.add(box).row();
+            cont.add("歌词颜色（正在播放）");
+            cont.row();
+            cont.field(Core.settings.getString("lrcColor", "blue"), s -> {
+                Core.settings.put("lrcColor", s);
+                lrcColor = "[" + s + "]";
+            }).size(128, 32);
+            cont.row();
+            cont.add("歌词颜色（下一行）");
+            cont.row();
+            cont.field(Core.settings.getString("nextLrcColor", "white"), s -> {
+                Core.settings.put("nextLrcColor", s);
+                nextLrcColor = "[" + s + "]";
+            }).size(128, 32);
+            cont.row();
+            cont.add("歌词字号：");
+            cont.slider(0.4f, 4, 0.2f, 1, fs -> {
+                fontScale = fs;
+                Core.settings.put("lrcFontScale", fs);
+            }).size(512, 40);
+            cont.label(() -> String.valueOf(fontScale));
+            cont.row();
+            cont.table(tt -> {
+                tt.add("预览效果：");
+                tt.row();
+                tt.label(() -> "").update(l -> {
+                    l.setFontScale(fontScale);
+                    l.setText(lrcColor + lrcLine1);
+                });
+                tt.row();
+                tt.label(() -> "").update(l -> {
+                    l.setFontScale(fontScale);
+                    l.setText(nextLrcColor + lrcLine2);
+                });
+            });
+            cont.row();
+            cont.button("重置歌词位置", () -> {
+                Core.settings.put("lrcX", 200f);
+                Core.settings.put("lrcY", 200f);
+                buildLRC();
+            }).size(256, 48);
+            cont.row();
+            cont.add("[pink]松鼠音乐v" + version + "\n[gold]松鼠制作\n[cyan]松鼠站:squi2rel.tk");
+            addCloseButton();
+        }
+    }
+}
diff --git a/core/src/mindustry/arcModule/ui/dialogs/USIDDialog.java b/core/src/mindustry/arcModule/ui/dialogs/USIDDialog.java
new file mode 100644
index 0000000000000000000000000000000000000000..57a7f92eb69636e5a01ebf27d297025319970864
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/dialogs/USIDDialog.java
@@ -0,0 +1,82 @@
+package mindustry.arcModule.ui.dialogs;
+
+import arc.*;
+import arc.math.*;
+import arc.struct.*;
+import arc.util.*;
+import arc.util.serialization.*;
+import mindustry.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+
+import java.util.*;
+
+public class USIDDialog extends BaseDialog{
+    public static boolean chooseUSID = false;
+
+    public USIDDialog(){
+        super("usid管理器");
+        shown(this::build);
+        addCloseButton();
+    }
+
+    public void build(){
+        cont.clear();
+        cont.add("在这里可以更改你在各个服务器内的usid").row();
+        cont.add("但小心，误改可能会导致账号需重新绑定/丢失管理").row();
+        cont.check("在加入新服务器时提示指定usid(不清楚用途不要开启)", b -> {
+            chooseUSID = b;
+            Core.settings.put("arc-chooseUSID", b);
+        }).checked(Core.settings.getBool("arc-chooseUSID", false)).row();
+        cont.pane(pane -> pane.table(t -> {
+            t.table(t2 -> {
+                t2.table(t3 -> t3.add("ip").color(Pal.accent).width(100).padLeft(5).left().get().setAlignment(Align.left)).growX();
+                t2.table(t3 -> t3.add("usid").color(Pal.accent).width(100).left().get().setAlignment(Align.left)).growX();
+                t2.add().size(48);
+            }).growX();
+            t.row();
+            HashMap<String, Object> map = Reflect.get(Core.settings, "values");
+            for(String k : map.keySet()){
+                if(k.startsWith("usid-")){
+                    t.table(t2 -> {
+                        t2.table(t3 -> t3.add(k.substring(5)).color(Pal.accent).growX().padLeft(5).get().setAlignment(Align.left)).growX();
+                        t2.table(t3 -> t3.field(Core.settings.getString(k), v -> Core.settings.put(k, v))).growX();
+                        t2.button(Icon.trash, () -> Vars.ui.showConfirm("警告:此操作不可逆且可能会导致账号需重新绑定/丢失管理", () -> {
+                            Core.settings.remove(k);
+                            build();
+                        })).size(48);
+                    }).growX();
+                    t.row();
+                }
+            }
+            t.button("清除所有usid", Icon.trash, () -> Vars.ui.showConfirm("警告:此操作不可逆且可能会导致账号需重新绑定/丢失管理", () -> {
+                Seq<String> keys = new Seq<>();
+                for(String k : map.keySet()){
+                    if(k.startsWith("usid-")){
+                        keys.add(k);
+                    }
+                }
+                for(String k : keys){
+                    Core.settings.remove(k);
+                }
+                build();
+            })).growX();
+        }).get().setBackground(Styles.grayPanel)).grow();
+    }
+
+    public static void showSet(String ip){
+        Vars.ui.showTextInput("设置usid", "选择对于ip " + ip + " 的usid\n填入\"rand\"可自动生成", 32, "", false, s -> {
+            if(Objects.equals(s, "rand")){
+                byte[] bytes = new byte[8];
+                new Rand().nextBytes(bytes);
+                String result = new String(Base64Coder.encode(bytes));
+                Core.settings.put("usid-" + ip, result);
+            }else{
+                Core.settings.put("usid-" + ip, s);
+            }
+            Vars.ui.join.reconnect();
+        }, () -> Vars.ui.loadfrag.hide());
+    }
+}
diff --git a/core/src/mindustry/arcModule/ui/quickTool/AdvanceBuildTool.java b/core/src/mindustry/arcModule/ui/quickTool/AdvanceBuildTool.java
new file mode 100644
index 0000000000000000000000000000000000000000..f03e268b9a135eaf3101cb42df2057ae11d16cc2
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/quickTool/AdvanceBuildTool.java
@@ -0,0 +1,435 @@
+package mindustry.arcModule.ui.quickTool;
+
+import arc.*;
+import arc.func.*;
+import arc.graphics.g2d.*;
+import arc.math.geom.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.arcModule.*;
+import mindustry.arcModule.ui.dialogs.*;
+import mindustry.content.*;
+import mindustry.entities.units.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustry.world.*;
+import mindustry.world.blocks.*;
+import mindustry.world.blocks.environment.*;
+import mindustry.world.blocks.power.*;
+import mindustry.world.blocks.production.*;
+import mindustry.world.blocks.storage.*;
+import mindustryX.features.ui.*;
+
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.arcModule.ElementUtils.*;
+
+public class AdvanceBuildTool extends ElementUtils.ToolTable{
+    BuildRange placement = BuildRange.player;
+    Rect selection = new Rect();
+    private Block original = Blocks.conveyor, newBlock = Blocks.titaniumConveyor;
+    private Block autoBuild = Blocks.turbineCondenser;
+    private Block searchBlock = Blocks.itemSource;
+    private Building searchBuild = null;
+    private int searchBlockIndex = -1;
+    private boolean shadowBuild = false;
+
+    public Seq<Building> buildingSeq = new Seq<>();
+    private final BuildTiles buildTiles = new BuildTiles();
+    private final ObjectFloatMap<Tile> buildEff = new ObjectFloatMap<>();//default 0f
+
+
+    public AdvanceBuildTool(){
+        icon = Blocks.buildTower.emoji();
+        Events.on(EventType.WorldLoadEvent.class, e -> rebuild());
+        Events.run(EventType.Trigger.update, () -> {
+            if(shadowBuild && player.unit() != null && player.unit().plans != null && player.unit().activelyBuilding()){
+                if(player.unit().buildPlan().progress == 0) return;
+                player.unit().plans.remove(player.unit().buildPlan());
+                Call.deletePlans(player, new int[]{player.unit().plans.indexOf(player.unit().buildPlan(), true)});
+            }
+        });
+
+    }
+
+    @Override
+    protected void buildTable(){
+        table(t -> {
+            t.setBackground(Styles.black6);
+            t.table(tt -> {
+                tt.button((placement == BuildRange.global ? "[cyan]" : "[gray]") + "", NCtextStyle, () -> {
+                    placement = BuildRange.global;
+                    rebuild();
+                }).tooltip("[cyan]全局检查").size(30f);
+                tt.button((placement == BuildRange.zone ? "[cyan]" : "[gray]") + "\uE818", NCtextStyle, () -> {
+                    selection = control.input.lastSelection;
+                    if(selection.area() < 10f) return;
+                    placement = BuildRange.zone;
+                    rebuild();
+                }).tooltip("[cyan]选择范围").size(30f);
+                tt.button((placement == BuildRange.team ? "" : "[gray]") + Blocks.coreShard.emoji(), NCtextStyle, () -> {
+                    placement = BuildRange.team;
+                    rebuild();
+                }).tooltip("[cyan]队伍区域").size(30f);
+                tt.button((placement == BuildRange.player ? "" : "[gray]") + UnitTypes.gamma.emoji(), NCtextStyle, () -> {
+                    placement = BuildRange.player;
+                    rebuild();
+                }).tooltip("[cyan]玩家建造区").size(30f);
+                tt.update(() -> {
+                    if(placement != BuildRange.zone) return;
+                    DrawUtilities.drawText("建造区域", 0.2f, selection.x * tilesize + selection.width * tilesize * 0.5f, selection.y * tilesize + selection.height * tilesize, Align.bottom);
+                    Draw.color(Pal.stat, 0.7f);
+                    Draw.z(Layer.effect - 1f);
+                    Lines.stroke(Math.min(Math.abs(width), Math.abs(height)) / tilesize / 10f);
+                    Lines.rect(selection.x * tilesize - tilesize / 2f, selection.y * tilesize - tilesize / 2f, selection.width * tilesize + tilesize, selection.height * tilesize + tilesize);
+                    Draw.reset();
+                });
+            }).fillX().row();
+            t.table(tt -> {
+                tt.button("R", NCtextStyle, this::replaceBlock).tooltip("[cyan]替换方块").size(30f);
+                tt.button(replaceBlockName(), NCtextStyle, this::replaceBlockSetting).tooltip("[acid]设置替换").width(100f).height(30f);
+            }).fillX().row();
+            t.table(tt -> {
+                tt.button(autoBuild.emoji(), NCtextStyle, () -> blockAutoPlacer(autoBuild)).size(30f);
+                tt.button("\uE87C", NCtextStyle, () -> {
+                    new BlockSelectDialog(Block::isPlaceable, block -> autoBuild = block, block -> autoBuild == block).show();
+                    rebuild();
+                }).size(30f);
+                tt.update(() -> {
+                    if(control.input.selectedBlock()){
+                        autoBuild = control.input.block;
+                        rebuild();
+                    }
+                });
+            }).fillX().row();
+            t.table(tt -> {
+                tt.button("S", NCtextStyle, this::searchBlock).update(button -> {
+
+                    buildingSeq = player.team().data().buildings.select(building1 -> building1.block == searchBlock);
+                    if(searchBlock.privileged){
+                        for(Team team : Team.all){
+                            if(team == player.team()) continue;
+                            buildingSeq.add(team.data().buildings.select(building1 -> building1.block == searchBlock));
+                        }
+                    }
+
+                    if(buildingSeq.contains(searchBuild)){
+                        searchBlockIndex = buildingSeq.indexOf(searchBuild);
+                    }else{
+                        searchBuild = null;
+                        searchBlockIndex = -1;
+                    }
+
+                    if(buildingSeq.isEmpty() || searchBlockIndex == -1) button.setText("[lightgray]\uE88A");
+                    else button.setText("\uE88A" + (searchBlockIndex + 1) + "/" + buildingSeq.size);
+                }).tooltip("[cyan]搜索方块").growX().height(30f);
+
+                tt.button(searchBlock.emoji(), NCtextStyle, () -> {
+                    new BlockSelectDialog(Block::isPlaceable, block -> searchBlock = block, block -> searchBlock == block).show().hidden(this::rebuild);
+                    searchBlockIndex = 0;
+                }).tooltip("[acid]搜索替换").width(30f).height(30f);
+
+                tt.update(() -> {
+                    if(control.input.selectedBlock()){
+                        searchBlock = control.input.block;
+                        rebuild();
+                    }
+                });
+            }).fillX().row();
+            t.table(tt -> {
+                tt.button(Blocks.worldMessage.emoji(), textStyle, () -> Core.settings.put("displayallmessage", !Core.settings.getBool("displayallmessage", false))).checked(a -> Core.settings.getBool("displayallmessage")).size(30, 30).tooltip("开关信息板全显示");
+                tt.button(Blocks.worldProcessor.emoji(), NCtextStyle, () -> {
+                    RFuncs.worldProcessor();
+                    searchBlock = Blocks.worldProcessor;
+                    rebuild();
+                }).size(30).tooltip("地图世处信息");
+            }).fillX().row();
+            t.table(tt -> tt.button("\uE817", textStyle, () -> shadowBuild = !shadowBuild).checked(a -> shadowBuild).size(30, 30).tooltip("虚影建造模式\n[red]有些服限制发包数较低，建筑较多时会被踢出。请酌情使用")).fillX().row();
+            if(!net.client()){
+                t.table(tt -> {
+                    tt.button("\uF8C9", textStyle, () -> {
+                        AdvanceToolTable.forcePlacement ^= true;
+                        if(mobile)
+                            arcui.arcInfo("允许蓝图建造地形");
+                    }).checked(a -> AdvanceToolTable.forcePlacement).size(30, 30).tooltip("允许蓝图建造地形");
+                    tt.button("\uE800", NCtextStyle, () -> {
+                        instantBuild();
+                        if(mobile)
+                            arcui.arcInfo("瞬间建造\n[cyan]强制瞬间建造[acid]选择范围内[cyan]内规划中的所有建筑\n[orange]可能出现bug");
+                    }).size(30, 30).tooltip("瞬间建造\n[cyan]强制瞬间建造[acid]选择范围内[cyan]规划中的所有建筑\n[orange]可能出现bug");
+                    tt.button("\uF8D2", NCtextStyle, () -> {
+                        if(!AdvanceToolTable.forcePlacement) arcui.arcInfo("请开启允许蓝图建造地形 \uF8C9");
+                        else saveTerrain(true);
+                    }).size(30, 30).tooltip("复制所选范围内的地板作为蓝图");
+                    tt.button("\uF8C4", NCtextStyle, () -> {
+                        if(!AdvanceToolTable.forcePlacement) arcui.arcInfo("请开启允许蓝图建造地形 \uF8C9");
+                        else saveTerrain(false);
+                    }).size(30, 30).tooltip("复制所选范围内的修饰作为蓝图");
+
+                }).fillX().row();
+            }
+        });
+    }
+
+    void replaceBlockSetting(){
+        BaseDialog dialog = new BaseDialog("方块替换器");
+        dialog.cont.table(t -> {
+            t.table(tt -> tt.label(() -> "当前选择：" + replaceBlockName())).row();
+            t.image().color(Pal.accent).fillX().row();
+            t.table(tt -> {
+                replaceBlockGroup(dialog, tt, Blocks.conveyor, Blocks.titaniumConveyor);
+                replaceBlockGroup(dialog, tt, Blocks.conveyor, Blocks.duct);
+                replaceBlockGroup(dialog, tt, Blocks.conduit, Blocks.pulseConduit);
+                replaceBlockGroup(dialog, tt, Blocks.conduit, Blocks.reinforcedConduit);
+            }).padTop(5f).row();
+            t.image().color(Pal.accent).padTop(5f).fillX().row();
+            t.table(tt -> {
+                tt.button("源方块", () -> new BlockSelectDialog(block -> block.replaceable, block -> original = block, block -> original == block).show()).width(100f).height(30f).row();
+                tt.button("新方块", () -> new BlockSelectDialog(block -> original.canReplace(block), block -> newBlock = block, block -> newBlock == block).show()).width(100f).height(30f).row();
+            }).padTop(5f).row();
+        });
+        dialog.hidden(this::rebuild);
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    void replaceBlockGroup(Dialog dialog, Table t, Block ori, Block re){
+        t.button(replaceBlockName(ori, re), () -> {
+            original = ori;
+            newBlock = re;
+            dialog.hide();
+        }).width(100f).height(30f);
+    }
+
+    String replaceBlockName(){
+        return replaceBlockName(original, newBlock);
+    }
+
+    String replaceBlockName(Block ori, Block re){
+        return ori.emoji() + "\uE803" + re.emoji();
+    }
+
+    void replaceBlock(){
+        replaceBlock(original, newBlock);
+    }
+
+    void replaceBlock(Block ori, Block re){
+        player.team().data().buildings.each(building -> building.block() == ori && contain(building.tile),
+        building -> player.unit().addBuild(new BuildPlan(building.tile.x, building.tile.y, building.rotation, re, building.config())));
+    }
+
+    void blockAutoPlacer(Block block){
+        buildTiles.buildBlock(block, tile -> getBlockEff(block, tile));
+    }
+
+    float getBlockEff(Block block, Tile tile){
+        if(block instanceof ThermalGenerator) return block.sumAttribute(((ThermalGenerator)block).attribute, tile);
+        if(block instanceof Drill) return ((Drill)block).countOreArc(tile);
+        return 1f;
+    }
+
+    boolean contain(Tile tile){
+        if(placement == BuildRange.global) return true;
+        if(placement == BuildRange.zone) return selection.contains(tile.x, tile.y);
+        if(placement == BuildRange.player) return tile.within(player.x, player.y, buildingRange);
+        if(placement == BuildRange.team){
+            if(state.rules.polygonCoreProtection){
+                float mindst = Float.MAX_VALUE;
+                CoreBlock.CoreBuild closest = null;
+                for(Teams.TeamData data : state.teams.active){
+                    for(CoreBlock.CoreBuild tiles : data.cores){
+                        float dst = tiles.dst2(tile.x * tilesize, tile.y * tilesize);
+                        if(dst < mindst){
+                            closest = tiles;
+                            mindst = dst;
+                        }
+                    }
+                }
+                return closest == null || closest.team == player.team();
+            }else return !state.teams.anyEnemyCoresWithin(player.team(), tile.x * tilesize, tile.y * tilesize, state.rules.enemyCoreBuildRadius + tilesize);
+        }
+        return true;
+    }
+
+    void searchBlock(){
+        if(buildingSeq.size == 0){
+            arcui.arcInfo("[violet]方块搜索\n[acid]未找到此方块");
+            return;
+        }
+        searchBlockIndex = (searchBlockIndex + 1) % buildingSeq.size;
+        searchBuild = buildingSeq.get(searchBlockIndex);
+
+        RFuncs.arcSetCamera(searchBuild);
+        arcui.arcInfo("[violet]方块搜索\n[acid]找到方块[cyan]" + (searchBlockIndex + 1) + "[acid]/[cyan]" + buildingSeq.size + "[white]" + searchBlock.emoji());
+    }
+
+    void instantBuild(){
+        player.unit().plans.each(buildPlan -> {
+            if(!contain(buildPlan.tile())) return;
+            forceBuildBlock(buildPlan.block, buildPlan.tile(), player.team(), buildPlan.rotation, buildPlan.config);
+        });
+    }
+
+    void saveTerrain(boolean floor){
+        buildTiles.updateTiles();
+        Seq<Schematic.Stile> tiles = new Seq<>();
+        buildTiles.validTile.each(tile -> {
+            if(!floor && tile.overlay() == Blocks.air) return;
+            tiles.add(new Schematic.Stile(floor ? tile.floor() : tile.overlay(), tile.x - buildTiles.minx, tile.y - buildTiles.miny));
+        });
+        control.input.lastSchematic = new Schematic(tiles, new StringMap(), buildTiles.width, buildTiles.height);
+        control.input.useSchematic(control.input.lastSchematic);
+    }
+
+    void forceBuildBlock(Block block, Tile tile, Team team, int rotation, Object config){
+        if(block == Blocks.cliff) buildCliff(tile);
+        else if(block instanceof OverlayFloor){
+            tile.setOverlay(block);
+        }else if(block instanceof Floor floor){
+            tile.setFloor(floor);
+        }else{
+            tile.setBlock(block, team, rotation);
+            tile.build.configure(config);
+        }
+        pathfinder.updateTile(tile);
+    }
+
+    void buildCliff(Tile tile){
+        int rotation = 0;
+        for(int i = 0; i < 8; i++){
+            Tile other = world.tiles.get(tile.x + Geometry.d8[i].x, tile.y + Geometry.d8[i].y);
+            if(other != null && !other.floor().hasSurface()){
+                rotation |= (1 << i);
+            }
+        }
+
+        if(rotation != 0){
+            tile.setBlock(Blocks.cliff);
+        }
+
+        tile.data = (byte)rotation;
+    }
+
+    enum BuildRange{
+        global, zone, team, player
+    }
+
+    class BuildTiles{
+        public int minx, miny, maxx, maxy, width, height;
+        Seq<Tile> validTile = new Seq<>();
+        Seq<Float> eff = new Seq<>();
+        float efficiency = 0;
+        Block block;
+        boolean canBuild = true;
+
+        public BuildTiles(){
+        }
+
+        void buildBlock(Block buildBlock, Floatf<Tile> tilef){
+            block = buildBlock;
+            updateTiles();
+            checkValid();
+            calBlockEff(tilef);
+            eff.sort().reverse().remove(0f);
+            eff.each(this::buildEff);
+        }
+
+        public void updateTiles(){
+            minx = 9999;
+            miny = 9999;
+            maxx = -999;
+            maxy = -999;
+            validTile.clear();
+            eff.clear();
+            world.tiles.eachTile(tile -> {
+                if(tile == null) return;
+                if(!contain(tile)) return;
+                validTile.add(tile);
+                minx = Math.min(minx, tile.x);
+                miny = Math.min(miny, tile.y);
+                maxx = Math.max(maxx, tile.x);
+                maxy = Math.max(maxy, tile.y);
+            });
+            buildEff.clear();
+            width = maxx - minx;
+            height = maxy - miny;
+        }
+
+        void checkValid(){
+            validTile.each(tile -> {
+                if(
+                (block.size == 2 && world.getDarkness(tile.x, tile.y) >= 3) ||
+                (state.rules.staticFog && state.rules.fog && !fogControl.isDiscovered(player.team(), tile.x, tile.y)) ||
+                (tile.floor().isDeep() && !block.floating && !block.requiresWater && !block.placeableLiquid) || //deep water
+                (block == tile.block() && tile.build != null && rotation == tile.build.rotation && block.rotate) || //same block, same rotation
+                !tile.interactable(player.team()) || //cannot interact
+                !tile.floor().placeableOn || //solid wall
+                //replacing a block that should be replaced (e.g. payload placement)
+                !((block.canReplace(tile.block()) || //can replace type
+                (tile.build instanceof ConstructBlock.ConstructBuild build && build.current == block && tile.centerX() == tile.x && tile.centerY() == tile.y)) && //same type in construction
+                block.bounds(tile.x, tile.y, Tmp.r1).grow(0.01f).contains(tile.block().bounds(tile.centerX(), tile.centerY(), Tmp.r2))) || //no replacement
+                (block.requiresWater && tile.floor().liquidDrop != Liquids.water) //requires water but none found
+                ) buildEff.put(tile, -1); // cannot build
+            });
+        }
+
+        void calBlockEff(Floatf<Tile> tilef){
+            validTile.each(tile -> {
+                canBuild = true;
+                getLinkedTiles(tile, tile1 -> canBuild = buildEff.get(tile, 0f) != -1 && canBuild);   //不可能建造
+                if(canBuild){
+                    efficiency = tilef.get(tile);
+                    buildEff.put(tile, efficiency);
+                    if(!eff.contains(efficiency)) eff.add(efficiency);
+                }else{
+                    buildEff.remove(tile, 0);
+                }
+            });
+        }
+
+        void buildEff(float e){
+            if(e == 0) return;
+            validTile.each(tile -> {
+                if(buildEff.get(tile, 0f) != e) return;
+                if(!block.canPlaceOn(tile, player.team(), 0)) return;
+                player.unit().addBuild(new BuildPlan(tile.x, tile.y, 0, block));
+                getFullLinkedTiles(tile, tile1 -> buildEff.remove(tile1, 0f));
+            });
+        }
+
+        private void getLinkedTiles(Tile tile, Cons<Tile> cons){
+            if(block.isMultiblock()){
+                int size = block.size, o = block.sizeOffset;
+                for(int dx = 0; dx < size; dx++){
+                    for(int dy = 0; dy < size; dy++){
+                        Tile other = world.tile(tile.x + dx + o, tile.y + dy + o);
+                        if(other != null) cons.get(other);
+                    }
+                }
+            }else{
+                cons.get(tile);
+            }
+        }
+
+        private void getFullLinkedTiles(Tile tile, Cons<Tile> cons){
+            if(block.isMultiblock()){
+                int size = block.size, o = 0;
+                for(int dx = -size + 1; dx < size; dx++){
+                    for(int dy = -size + 1; dy < size; dy++){
+                        Tile other = world.tile(tile.x + dx + o, tile.y + dy + o);
+                        if(other != null) cons.get(other);
+                    }
+                }
+            }else{
+                cons.get(tile);
+            }
+        }
+
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/ui/quickTool/HudSettingsTable.java b/core/src/mindustry/arcModule/ui/quickTool/HudSettingsTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..e544d6d1bde608e1e84d6ead4b76dd74d96bc507
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/quickTool/HudSettingsTable.java
@@ -0,0 +1,349 @@
+package mindustry.arcModule.ui.quickTool;
+
+import arc.*;
+import arc.func.*;
+import arc.scene.*;
+import arc.scene.event.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import mindustry.arcModule.*;
+import mindustry.content.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustryX.features.*;
+
+import static arc.Core.*;
+import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.arcModule.ElementUtils.*;
+
+public class HudSettingsTable extends ElementUtils.ToolTable{
+    protected Seq<Setting> list = new Seq<>();
+
+    public HudSettingsTable(){
+        icon = String.valueOf(Iconc.settings);
+        rebuild();
+        Events.on(EventType.WorldLoadEvent.class, e -> Core.settings.put("removeLogicLock", false));
+    }
+
+    @Override
+    protected void buildTable(){
+        list.clear();
+        Table sets = new Table();
+        sliderPref("turretShowRange", 0, 0, 3, 1, s -> {
+            if(s == 0){
+                return "关闭";
+            }else if(s == 1){
+                return "仅对地";
+            }else if(s == 2){
+                return "仅对空";
+            }else if(s == 3){
+                return "全部";
+            }else{
+                return s + "";
+            }
+        });
+        sliderPref("chatValidType", 0, 0, 3, 1, s -> {
+            if(s == 0){
+                return "原版模式";
+            }else if(s == 1){
+                return "纯净聊天";
+            }else if(s == 2){
+                return "服务器记录";
+            }else if(s == 3){
+                return "全部记录";
+            }else{
+                return s + "";
+            }
+        });
+        checkPref("unitHealthBar", false);
+        sliderPref("unitTransparency", 100, 0, 100, 5, i -> i > 0 ? i + "%" : "关闭");
+        sliderPref("unitDrawMinHealth", 0, 0, 2500, 50, i -> i + "[red]HP");
+        sliderPref("unitBarDrawMinHealth", 0, 0, 2500, 100, i -> i + "[red]HP");
+        sliderPref("unitWeaponRange", 0, 0, 100, 1, i -> i > 0 ? i + "%" : "关闭");
+
+        checkPref("alwaysShowUnitRTSAi", false);
+        checkPref("unitLogicMoveLine", true);
+        checkPref("unitWeaponTargetLine", true);
+
+        checkPref("blockWeaponTargetLine", true);
+        checkPref("unitbuildplan", false);
+
+
+        for(Setting setting : list){
+            setting.add(sets);
+        }
+
+        ScrollPane pane = pane(sp -> {
+            sp.background(Styles.black6);
+            sp.table(t -> {
+                t.button("[cyan]S", NCtextStyle, () -> Call.sendChatMessage("/sync")).size(30).tooltip("同步一波");
+                t.button("[cyan]观", NCtextStyle, () -> Call.sendChatMessage("/ob")).size(30).tooltip("观察者模式");
+                t.button("[cyan]技", NCtextStyle, () -> Call.sendChatMessage("/skill")).size(30).tooltip("技能！");
+                t.button("[cyan]版", NCtextStyle, () -> Call.sendChatMessage("/broad")).size(30).tooltip("服务器信息版");
+                t.button("[red]版", textStyle, () -> settings.put("ShowInfoPopup", !Core.settings.getBool("ShowInfoPopup"))).checked(a -> Core.settings.getBool("ShowInfoPopup")).size(30, 30).tooltip("关闭所有信息版");
+                t.button("[white]法", NCtextStyle, () -> ui.showConfirm("受不了，直接投降？", () -> Call.sendChatMessage("/vote gameover"))).size(30, 30).tooltip("法国军礼");
+                if(settings.getInt("arcQuickMsg", 0) == 0)
+                    t.button("\uE87C", NCtextStyle, this::arcQuickMsgTable).size(30, 30).tooltip("快捷消息");
+            }).left();
+            sp.row();
+            if(settings.getInt("arcQuickMsg") > 0){
+                sp.table(t -> {
+                    for(int i = 0; i < settings.getInt("arcQuickMsg"); i++){
+                        if(i % settings.getInt("arcQuickMsgKey", 8) == 0) t.row();
+                        int finalI = i;
+                        t.button(settings.getString(getArcQuickMsgShortName(i)), NCtextStyle, () -> {
+                            if(settings.getBool(getArcQuickMsgJs(finalI))) mods.getScripts().runConsole(settings.getString(getArcQuickMsgName(finalI)));
+                            else Call.sendChatMessage(settings.getString(getArcQuickMsgName(finalI)));
+                        }
+                        ).size(30);
+                    }
+                    t.button("\uE87C", NCtextStyle, this::arcQuickMsgTable).size(30, 30).tooltip("快捷消息");
+                }).left();
+                sp.row();
+            }
+            sp.table(t -> {
+                t.button("[cyan]块", textStyle, () -> Core.settings.put("blockRenderLevel", (RenderExt.blockRenderLevel + 1) % 3)).size(30, 30).tooltip("建筑显示");
+                t.button("[cyan]兵", textStyle, () -> RenderExt.unitHide = !RenderExt.unitHide).checked(a -> !RenderExt.unitHide).size(30, 30).tooltip("兵种显示");
+                t.button("[cyan]箱", textStyle, () -> Core.settings.put("unithitbox", !Core.settings.getBool("unithitbox"))).checked(a -> Core.settings.getBool("unithitbox")).size(30, 30).tooltip("碰撞箱显示");
+                t.button("[cyan]弹", textStyle, () -> Core.settings.put("bulletShow", !Core.settings.getBool("bulletShow"))).checked(a -> Core.settings.getBool("bulletShow")).size(30, 30).tooltip("子弹显示");
+                t.button("[violet]锁", textStyle, () -> {
+                    Core.settings.put("removeLogicLock", !Core.settings.getBool("removeLogicLock"));
+                    control.input.logicCutscene = false;
+                    arcui.arcInfo("已移除逻辑视角锁定");
+                }).checked(a -> Core.settings.getBool("removeLogicLock")).size(30, 30).tooltip("逻辑锁定");
+                t.button("[violet]丢", textStyle, () -> {
+                    boolean block = Core.settings.getBool("blockDrop");
+                    Core.settings.put("blockDrop", !block);
+                    arcui.arcInfo("已" + (block ? "开启" : "关闭") + "丢弃物品");
+                }).checked(a -> !Core.settings.getBool("blockDrop")).size(30, 30).tooltip("允许丢弃物品");
+                t.button("[cyan]雾", textStyle, () -> {
+                    if(!state.rules.pvp || player.team().id == 255) renderer.fogEnabled = !renderer.fogEnabled;
+                }).checked(a -> renderer.fogEnabled).size(30, 30).tooltip("战争迷雾").visible(() -> !state.rules.pvp || player.team().id == 255);
+            }).left();
+            sp.row();
+            sp.table(t -> {
+                t.button("[red]灯", textStyle, () -> settings.put("drawlight", !settings.getBool("drawlight"))).checked(a -> state.rules.lighting).size(30, 30).name("灯光").tooltip("[cyan]开灯啊！");
+                t.button("[acid]效", textStyle, () -> Core.settings.put("effects", !Core.settings.getBool("effects"))).checked(a -> Core.settings.getBool("effects")).size(30, 30).tooltip("特效显示");
+                t.button("[acid]光", textStyle, () -> {
+                    Core.settings.put("bloom", !Core.settings.getBool("bloom"));
+                    renderer.toggleBloom(settings.getBool("bloom"));
+                }).checked(a -> Core.settings.getBool("bloom")).size(30, 30).tooltip("光效显示");
+                t.button("[acid]墙", textStyle, () -> Core.settings.put("forceEnableDarkness", !Core.settings.getBool("forceEnableDarkness"))).checked(a -> Core.settings.getBool("forceEnableDarkness")).size(30, 30).tooltip("墙体阴影显示");
+                t.button("[acid]天", textStyle, () -> Core.settings.put("showweather", !Core.settings.getBool("showweather"))).checked(a -> Core.settings.getBool("showweather")).size(30, 30).tooltip("天气显示");
+                if(settings.getBool("developMode"))
+                    t.button(StatusEffects.burning.emoji(), textStyle, () -> state.rules.fire = !state.rules.fire).checked(a -> state.rules.fire).size(30, 30).tooltip("太燃了");
+                t.button("[cyan]扫", textStyle, () -> control.input.arcScanMode = !control.input.arcScanMode).checked(a -> control.input.arcScanMode).size(30, 30).tooltip("扫描模式");
+
+            }).left();
+            sp.row();
+            sp.add(sets);
+        }).maxSize(800f, 300f).get();
+
+        pane.update(() -> {
+            Element e = Core.scene.hit(Core.input.mouseX(), Core.input.mouseY(), true);
+            if(e != null && e.isDescendantOf(pane)){
+                pane.requestScroll();
+            }else if(pane.hasScroll()){
+                Core.scene.setScrollFocus(null);
+            }
+        });
+    }
+
+    private void arcQuickMsgTable(){
+        BaseDialog dialog = new BaseDialog("快捷信息");
+        dialog.cont.table(t -> {
+            t.add("在此编辑快速消息，可在快捷设置面板显示。如设置：\n[white]法 /vote gameover\n" +
+            "这一指令会添加一个“[white]法的按钮，点击会自动输入/vote gameover。\n" +
+            "由于懒得写更新，请修改滑块后[orange]关闭此窗口后再打开一次[white]\n" +
+            "快捷设置面板同样需要[orange]关闭后再打开一次[white]才能生效").center().fillX().row();
+            t.table(tt -> {
+                tt.add("快捷消息个数： ");
+                Label label = tt.add(String.valueOf(settings.getInt("arcQuickMsg", 0))).get();
+                tt.slider(0, 50, 1, settings.getInt("arcQuickMsg", 0), i -> {
+                    settings.put("arcQuickMsg", (int)i);
+                    label.setText(String.valueOf(settings.getInt("arcQuickMsg")));
+                }).width(200f).row();
+                tt.add("每行多少个按键： ");
+                Label label2 = tt.add(String.valueOf(settings.getInt("arcQuickMsgKey", 0))).get();
+                tt.slider(3, 10, 1, settings.getInt("arcQuickMsgKey", 0), i -> {
+                    settings.put("arcQuickMsgKey", (int)i);
+                    label2.setText(String.valueOf(settings.getInt("arcQuickMsgKey")));
+                }).width(200f);
+            }).row();
+            t.pane(tt -> {
+                tt.add("第i个").width(50f);
+                tt.add("JS").width(50f);
+                tt.add("按钮显示\n(建议单个字符)").width(100f);
+                tt.add("              输入信息").width(400f).center().row();
+
+                for(int i = 0; i < settings.getInt("arcQuickMsg", 0); i++){
+                    tt.add(i + "  ");
+                    int finalI = i;
+                    tt.check("", settings.getBool(getArcQuickMsgJs(finalI)), js -> settings.put(getArcQuickMsgJs(finalI), js));
+                    tt.field(settings.getString(getArcQuickMsgShortName(finalI), "?"), text -> settings.put(getArcQuickMsgShortName(finalI), text)).maxTextLength(10);
+                    tt.field(settings.getString(getArcQuickMsgName(finalI), "未输入指令"), text -> settings.put(getArcQuickMsgName(finalI), text)).maxTextLength(300).width(350f);
+                    tt.row();
+                }
+            });
+        });
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    private String getArcQuickMsgShortName(int i){
+        return "arcQuickMsgShort" + i;
+    }
+
+    private String getArcQuickMsgName(int i){
+        return "arcQuickMsg" + i;
+    }
+
+    private String getArcQuickMsgJs(int i){
+        return "arcQuickMsgJs" + i;
+    }
+
+    public interface StringProcessor{
+        String get(int i);
+    }
+
+    public Seq<Setting> getSettings(){
+        return list;
+    }
+
+    public void pref(Setting setting){
+        list.add(setting);
+        rebuild();
+    }
+
+    public SliderSettingF sliderPref(String name, String title, int def, int min, int max, StringProcessor s){
+        return sliderPref(name, title, def, min, max, 1, s);
+    }
+
+    public SliderSettingF sliderPref(String name, String title, int def, int min, int max, int step, StringProcessor s){
+        SliderSettingF res;
+        list.add(res = new SliderSettingF(name, title, def, min, max, step, s));
+        settings.defaults(name, def);
+        return res;
+    }
+
+    public SliderSettingF sliderPref(String name, int def, int min, int max, StringProcessor s){
+        return sliderPref(name, def, min, max, 1, s);
+    }
+
+    public SliderSettingF sliderPref(String name, int def, int min, int max, int step, StringProcessor s){
+        SliderSettingF res;
+        list.add(res = new SliderSettingF(name, bundle.get("setting." + name + ".name"), def, min, max, step, s));
+        settings.defaults(name, def);
+        return res;
+    }
+
+    public void checkPref(String name, String title, boolean def){
+        list.add(new CheckSettingF(name, title, def, null));
+        settings.defaults(name, def);
+    }
+
+    public void checkPref(String name, String title, boolean def, Boolc changed){
+        list.add(new CheckSettingF(name, title, def, changed));
+        settings.defaults(name, def);
+    }
+
+    /**
+     * Localized title.
+     */
+    public void checkPref(String name, boolean def){
+        list.add(new CheckSettingF(name, bundle.get("setting." + name + ".name"), def, null));
+        settings.defaults(name, def);
+    }
+
+    /**
+     * Localized title.
+     */
+    public void checkPref(String name, boolean def, Boolc changed){
+        list.add(new CheckSettingF(name, bundle.get("setting." + name + ".name"), def, changed));
+        settings.defaults(name, def);
+    }
+
+    public abstract static class Setting{
+        public String name;
+        public String title;
+
+        public abstract void add(Table table);
+    }
+
+    public static class CheckSettingF extends Setting{
+        boolean def;
+        Boolc changed;
+
+        CheckSettingF(String name, String title, boolean def, Boolc changed){
+            this.name = name;
+            this.title = title;
+            this.def = def;
+            this.changed = changed;
+        }
+
+        @Override
+        public void add(Table table){
+            CheckBox box = new CheckBox(title);
+            box.update(() -> box.setChecked(settings.getBool(name)));
+
+            box.changed(() -> {
+                settings.put(name, box.isChecked());
+                if(changed != null){
+                    changed.get(box.isChecked());
+                }
+            });
+
+            box.left();
+            table.add(box).left().padTop(0.5f);
+            table.row();
+        }
+    }
+
+    public static class SliderSettingF extends Setting{
+        int def;
+        int min;
+        int max;
+        int step;
+        StringProcessor sp;
+        float[] values = null;
+
+        SliderSettingF(String name, String title, int def, int min, int max, int step, StringProcessor s){
+            this.name = name;
+            this.title = title;
+            this.def = def;
+            this.min = min;
+            this.max = max;
+            this.step = step;
+            this.sp = s;
+        }
+
+        @Override
+        public void add(Table table){
+            Slider slider = new Slider(min, max, step, false);
+
+            slider.setValue(settings.getInt(name));
+
+            Label value = new Label("", Styles.outlineLabel);
+            Table content = new Table();
+            content.add(title, Styles.outlineLabel).left().growX().wrap();
+            content.add(value).padLeft(10f).right();
+            content.margin(3f, 33f, 3f, 33f);
+            content.touchable = Touchable.disabled;
+
+            slider.changed(() -> {
+                settings.put(name, (int)slider.getValue());
+                value.setText(sp.get((int)slider.getValue()));
+            });
+
+            slider.change();
+
+            table.stack(slider, content).width(Math.min(Core.graphics.getWidth() / 1.2f, 300f)).left().padTop(4f).get();
+            table.row();
+        }
+    }
+
+}
diff --git a/core/src/mindustry/arcModule/ui/quickTool/QuickToolTable.java b/core/src/mindustry/arcModule/ui/quickTool/QuickToolTable.java
new file mode 100644
index 0000000000000000000000000000000000000000..f447c94277b4e601cc8fbfd6b96aca6cdfab531f
--- /dev/null
+++ b/core/src/mindustry/arcModule/ui/quickTool/QuickToolTable.java
@@ -0,0 +1,13 @@
+package mindustry.arcModule.ui.quickTool;
+
+import arc.scene.ui.layout.*;
+
+public class QuickToolTable extends Table{
+    public HudSettingsTable hudSettingsTable = new HudSettingsTable();
+    public AdvanceBuildTool advanceBuildTool = new AdvanceBuildTool();
+
+    public QuickToolTable(){
+        add(hudSettingsTable).growX().row();
+        add(advanceBuildTool).growX();
+    }
+}
diff --git a/core/src/mindustry/core/NetClient.java b/core/src/mindustry/core/NetClient.java
index 89ac0f575dafcf3602ec5b8b2ec2db47d5f3a584..780e1afa49a32a6afb2a0162f9f17eae13fe3a09 100644
--- a/core/src/mindustry/core/NetClient.java
+++ b/core/src/mindustry/core/NetClient.java
@@ -12,6 +12,7 @@ import arc.util.io.*;
 import arc.util.serialization.*;
 import mindustry.*;
 import mindustry.annotations.Annotations.*;
+import mindustry.arcModule.ui.dialogs.*;
 import mindustry.core.GameState.*;
 import mindustry.entities.*;
 import mindustry.game.EventType.*;
@@ -62,7 +63,19 @@ public class NetClient implements ApplicationListener{
     public NetClient(){
 
         net.handleClient(Connect.class, packet -> {
+            player.name = Core.settings.getString("name");
+            player.color.set(Core.settings.getInt("color-0"));
+
             Log.info("Connecting to server: @", packet.addressTCP);
+            String ip = packet.addressTCP;
+            if (ip.contains("/")) {
+                ip = ip.substring(ip.indexOf("/") + 1);
+            }
+            if (USIDDialog.chooseUSID && Core.settings.getString("usid-" + ip, null) == null) {
+                disconnectQuietly();
+                USIDDialog.showSet(ip);
+                return;
+            }
 
             player.admin = false;
 
diff --git a/core/src/mindustry/core/Renderer.java b/core/src/mindustry/core/Renderer.java
index 54670380d6dbfdd947640ae3949a1ba9d7141ce8..9a56befe5e185bd9208d4090fca501606b7d7db8 100644
--- a/core/src/mindustry/core/Renderer.java
+++ b/core/src/mindustry/core/Renderer.java
@@ -28,6 +28,7 @@ import static arc.Core.*;
 import static mindustry.Vars.*;
 
 public class Renderer implements ApplicationListener{
+    public boolean fogEnabled = true;
     /** These are global variables, for headless access. Cached. */
     public static float laserOpacity = 0.5f, bridgeOpacity = 0.75f;
 
@@ -47,10 +48,11 @@ public class Renderer implements ApplicationListener{
     public @Nullable Bloom bloom;
     public @Nullable FrameBuffer backgroundBuffer;
     public FrameBuffer effectBuffer = new FrameBuffer();
+    public boolean drawBars = true;
     public boolean animateShields, drawWeather = true, drawStatus, enableEffects, drawDisplays = true, drawLight = true;
     public float weatherAlpha;
     /** minZoom = zooming out, maxZoom = zooming in */
-    public float minZoom = 1.5f, maxZoom = 6f;
+    public float minZoom = 0.25f, maxZoom = 20f;
     public Seq<EnvRenderer> envRenderers = new Seq<>();
     public ObjectMap<String, Runnable> customBackgrounds = new ObjectMap<>();
     public TextureRegion[] bubbles = new TextureRegion[16], splashes = new TextureRegion[12];
@@ -172,7 +174,7 @@ public class Renderer implements ApplicationListener{
             baseTarget = Mathf.lerp(minZoom, maxZoom, control.input.logicCutsceneZoom);
         }
 
-        float dest = Mathf.clamp(Mathf.round(baseTarget, 0.5f), minScale(), maxScale());
+        float dest = Mathf.clamp(Mathf.round(baseTarget, 0.1f), minScale(), maxScale());
         camerascale = Mathf.lerpDelta(camerascale, dest, 0.1f);
         if(Mathf.equal(camerascale, dest, 0.001f)) camerascale = dest;
         laserOpacity = settings.getInt("lasersopacity") / 100f;
@@ -181,6 +183,7 @@ public class Renderer implements ApplicationListener{
         drawStatus = settings.getBool("blockstatus");
         enableEffects = settings.getBool("effects");
         drawDisplays = !settings.getBool("hidedisplays");
+        drawBars = Core.settings.getBool("blockBars");
         drawLight = settings.getBool("drawlight", true);
 
         if(landTime > 0){
@@ -344,7 +347,7 @@ public class Renderer implements ApplicationListener{
             Draw.draw(Layer.light, lights::draw);
         }
 
-        if(enableDarkness){
+        if(Core.settings.getBool("forceEnableDarkness")&&enableDarkness){
             Draw.draw(Layer.darkness, blocks::drawDarkness);
         }
 
@@ -377,7 +380,7 @@ public class Renderer implements ApplicationListener{
         }
 
         Draw.draw(Layer.overlayUI, overlays::drawTop);
-        if(state.rules.fog) Draw.draw(Layer.fogOfWar, fog::drawFog);
+        if(state.rules.fog && (fogEnabled || state.rules.pvp && player.team().id != 255)) Draw.draw(Layer.fogOfWar, fog::drawFog);
         Draw.draw(Layer.space, this::drawLanding);
 
         Events.fire(Trigger.drawOver);
@@ -525,7 +528,7 @@ public class Renderer implements ApplicationListener{
     }
 
     public void scaleCamera(float amount){
-        targetscale *= (amount / 4) + 1;
+        targetscale *= (amount / 6) + 1;
         clampScale();
     }
 
diff --git a/core/src/mindustry/core/UI.java b/core/src/mindustry/core/UI.java
index c5b749e3802b85e30de6eb10dc470455700aa5ba..d50b6a17303711e1ae92c4a794e8515fb53850c7 100644
--- a/core/src/mindustry/core/UI.java
+++ b/core/src/mindustry/core/UI.java
@@ -20,6 +20,8 @@ import arc.scene.ui.Tooltip.*;
 import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
+import mindustry.arcModule.ARCVars;
+import mindustry.arcModule.ui.*;
 import mindustry.editor.*;
 import mindustry.game.EventType.*;
 import mindustry.gen.*;
@@ -28,6 +30,7 @@ import mindustry.logic.*;
 import mindustry.ui.*;
 import mindustry.ui.dialogs.*;
 import mindustry.ui.fragments.*;
+import mindustryX.features.ui.*;
 
 import static arc.scene.actions.Actions.*;
 import static mindustry.Vars.*;
@@ -120,6 +123,8 @@ public class UI implements ApplicationListener, Loadable{
         Tex.load();
         Icon.load();
         Styles.load();
+        RStyles.load();
+
         Tex.loadStyles();
         Fonts.loadContentIcons();
 
@@ -217,6 +222,8 @@ public class UI implements ApplicationListener, Loadable{
 
         Group group = Core.scene.root;
 
+        ARCVars.arcui.init();
+
         menuGroup.setFillParent(true);
         menuGroup.touchable = Touchable.childrenOnly;
         menuGroup.visible(() -> state.isMenu());
@@ -365,6 +372,7 @@ public class UI implements ApplicationListener, Loadable{
 
     /** Shows a fading label at the top of the screen. */
     public void showInfoToast(String info, float duration){
+        if (!info.contains("建筑过多单位") && !info.contains("可能造成服务器卡顿"))  ui.chatfrag.addMessage("[acid][公屏][white]"+info);
         var cinfo = Core.scene.find("coreinfo");
         Table table = new Table();
         table.touchable = Touchable.disabled;
@@ -381,6 +389,7 @@ public class UI implements ApplicationListener, Loadable{
 
     /** Shows a label at some position on the screen. Does not fade. */
     public void showInfoPopup(String info, float duration, int align, int top, int left, int bottom, int right){
+        if (!Core.settings.getBool("ShowInfoPopup")) return;
         Table table = new Table();
         table.setFillParent(true);
         table.touchable = Touchable.disabled;
@@ -586,7 +595,7 @@ public class UI implements ApplicationListener, Loadable{
         t.touchable = Touchable.disabled;
         t.margin(8f).add(text).style(Styles.outlineLabel).labelAlign(Align.center);
         t.update(() -> t.setPosition(Core.graphics.getWidth()/2f, Core.graphics.getHeight()/2f, Align.center));
-        t.actions(Actions.fadeOut(duration, Interp.pow4In), Actions.remove());
+        t.actions(Actions.fadeOut(Math.min(duration,30f), Interp.pow4In), Actions.remove());
         t.pack();
         t.act(0.1f);
         Core.scene.add(t);
@@ -690,23 +699,7 @@ public class UI implements ApplicationListener, Loadable{
     }
 
     public static String formatAmount(long number){
-        //prevent things like bars displaying erroneous representations of casted infinities
-        if(number == Long.MAX_VALUE) return "∞";
-        if(number == Long.MIN_VALUE) return "-∞";
-
-        long mag = Math.abs(number);
-        String sign = number < 0 ? "-" : "";
-        if(mag >= 1_000_000_000){
-            return sign + Strings.fixed(mag / 1_000_000_000f, 1) + "[gray]" + billions + "[]";
-        }else if(mag >= 1_000_000){
-            return sign + Strings.fixed(mag / 1_000_000f, 1) + "[gray]" + millions + "[]";
-        }else if(mag >= 10_000){
-            return number / 1000 + "[gray]" + thousands + "[]";
-        }else if(mag >= 1000){
-            return sign + Strings.fixed(mag / 1000f, 1) + "[gray]" + thousands + "[]";
-        }else{
-            return number + "";
-        }
+        return FormatDefault.format(number);
     }
 
     public static int roundAmount(int number){
diff --git a/core/src/mindustry/editor/EditorTool.java b/core/src/mindustry/editor/EditorTool.java
index 50c7a2aca929b532c1762a399ebc68f779ef0670..85cf245a2a85614a0eb5ebd2e670a8ab09080060 100644
--- a/core/src/mindustry/editor/EditorTool.java
+++ b/core/src/mindustry/editor/EditorTool.java
@@ -47,7 +47,7 @@ public enum EditorTool{
         }
     },
     //the "under liquid" rendering is too buggy to make public
-    pencil(KeyCode.b, "replace", "square", "drawteams"/*, "underliquid"*/){
+    pencil(KeyCode.b, "replace", "square", "drawteams", "underliquid"){
         {
             edit = true;
             draggable = true;
diff --git a/core/src/mindustry/editor/MapEditor.java b/core/src/mindustry/editor/MapEditor.java
index 96418def2fc27327d1332598acb823f4b4875613..ed0b9c3458666928e56061ce4a66c7a5f4408bf5 100644
--- a/core/src/mindustry/editor/MapEditor.java
+++ b/core/src/mindustry/editor/MapEditor.java
@@ -29,6 +29,7 @@ public class MapEditor{
     private boolean loading;
 
     public float brushSize = 1;
+    public int interval = 25;
     public int rotation;
     public Block drawBlock = Blocks.stone;
     public Team drawTeam = Team.sharded;
@@ -270,9 +271,9 @@ public class MapEditor{
     }
 
     public void drawSquare(int x, int y, Cons<Tile> drawer){
-        int clamped = (int)brushSize;
-        for(int rx = -clamped; rx <= clamped; rx++){
-            for(int ry = -clamped; ry <= clamped; ry++){
+        int clamped = (int)brushSize - 1;
+        for(int rx = -clamped/2; rx <= clamped - clamped/2; rx++){
+            for(int ry = -clamped/2; ry <= clamped - clamped/2; ry++){
                 int wx = x + rx, wy = y + ry;
 
                 if(wx < 0 || wy < 0 || wx >= width() || wy >= height()){
diff --git a/core/src/mindustry/editor/MapEditorDialog.java b/core/src/mindustry/editor/MapEditorDialog.java
index 0010346f9a9680fc25609b3d75106be012e1c15f..3300f64ae876e4f3c67ab5c2c2b1467aaffd1129 100644
--- a/core/src/mindustry/editor/MapEditorDialog.java
+++ b/core/src/mindustry/editor/MapEditorDialog.java
@@ -30,8 +30,10 @@ import mindustry.world.*;
 import mindustry.world.blocks.environment.*;
 import mindustry.world.blocks.storage.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
+import static mindustry.ui.Styles.flatToggleMenut;
 
 public class MapEditorDialog extends Dialog implements Disposable{
     private MapView view;
@@ -49,6 +51,8 @@ public class MapEditorDialog extends Dialog implements Disposable{
     private boolean shownWithMap = false;
     private Seq<Block> blocksOut = new Seq<>();
 
+    private TextField brushField;
+
     public MapEditorDialog(){
         super("");
 
@@ -600,30 +604,48 @@ public class MapEditorDialog extends Dialog implements Disposable{
 
                 tools.row();
 
-                ButtonGroup<ImageButton> teamgroup = new ButtonGroup<>();
+                mid.add(tools).top().padBottom(-6);
+                mid.row();
+
+                mid.table(to->{
+                    to.table(t->{
+                        for(Team team : Team.baseTeams){
+                            ImageButton button = new ImageButton(Tex.whiteui, Styles.clearTogglei);
+                            button.getStyle().imageUpColor = team.color;
+                            button.margin(3f);
+                            button.resizeImage(20f);
+                            button.clicked(() -> editor.drawTeam = team);
+                            button.update(() -> button.setChecked(editor.drawTeam == team));
+                            t.add(button);
+                        }
+                        t.button("[violet]+", flatToggleMenut, () -> UIExt.teamSelect.pickOne(team -> editor.drawTeam = team, editor.drawTeam)).checked(b -> !Seq.with(Team.baseTeams).contains(editor.drawTeam)).tooltip("[acid]更多队伍选择").size(30f, 30f);
+                    });
+                    to.row();
+
+                    to.table(t-> {
+                        t.add("辅助线：");
+                        t.field(Integer.toString(editor.interval), TextField.TextFieldFilter.digitsOnly, value -> {
+                            editor.interval = Integer.parseInt(value);
+                        }).valid(value -> Strings.canParsePositiveInt(value)).maxTextLength(4).width(100f);
+                    });
 
-                int i = 0;
+                    to.row();
 
-                for(Team team : Team.baseTeams){
-                    ImageButton button = new ImageButton(Tex.whiteui, Styles.clearNoneTogglei);
-                    button.margin(4f);
-                    button.getImageCell().grow();
-                    button.getStyle().imageUpColor = team.color;
-                    button.clicked(() -> editor.drawTeam = team);
-                    button.update(() -> button.setChecked(editor.drawTeam == team));
-                    teamgroup.add(button);
-                    tools.add(button);
+                    to.table(t-> {
+                        t.add("笔刷：");
+                        brushField = t.field(Float.toString(editor.brushSize), value -> {
+                            editor.brushSize = Float.parseFloat(value);
+                        }).valid(value -> Strings.canParsePositiveFloat(value)).maxTextLength(4).width(100f).get();
+                    });
 
-                    if(i++ % 3 == 2) tools.row();
-                }
+                });
 
-                mid.add(tools).top().padBottom(-6);
 
                 mid.row();
 
                 mid.table(Tex.underline, t -> {
                     Slider slider = new Slider(0, MapEditor.brushSizes.length - 1, 1, false);
-                    slider.moved(f -> editor.brushSize = MapEditor.brushSizes[(int)f]);
+                    slider.moved(f -> {editor.brushSize = MapEditor.brushSizes[(int)f];brushField.setText(Float.toString(editor.brushSize));});
                     for(int j = 0; j < MapEditor.brushSizes.length; j++){
                         if(MapEditor.brushSizes[j] == editor.brushSize){
                             slider.setValue(j);
@@ -797,7 +819,7 @@ public class MapEditorDialog extends Dialog implements Disposable{
 
             if(i == 0) editor.drawBlock = block;
 
-            if(++i % 4 == 0){
+            if(++i % Math.max(Core.settings.getInt("editorBrush"),3) == 0){
                 blockSelection.row();
             }
         }
diff --git a/core/src/mindustry/editor/MapInfoDialog.java b/core/src/mindustry/editor/MapInfoDialog.java
index 2c7e4e46ab46b6634ee9d6cca90e9c19784cadaf..9301f01951f26052c74720f41bb0417678a4caaa 100644
--- a/core/src/mindustry/editor/MapInfoDialog.java
+++ b/core/src/mindustry/editor/MapInfoDialog.java
@@ -1,8 +1,10 @@
 package mindustry.editor;
 
+import arc.Core;
 import arc.scene.ui.*;
 import arc.struct.*;
 import mindustry.*;
+import mindustry.arcModule.ui.*;
 import mindustry.game.*;
 import mindustry.gen.*;
 import mindustry.io.*;
@@ -13,14 +15,14 @@ import mindustry.ui.dialogs.*;
 import static mindustry.Vars.*;
 
 public class MapInfoDialog extends BaseDialog{
-    private final WaveInfoDialog waveInfo;
+    private final ArcWaveInfoDialog waveInfo;
     private final MapGenerateDialog generate;
     private final CustomRulesDialog ruleInfo = new CustomRulesDialog();
     private final MapObjectivesDialog objectives = new MapObjectivesDialog();
 
     public MapInfoDialog(){
         super("@editor.mapinfo");
-        this.waveInfo = new WaveInfoDialog();
+        this.waveInfo = new ArcWaveInfoDialog();
         this.generate = new MapGenerateDialog(false);
 
         addCloseButton();
@@ -32,12 +34,12 @@ public class MapInfoDialog extends BaseDialog{
         cont.clear();
 
         ObjectMap<String, String> tags = editor.tags;
-        
+
         cont.pane(t -> {
             t.add("@editor.mapname").padRight(8).left();
             t.defaults().padTop(15);
 
-            TextField name = t.field(tags.get("name", ""), text -> {
+            TextField name = t.field(state.isPlaying() ? state.map.name() : tags.get("name", ""), text -> {
                 tags.put("name", text);
             }).size(400, 55f).maxTextLength(50).get();
             name.setMessageText("@unknown");
@@ -45,14 +47,78 @@ public class MapInfoDialog extends BaseDialog{
             t.row();
             t.add("@editor.description").padRight(8).left();
 
-            TextArea description = t.area(tags.get("description", ""), Styles.areaField, text -> {
+            TextArea description = t.area(state.isPlaying() ? state.map.description() : tags.get("description", ""), Styles.areaField, text -> {
                 tags.put("description", text);
             }).size(400f, 140f).maxTextLength(1000).get();
 
+            t.row();
+            t.add("[acid]地图模式标签").padRight(8).left();
+
+            TextField modeName = t.field(state.isPlaying() ? state.rules.modeName : tags.get("modeName", ""), Styles.areaField, text -> {
+                tags.put("modeName", text);
+            }).size(400f, 55f).maxTextLength(1000).get();
+
+            if (Core.settings.getBool("arcPlayerList")) {
+                t.row();
+                t.add("[cyan]服务器标签").padRight(8).left();
+                t.button("编辑...", () -> {
+                    BaseDialog dialog = new BaseDialog("地图标签");
+
+                    dialog.cont.pane(td -> {
+                        td.add("[cyan]微泽系服务器标签编辑器 \n[white]BY [violet]Lucky Clover"
+                                + "\n\n[white]用于国内新版微泽系插件标签。"
+                                + "\n[orange]如果您发现标签无效，可能是您所在的服务器插件版本过低。请联系服主更新插件"
+                                + "\n所有标签与主服同步"
+                                + "\n\n[red]需要退出地图界面后重新打开才会更新"
+                                + "\n\n[white]如果有bug欢迎提出"
+                        );
+                        td.row();
+                        td.row();
+
+                        td.add("PVP保护时间(s)").left();
+                        td.field(arcReadStringLabel("@pvpProtect"), pama -> {
+                            arcAddStringLabel(pama, "@pvpProtect");
+                        }).maxTextLength(5).left();
+                        td.row();
+                        td.add("禁用队伍(如1,2,3...)").left();
+                        td.field(arcReadStringLabel("@banTeam"), pama -> {
+                            arcAddStringLabel(pama, "@banTeam");
+                        }).maxTextLength(5).left();
+                        td.row();
+                        td.add("插件选择").left();
+                        td.field(arcReadStringLabel("@mapScript"), pama -> {
+                            arcAddStringLabel(pama, "@mapScript");
+                        }).maxTextLength(6).left();
+                        td.row();
+                        td.check("空域管制 [acid]敌方核心保护区内禁止空军", arcreadBoolLable("[@limitAir]"), islimit -> {
+                            arcAddBoolLable(islimit, "[@limitAir]");
+                        }).left();
+                        td.row();
+                        td.check("塔防模式 [acid]怪物仅会在出生点地板移动，不会攻击", arcreadBoolLable("[@towerDefend]"), islimit -> {
+                            arcAddBoolLable(islimit, "[@towerDefend]");
+                        }).left();
+                        td.row();
+                        td.check("敌人掉落 [acid]非塔防模式下，打怪掉落资源", arcreadBoolLable("[@TDDrop]"), islimit -> {
+                            arcAddBoolLable(islimit, "[@TDDrop]");
+                        }).left();
+                        td.row();
+                        td.check("水漫金山 [acid]蓝队核心会释放洪水淹没你的核心", arcreadBoolLable("[@floodV2]"), islimit -> {
+                            arcAddBoolLable(islimit, "[@flood]");
+                        }).left();
+                    }).left();
+                    dialog.row();
+                    dialog.addCloseButton();
+                    dialog.margin(16f);
+
+                    dialog.show();
+                }).left().width(200f);
+            }
+
+
             t.row();
             t.add("@editor.author").padRight(8).left();
 
-            TextField author = t.field(tags.get("author", ""), text -> {
+            TextField author = t.field(state.isPlaying() ? state.map.author() : tags.get("author", ""), text -> {
                 tags.put("author", text);
             }).size(400, 55f).maxTextLength(50).get();
             author.setMessageText("@unknown");
@@ -98,9 +164,79 @@ public class MapInfoDialog extends BaseDialog{
 
             name.change();
             description.change();
+            modeName.change();
             author.change();
 
             t.margin(16f);
         });
+
+    }
+
+    private String arcReadStringLabel(String labelName) {
+        ObjectMap<String, String> tags = editor.tags;
+        String des = tags.get("description", "");
+        try {
+            int strLength = des.length();
+            int stopindex = 0;
+            for (int i = 0; i < strLength; i++) {
+                if (des.substring(i, i + 2 + labelName.length()).equals("[" + labelName + "=")) {
+                    stopindex = i;
+                    break;
+                }
+            }
+            for (int i = stopindex; i < strLength; i++) {
+                if (des.charAt(i) == ']') {
+                    return des.substring(stopindex + 2 + labelName.length(), i);
+                }
+            }
+        } catch (Exception e) {
+        }
+        return "<未设定参数>";
+    }
+
+    private void arcAddStringLabel(String parameter, String labelName) {
+        ObjectMap<String, String> tags = editor.tags;
+        String des = tags.get("description", "");
+        if (des.contains(labelName)) {
+            try {
+                int strLength = des.length();
+                int stopindex = 0;
+                for (int i = 0; i < strLength; i++) {
+                    if (des.substring(i, i + 2 + labelName.length()).equals("[" + labelName + "=")) {
+                        stopindex = i;
+                        break;
+                    }
+                }
+                for (int i = stopindex; i < strLength; i++) {
+                    if (des.charAt(i) == ']') {
+                        des = des.substring(0, stopindex + 2 + labelName.length()) + parameter + des.substring(i, strLength + 1);
+                        tags.put("description", des);
+                        break;
+                    }
+                }
+            } catch (Exception e) {
+            }
+        } else {
+            tags.put("description", des.concat("[" + labelName + "=" + parameter + "]"));
+        }
+    }
+
+    private boolean arcreadBoolLable(String labelname) {
+        ObjectMap<String, String> tags = editor.tags;
+        if (tags.get("description", "").contains(labelname)) {
+            return Boolean.TRUE;
+        } else {
+            return Boolean.FALSE;
+        }
+    }
+
+    private void arcAddBoolLable(Boolean isadd, String labelname) {
+        ObjectMap<String, String> tags = editor.tags;
+        String des = tags.get("description", "");
+        if (des.contains(labelname) && !isadd) {
+            tags.put("description", des.replace(labelname, ""));
+        } else if (!des.contains(labelname) && isadd) {
+            tags.put("description", des.concat(labelname));
+        }
     }
 }
diff --git a/core/src/mindustry/editor/MapResizeDialog.java b/core/src/mindustry/editor/MapResizeDialog.java
index 7a5c15ce71ac487492b0685e7cc99d061bae5b76..531e545323ec177de4a0ae29a2986dfaeb898402 100644
--- a/core/src/mindustry/editor/MapResizeDialog.java
+++ b/core/src/mindustry/editor/MapResizeDialog.java
@@ -9,7 +9,7 @@ import mindustry.ui.dialogs.*;
 import static mindustry.Vars.*;
 
 public class MapResizeDialog extends BaseDialog{
-    public static int minSize = 50, maxSize = 600, increment = 50;
+    public static int minSize = 10, maxSize = 9999, increment = 50;
 
     int width, height, shiftX, shiftY;
 
@@ -31,7 +31,7 @@ public class MapResizeDialog extends BaseDialog{
                 table.field((w ? width : height) + "", TextFieldFilter.digitsOnly, value -> {
                     int val = Integer.parseInt(value);
                     if(w) width = val; else height = val;
-                }).valid(value -> Strings.canParsePositiveInt(value) && Integer.parseInt(value) <= maxSize && Integer.parseInt(value) >= minSize).maxTextLength(3);
+                }).valid(value -> Strings.canParsePositiveInt(value) && Integer.parseInt(value) <= maxSize && Integer.parseInt(value) >= minSize).maxTextLength(4);
 
                 table.row();
             }
diff --git a/core/src/mindustry/editor/MapView.java b/core/src/mindustry/editor/MapView.java
index dd1c447f6192caa90dfc39d3cdce89368e148f3c..fa7f84cc9638b79900809ebd8f5c0c5e0c741a72 100644
--- a/core/src/mindustry/editor/MapView.java
+++ b/core/src/mindustry/editor/MapView.java
@@ -268,6 +268,39 @@ public class MapView extends Element implements GestureListener{
             Lines.line(centerx - sclwidth/2f, centery, centerx + sclwidth/2f, centery);
             Lines.line(centerx, centery - sclheight/2f, centerx, centery + sclheight/2f);
 
+            Draw.color(Color.orange);
+            Draw.alpha(0.5f);
+
+            float diagonal = Math.max(sclwidth/2f,sclheight/2f);
+
+            Lines.line(centerx - diagonal, centery - diagonal, centerx + diagonal, centery + diagonal);
+            Lines.line(centerx - diagonal, centery + diagonal, centerx + diagonal, centery - diagonal);
+
+            float tileCorr = 5.051f;//LC: anuke这什么几把画图算法，为了对齐只能做这种小数
+
+            if (width>20f && editor.interval>1){
+                for(int count = 1; count < width / editor.interval / tilesize ; count += 1){
+                    float dx = tileCorr * zoom * editor.interval * count;
+                    Draw.color(Color.cyan);
+                    Draw.alpha(0.5f);
+
+                    Lines.line(centerx + dx, centery - sclheight/2f, centerx + dx, centery + sclheight/2f);
+                    Lines.line(centerx - dx, centery - sclheight/2f, centerx - dx, centery + sclheight/2f);
+                }
+            }
+
+            if (height>20f && editor.interval>1){
+                for(int count = 1; count < height / editor.interval / tilesize ; count += 1){
+
+                    float dy = tileCorr * zoom * editor.interval * count;
+                    Draw.color(Color.acid);
+                    Draw.alpha(0.5f);
+
+                    Lines.line(centerx - sclwidth/2f,centery + dy , centerx + sclwidth/2f, centery + dy);
+                    Lines.line(centerx - sclwidth/2f, centery - dy, centerx + sclwidth/2f, centery - dy);
+                }
+            }
+
             Draw.reset();
         }
 
@@ -284,14 +317,16 @@ public class MapView extends Element implements GestureListener{
         Draw.color(Pal.accent);
         Lines.stroke(Scl.scl(2f));
 
+        Vec2[] arcBrushPolygons = Geometry.pixelCircle(editor.brushSize, (arcIndex, x, y) -> Mathf.dst(x, y, arcIndex - editor.brushSize % 1f, arcIndex - editor.brushSize % 1f) <= editor.brushSize - 0.5f);
+
         if((!editor.drawBlock.isMultiblock() || tool == EditorTool.eraser) && tool != EditorTool.fill){
             if(tool == EditorTool.line && drawing){
                 Vec2 v1 = unproject(startx, starty).add(x, y);
                 float sx = v1.x, sy = v1.y;
                 Vec2 v2 = unproject(lastx, lasty).add(x, y);
 
-                Lines.poly(brushPolygons[index], sx, sy, scaling);
-                Lines.poly(brushPolygons[index], v2.x, v2.y, scaling);
+                Lines.poly(arcBrushPolygons, sx, sy, scaling);
+                Lines.poly(arcBrushPolygons, v2.x, v2.y, scaling);
             }
 
             if((tool.edit || (tool == EditorTool.line && !drawing)) && (!mobile || drawing)){
@@ -300,9 +335,10 @@ public class MapView extends Element implements GestureListener{
 
                 //pencil square outline
                 if(tool == EditorTool.pencil && tool.mode == 1){
-                    Lines.square(v.x + scaling/2f, v.y + scaling/2f, scaling * ((editor.brushSize == 1.5f ? 1f : editor.brushSize) + 0.5f));
+                    float xCorr = ((int)editor.brushSize + 1) % 2 * tilesize * zoom / 4;
+                    Lines.square(v.x + xCorr + scaling/2f, v.y + xCorr + scaling/2f, scaling * (editor.brushSize/2));
                 }else{
-                    Lines.poly(brushPolygons[index], v.x, v.y, scaling);
+                    Lines.poly(arcBrushPolygons, v.x, v.y, scaling);
                 }
             }
         }else{
diff --git a/core/src/mindustry/entities/EntityGroup.java b/core/src/mindustry/entities/EntityGroup.java
index 48be2883457e5afad30946e1acdaf972ebce5658..7944ef8614c4f37a581103bff0580b547fc0cd32 100644
--- a/core/src/mindustry/entities/EntityGroup.java
+++ b/core/src/mindustry/entities/EntityGroup.java
@@ -5,6 +5,7 @@ import arc.func.*;
 import arc.math.geom.*;
 import arc.struct.*;
 import arc.util.*;
+import mindustry.arcModule.ARCVars;
 import mindustry.gen.*;
 
 import java.util.*;
@@ -79,8 +80,22 @@ public class EntityGroup<T extends Entityc> implements Iterable<T>{
     }
 
     public void update(){
-        for(index = 0; index < array.size; index++){
-            array.items[index].update();
+        if (!ARCVars.limitUpdate) {
+            for (index = 0; index < array.size; index++) {
+                array.items[index].update();
+            }
+            return;
+        }
+        float x = Core.camera.position.x - Core.camera.width / 2 - ARCVars.limitDst, y = Core.camera.position.y - Core.camera.height / 2 - ARCVars.limitDst;
+        float dx = x + Core.camera.width + ARCVars.limitDst * 2, dy = y + Core.camera.height + ARCVars.limitDst * 2;
+        for (index = 0; index < array.size; index++) {
+            Entityc e = array.items[index];
+            if (e instanceof Posc p) {
+                float ex = p.x(), ey = p.y();
+                if (x < ex && ex < dx && y < ey && ey < dy) e.update();
+                continue;
+            }
+            e.update();
         }
     }
 
diff --git a/core/src/mindustry/entities/abilities/ShieldArcAbility.java b/core/src/mindustry/entities/abilities/ShieldArcAbility.java
index 548a123899a8a86ba797f318f2b2bae8845293e7..96e6e497d5eadb9d297118a8fc3bd5b78ac9eaec 100644
--- a/core/src/mindustry/entities/abilities/ShieldArcAbility.java
+++ b/core/src/mindustry/entities/abilities/ShieldArcAbility.java
@@ -14,6 +14,7 @@ import mindustry.graphics.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.meta.*;
+import mindustryX.features.ui.*;
 
 public class ShieldArcAbility extends Ability{
     private static Unit paramUnit;
@@ -133,6 +134,6 @@ public class ShieldArcAbility extends Ability{
 
     @Override
     public void displayBars(Unit unit, Table bars){
-        bars.add(new Bar("stat.shieldhealth", Pal.accent, () -> data / max)).row();
+        bars.add(new Bar(() -> (data < 0 ? "[red]" : "") + "\uE84D " + FormatDefault.percent(data, max), () -> Pal.accent, () -> data / max)).row();
     }
 }
diff --git a/core/src/mindustry/entities/comp/BuildingComp.java b/core/src/mindustry/entities/comp/BuildingComp.java
index d45ac2cc96780058becfa34b8a7b8b8f5ac9db12..53da7fbb66e927f42a9a6d3cc078188f0d100abd 100644
--- a/core/src/mindustry/entities/comp/BuildingComp.java
+++ b/core/src/mindustry/entities/comp/BuildingComp.java
@@ -16,6 +16,7 @@ import arc.util.*;
 import arc.util.io.*;
 import mindustry.*;
 import mindustry.annotations.Annotations.*;
+import mindustry.arcModule.ARCVars;
 import mindustry.audio.*;
 import mindustry.content.*;
 import mindustry.core.*;
@@ -76,6 +77,7 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
 
     transient boolean enabled = true;
     transient @Nullable Building lastDisabler;
+    transient @Nullable Building lastLogicController;
 
     @Nullable PowerModule power;
     @Nullable ItemModule items;
@@ -1160,6 +1162,20 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
         }
     }
 
+    public void drawBars(){
+        Draw.z(Layer.turret + 4f);
+        if(maxHealth < Core.settings.getInt("blockbarminhealth") || (health / maxHealth > 0.9f )) return;
+        Draw.color(team.color, 0.3f);
+        Lines.stroke(4f);
+        Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+            x + block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f);
+        Draw.color(Pal.health ,0.6f);
+        Lines.stroke(2f);
+        Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+            x + 0.6f * (Mathf.clamp(health / maxHealth, 0f, 1f) - 0.5f) * block.size * tilesize, y + block.size * tilesize / 2.5f);
+        Draw.color();
+    }
+
     public void drawCracks(){
         if(!block.drawCracks || !damaged() || block.size > BlockRenderer.maxCrackSize) return;
         int id = pos();
@@ -1386,7 +1402,8 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
         //derelict team icon currently doesn't display
         return team == Team.derelict ?
             block.localizedName + "\n" + Core.bundle.get("block.derelict") :
-            block.localizedName + (team == player.team() || team.emoji.isEmpty() ? "" : " " + team.emoji);
+                "[#" + team.color + "]" + (Core.settings.getBool("colorizedContent") && block.localizedName.length() > 11 ? block.localizedName.substring(11) : block.localizedName) + (team == player.team() || team.emoji.isEmpty() ? "" : " " + team.emoji
+                + (team.id > 5 ? "[" + team.id + "]" : ""));
     }
 
     public TextureRegion getDisplayIcon(){
@@ -1409,8 +1426,8 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
 
         table.row();
 
-        //only display everything else if the team is the same
-        if(team == player.team()){
+        //only display everything else if the team is the same LC modified
+        if(ARCVars.arcInfoControl(team)){
             table.table(bars -> {
                 bars.defaults().growX().height(18f).pad(4);
 
@@ -1511,6 +1528,15 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
             table.add(result).growX();
             table.row();
         }
+        if (lastLogicController != null) {
+            table.add(lastLogicController.block.emoji() + " [lightgray](" + lastLogicController.tileX() + ", " + lastLogicController.tileY() + ")").growX().left().row();
+        }
+        if (Time.time < healSuppressionTime){
+            table.add("\uF89B[red]\uE815").update(label -> {
+                if (healSuppressionTime > 0) label.setText("\uF89B[red]\uE815 [white]~ " + UI.formatTime(healSuppressionTime - Time.time));
+                else label.visible = false;
+            }).row();
+        }
     }
 
      /** Called when this block is tapped to build a UI on the table.
@@ -1526,7 +1552,12 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
 
     /** Returns whether a hand cursor should be shown over this block. */
     public Cursor getCursor(){
-        return block.configurable && interactable(player.team()) ? SystemCursor.hand : SystemCursor.arrow;
+        if (Core.settings.getBool("showOtherTeamState")){
+            return block.configurable  ? SystemCursor.hand : SystemCursor.arrow;
+        }
+        else{
+            return block.configurable && interactable(player.team()) ? SystemCursor.hand : SystemCursor.arrow;
+        }
     }
 
     /**
diff --git a/core/src/mindustry/entities/comp/PlayerComp.java b/core/src/mindustry/entities/comp/PlayerComp.java
index c995d3d9f0cfb8b0bda22026fa1d6dc9bc6a6cfa..e1bb5cf5b978266cf22407a7ca3e693dd37fccf0 100644
--- a/core/src/mindustry/entities/comp/PlayerComp.java
+++ b/core/src/mindustry/entities/comp/PlayerComp.java
@@ -21,6 +21,8 @@ import mindustry.net.Administration.*;
 import mindustry.net.*;
 import mindustry.net.Packets.*;
 import mindustry.ui.*;
+import mindustry.world.blocks.defense.turrets.BaseTurret;
+import mindustry.world.blocks.production.GenericCrafter;
 import mindustry.world.blocks.storage.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
 
@@ -291,7 +293,7 @@ abstract class PlayerComp implements UnitController, Entityc, Syncc, Timerc, Dra
         font.getData().setScale(0.25f / Scl.scl(1f));
         layout.setText(font, name);
 
-        if(!isLocal()){
+        if(Core.settings.getBool("arcSelfName") || !isLocal()){
             Draw.color(0f, 0f, 0f, 0.3f);
             Fill.rect(unit.x, unit.y + nameHeight - layout.height / 2, layout.width + 2, layout.height + 3);
             Draw.color();
@@ -356,6 +358,28 @@ abstract class PlayerComp implements UnitController, Entityc, Syncc, Timerc, Dra
         }
     }
 
+    public void buildDestroyedBlocks() {
+        if (unit.canBuild()) {
+            int count = 0;
+            for (Teams.BlockPlan plan : player.team().data().plans) {
+                if (within(plan.x * tilesize, plan.y * tilesize, buildingRange)) {
+                    unit.addBuild(new BuildPlan(plan.x, plan.y, plan.rotation, content.block(plan.block), plan.config));
+                    if (++count >= 255) break;
+                }
+            }
+        }
+    }
+
+    public void dropItems() {
+        if (state.rules.mode() == Gamemode.pvp || player.unit() == null || player.unit().stack.amount <= 0) {
+            return;
+        }
+        indexer.eachBlock(player.team(), player.x, player.y, itemTransferRange,
+                build -> build.acceptStack(player.unit().item(), player.unit().stack.amount, player.unit()) > 0 && (
+                        build.block instanceof BaseTurret || build.block instanceof GenericCrafter)
+                , build -> Call.transferInventory(player, build)
+        );
+    }
     void sendUnformatted(String unformatted){
         sendUnformatted(null, unformatted);
     }
diff --git a/core/src/mindustry/entities/comp/ShieldComp.java b/core/src/mindustry/entities/comp/ShieldComp.java
index ca70594caf12ea870044f453a2900d342010f076..0eb592d00ed8763eddd9d5fd9bcb8338fd5b09ce 100644
--- a/core/src/mindustry/entities/comp/ShieldComp.java
+++ b/core/src/mindustry/entities/comp/ShieldComp.java
@@ -1,5 +1,6 @@
 package mindustry.entities.comp;
 
+import arc.math.WindowedMean;
 import arc.util.*;
 import mindustry.*;
 import mindustry.annotations.Annotations.*;
@@ -22,6 +23,8 @@ abstract class ShieldComp implements Healthc, Posc{
     transient float armor;
     /** Shield opacity. */
     transient float shieldAlpha = 0f;
+    transient float lastHealth = 0f, lastShield = 0f;
+    transient WindowedMean healthBalance = new WindowedMean(120);
 
     @Replace
     @Override
@@ -70,5 +73,8 @@ abstract class ShieldComp implements Healthc, Posc{
     public void update(){
         shieldAlpha -= Time.delta / 15f;
         if(shieldAlpha < 0) shieldAlpha = 0f;
+        healthBalance.add(((health - lastHealth) + (shield - lastShield)) / Time.delta);
+        lastHealth = health;
+        lastShield = shield;
     }
 }
diff --git a/core/src/mindustry/entities/comp/StatusComp.java b/core/src/mindustry/entities/comp/StatusComp.java
index 0f956377076bf87615678ea8a8c3b9bccb73f5f6..b17a644f2361edc97b94aee2968b053d36565399 100644
--- a/core/src/mindustry/entities/comp/StatusComp.java
+++ b/core/src/mindustry/entities/comp/StatusComp.java
@@ -163,4 +163,16 @@ abstract class StatusComp implements Posc, Flyingc{
     boolean hasEffect(StatusEffect effect){
         return applied.get(effect.id);
     }
+    void addEntry(StatusEffect effect, float duration) {
+        if (effect.reactive) apply(effect);
+        else {
+            StatusEntry entry = Pools.obtain(StatusEntry.class, StatusEntry::new);
+            entry.set(effect, duration);
+            statuses.add(entry);
+            effect.applied(self(), duration, false);
+        }
+    }
+    Seq<StatusEntry> statuses(){
+        return statuses;
+    }
 }
diff --git a/core/src/mindustry/game/Schematic.java b/core/src/mindustry/game/Schematic.java
index 75ac43ec66aa09576dc82bfeeaa726e68321ef8e..b96abdfe1253f3b01e28060ec62d005ccf62d9cf 100644
--- a/core/src/mindustry/game/Schematic.java
+++ b/core/src/mindustry/game/Schematic.java
@@ -8,7 +8,15 @@ import mindustry.mod.Mods.*;
 import mindustry.type.*;
 import mindustry.world.*;
 import mindustry.world.blocks.power.*;
+import mindustry.world.blocks.production.Fracker;
+import mindustry.world.blocks.production.GenericCrafter;
+import mindustry.world.blocks.production.Separator;
 import mindustry.world.blocks.storage.*;
+import mindustry.world.consumers.ConsumeItems;
+import mindustry.world.consumers.ConsumeLiquid;
+import mindustry.world.consumers.ConsumeLiquids;
+
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import static mindustry.Vars.*;
 
@@ -23,6 +31,9 @@ public class Schematic implements Publishable, Comparable<Schematic>{
     /** Associated mod. If null, no mod is associated with this schematic. */
     public @Nullable LoadedMod mod;
 
+    public ObjectFloatMap<Item> items;
+    public ObjectFloatMap<Liquid> liquids;
+
     public Schematic(Seq<Stile> tiles, StringMap tags, int width, int height){
         this.tiles = tiles;
         this.tags = tags;
@@ -30,6 +41,15 @@ public class Schematic implements Publishable, Comparable<Schematic>{
         this.height = height;
     }
 
+    public boolean containsBlock(Block block){
+        AtomicBoolean contains = new AtomicBoolean(false);
+        tiles.each(t -> {
+            if(t.block == block) contains.set(true);
+        });
+        return contains.get();
+
+    }
+
     public float powerProduction(){
         return tiles.sumf(s -> s.block instanceof PowerGenerator p ? p.powerProduction : 0f);
     }
@@ -38,6 +58,143 @@ public class Schematic implements Publishable, Comparable<Schematic>{
         return tiles.sumf(s -> s.block.consPower != null ? s.block.consPower.usage : 0f);
     }
 
+    public void calProduction() {
+        items = new ObjectFloatMap<>(content.items().copy().size << 1);
+        liquids = new ObjectFloatMap<>(content.liquids().copy().size << 1);
+        tiles.each(t -> {
+            if(t.block== null)
+                return;
+
+            if (t.block instanceof GenericCrafter gc) {
+                for(var c:gc.consumeBuilder){
+                    if(c.optional) continue;
+                    else if(c instanceof ConsumeItems consumeItems){
+                        for (ItemStack stack : consumeItems.items) {
+                            Item item = stack.item;
+                            items.put(item, items.get(item, 0) - stack.amount * 60f / gc.craftTime);
+                        }
+                    }
+                    else if(c instanceof ConsumeLiquid consumeLiquid){
+                        Liquid liquid = consumeLiquid.liquid;
+                        liquids.put(liquid, liquids.get(liquid, 0) - consumeLiquid.amount * 60f);
+                    }
+                    else if(c instanceof ConsumeLiquids consumeLiquids){
+                        for (LiquidStack stack : consumeLiquids.liquids) {
+                            Liquid liquid = stack.liquid;
+                            liquids.put(liquid, liquids.get(liquid, 0) - stack.amount * 60f);
+                        }
+                    }
+                }
+                if(gc.outputsItems()){
+                    for (ItemStack stack : gc.outputItems) {
+                        Item item = stack.item;
+                        items.put(item, items.get(item, 0) + stack.amount * 60f / gc.craftTime);
+                    }
+                }/*
+                if(gc.outputLiquid != null){
+                    liquids.put(gc.outputLiquid.liquid, liquids.get(gc.outputLiquid.liquid, 0) + gc.outputLiquid.amount * 60f);
+                }*/
+                if(gc.outputLiquids !=null) {
+                    for (LiquidStack stack : gc.outputLiquids) {
+                        Liquid liquid = stack.liquid;
+                        liquids.put(liquid, liquids.get(liquid, 0) + stack.amount * 60f);
+                    }
+                }
+            }
+            else if (t.block instanceof Separator s) {
+                for(var c:s.consumeBuilder){
+                    if(c.optional) continue;
+                    else if(c instanceof ConsumeItems consumeItems){
+                        for (ItemStack stack : consumeItems.items) {
+                            Item item = stack.item;
+                            items.put(item, items.get(item, 0) - stack.amount * 60f / s.craftTime);
+                        }
+                    }
+                    else if (c instanceof ConsumeLiquid consumeLiquid) {
+                        Liquid liquid = consumeLiquid.liquid;
+                        liquids.put(liquid, liquids.get(liquid, 0) - consumeLiquid.amount * 60f);
+                    }
+                }
+            }
+            else if (t.block instanceof Fracker f) {
+                for(var c:f.consumeBuilder) {
+                    if (c.optional) continue;
+                    else if (c instanceof ConsumeItems consumeItems) {
+                        for (ItemStack stack : consumeItems.items) {
+                            Item item = stack.item;
+                            items.put(item, items.get(item, 0) - stack.amount * f.itemUseTime / 60f);
+                        }
+                    }
+                }
+            }
+            else if (t.block instanceof PowerGenerator) {
+                if (t.block instanceof  ConsumeGenerator cg) {
+                    for(var c:cg.consumeBuilder){
+                        if(c.optional) continue;
+                        else if(c instanceof ConsumeItems consumeItems){
+                            for (ItemStack stack : consumeItems.items) {
+                                Item item = stack.item;
+                                items.put(item, items.get(item, 0) - stack.amount * 60f / cg.itemDuration);
+                            }
+                        }
+                        else if(c instanceof ConsumeLiquid consumeLiquid){
+                            Liquid liquid = consumeLiquid.liquid;
+                            liquids.put(liquid, liquids.get(liquid, 0) - consumeLiquid.amount * 60f);
+                        }
+                        else if(c instanceof ConsumeLiquids consumeLiquids){
+                            for (LiquidStack stack : consumeLiquids.liquids) {
+                                Liquid liquid = stack.liquid;
+                                liquids.put(liquid, liquids.get(liquid, 0) - stack.amount * 60f);
+                            }
+                        }
+                    }
+                }
+                else if (t.block instanceof NuclearReactor nr) {
+                    for(var c:nr.consumeBuilder){
+                        if(c.optional) continue;
+                        else if(c instanceof ConsumeItems consumeItems){
+                            for (ItemStack stack : consumeItems.items) {
+                                Item item = stack.item;
+                                items.put(item, items.get(item, 0) - stack.amount * 60f / nr.itemDuration);
+                            }
+                        }
+                        else if(c instanceof ConsumeLiquid consumeLiquid){
+                            Liquid liquid = consumeLiquid.liquid;
+                            liquids.put(liquid, liquids.get(liquid, 0) - consumeLiquid.amount * 60f);
+                        }
+                        else if(c instanceof ConsumeLiquids consumeLiquids){
+                            for (LiquidStack stack : consumeLiquids.liquids) {
+                                Liquid liquid = stack.liquid;
+                                liquids.put(liquid, liquids.get(liquid, 0) - stack.amount * 60f);
+                            }
+                        }
+                    }
+                }
+                else if (t.block instanceof ImpactReactor ir) {
+                    for(var c:ir.consumeBuilder){
+                        if(c.optional) continue;
+                        else if(c instanceof ConsumeItems consumeItems){
+                            for (ItemStack stack : consumeItems.items) {
+                                Item item = stack.item;
+                                items.put(item, items.get(item, 0) - stack.amount * 60f / ir.itemDuration);
+                            }
+                        }
+                        else if(c instanceof ConsumeLiquid consumeLiquid){
+                            Liquid liquid = consumeLiquid.liquid;
+                            liquids.put(liquid, liquids.get(liquid, 0) - consumeLiquid.amount * 60f);
+                        }
+                        else if(c instanceof ConsumeLiquids consumeLiquids){
+                            for (LiquidStack stack : consumeLiquids.liquids) {
+                                Liquid liquid = stack.liquid;
+                                liquids.put(liquid, liquids.get(liquid, 0) - stack.amount * 60f);
+                            }
+                        }
+                    }
+                }
+            }
+        });
+    }
+
     public ItemSeq requirements(){
         ItemSeq requirements = new ItemSeq();
 
@@ -142,6 +299,12 @@ public class Schematic implements Publishable, Comparable<Schematic>{
             block = Blocks.air;
         }
 
+        public Stile(Block block, int x, int y){
+            this.block = block;
+            this.x = (short)x;
+            this.y = (short)y;
+        }
+
         public Stile set(Stile other){
             block = other.block;
             x = other.x;
diff --git a/core/src/mindustry/game/Schematics.java b/core/src/mindustry/game/Schematics.java
index 32b304f3e9e708aed49ad1c43b3165dbfcb23873..ab05df5b9e0e70f714cc96adefb58e4f534b4d1e 100644
--- a/core/src/mindustry/game/Schematics.java
+++ b/core/src/mindustry/game/Schematics.java
@@ -15,6 +15,7 @@ import arc.util.io.Streams.*;
 import arc.util.pooling.*;
 import arc.util.serialization.*;
 import mindustry.*;
+import mindustry.arcModule.ARCVars;
 import mindustry.content.*;
 import mindustry.core.*;
 import mindustry.ctype.*;
@@ -34,6 +35,7 @@ import mindustry.world.blocks.sandbox.*;
 import mindustry.world.blocks.storage.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
 import mindustry.world.meta.*;
+import mindustryX.features.ui.*;
 
 import java.io.*;
 import java.util.zip.*;
@@ -97,7 +99,8 @@ public class Schematics implements Loadable{
         all.sort();
 
         if(shadowBuffer == null){
-            Core.app.post(() -> shadowBuffer = new FrameBuffer(maxSchematicSize + padding + 8, maxSchematicSize + padding + 8));
+            var size = Math.min(maxSchematicSize, 1024) + padding + 8;
+            Core.app.post(() -> shadowBuffer = new FrameBuffer(size, size));
         }
     }
 
@@ -276,7 +279,7 @@ public class Schematics implements Loadable{
     /** Creates an array of build plans from a schematic's data, centered on the provided x+y coordinates. */
     public Seq<BuildPlan> toPlans(Schematic schem, int x, int y){
         return schem.tiles.map(t -> new BuildPlan(t.x + x - schem.width/2, t.y + y - schem.height/2, t.rotation, t.block, t.config).original(t.x, t.y, schem.width, schem.height))
-            .removeAll(s -> (!s.block.isVisible() && !(s.block instanceof CoreBlock)) || !s.block.unlockedNow()).sort(Structs.comparingInt(s -> -s.block.schematicPriority));
+            .removeAll(s -> !AdvanceToolTable.forcePlacement && ((!s.block.isVisible() && !(s.block instanceof CoreBlock)) || !s.block.unlockedNow())).sort(Structs.comparingInt(s -> -s.block.schematicPriority));
     }
 
     /** @return all the valid loadouts for a specific core type. */
@@ -542,7 +545,7 @@ public class Schematics implements Loadable{
         try(DataInputStream stream = new DataInputStream(new InflaterInputStream(input))){
             short width = stream.readShort(), height = stream.readShort();
 
-            if(width > 128 || height > 128) throw new IOException("Invalid schematic: Too large (max possible size is 128x128)");
+            if(width > 1024 || height > 1024) throw new IOException("Invalid schematic: Too large (max possible size is 128x128)");
 
             StringMap map = new StringMap();
             int tags = stream.readUnsignedByte();
@@ -568,7 +571,7 @@ public class Schematics implements Loadable{
 
             int total = stream.readInt();
 
-            if(total > 128 * 128) throw new IOException("Invalid schematic: Too many blocks.");
+            if(maxSchematicSize != Integer.MAX_VALUE && total > maxSchematicSize * maxSchematicSize) throw new IOException("Invalid schematic: Too many blocks.");
 
             Seq<Stile> tiles = new Seq<>(total);
             for(int i = 0; i < total; i++){
diff --git a/core/src/mindustry/game/Universe.java b/core/src/mindustry/game/Universe.java
index 4aa77d8be7d4876022746b93046e0e8587b9052b..849a46f6bae96b5a65e4874b2621acfcc7e4ded9 100644
--- a/core/src/mindustry/game/Universe.java
+++ b/core/src/mindustry/game/Universe.java
@@ -20,7 +20,7 @@ public class Universe{
     private int netSeconds;
     private float secondCounter;
     private int turn;
-    private float turnCounter;
+    public static float turnCounter;
 
     private @Nullable Schematic lastLoadout;
     private ItemSeq lastLaunchResources = new ItemSeq();
diff --git a/core/src/mindustry/graphics/BlockRenderer.java b/core/src/mindustry/graphics/BlockRenderer.java
index 8e6bb188cd42409bdcbda2a357b96a27d9ccedba..e6f14c81d20925d45189e176e2ad497dca707cfe 100644
--- a/core/src/mindustry/graphics/BlockRenderer.java
+++ b/core/src/mindustry/graphics/BlockRenderer.java
@@ -10,6 +10,7 @@ import arc.math.geom.*;
 import arc.struct.*;
 import arc.util.*;
 import mindustry.*;
+import mindustry.arcModule.ARCVars;
 import mindustry.content.*;
 import mindustry.game.EventType.*;
 import mindustry.game.*;
@@ -444,14 +445,25 @@ public class BlockRenderer{
                         Draw.z(Layer.block);
                     }
 
+                    if(renderer.drawBars){
+                        build.drawBars();
+                        Draw.z(Layer.block);
+                    }
+
                     if(build.team != pteam){
                         if(build.block.drawTeamOverlay){
                             build.drawTeam();
                             Draw.z(Layer.block);
                         }
-                    }else if(renderer.drawStatus && block.hasConsumers){
+                    }
+                    if(renderer.drawStatus && block.hasConsumers && ARCVars.arcInfoControl(build.team)){
                         build.drawStatus();
                     }
+
+                    if(Core.settings.getBool("blockdisabled") && ARCVars.arcInfoControl(build.team) && !build.enabled()){
+                        build.drawDisabled();
+                    }
+
                 }
                 Draw.reset();
             }else if(!visible){
diff --git a/core/src/mindustry/graphics/Drawf.java b/core/src/mindustry/graphics/Drawf.java
index 0dbf5a5b3379652bab93f58034674db49d9b2121..9cf2df380e6c7b2c0cdb3dffc650950155068d92 100644
--- a/core/src/mindustry/graphics/Drawf.java
+++ b/core/src/mindustry/graphics/Drawf.java
@@ -148,6 +148,13 @@ public class Drawf{
         Drawf.line(Pal.accent, start.getX() + Tmp.v1.x, start.getY() + Tmp.v1.y, dest.getX() + Tmp.v2.x, dest.getY() + Tmp.v2.y);
     }
 
+    public static void limitLineColor(Position start, Position dest, float len1, float len2,Color color){
+        Tmp.v1.set(dest).sub(start).setLength(len1);
+        Tmp.v2.set(Tmp.v1).scl(-1f).setLength(len2);
+
+        Drawf.line(color, start.getX() + Tmp.v1.x, start.getY() + Tmp.v1.y, dest.getX() + Tmp.v2.x, dest.getY() + Tmp.v2.y);
+    }
+
     public static void dashLineDst(Color color, float x, float y, float x2, float y2){
         dashLine(color, x, y, x2, y2, (int)(Mathf.dst(x, y, x2, y2) / tilesize * 1.6f));
     }
@@ -220,6 +227,32 @@ public class Drawf{
         Draw.reset();
     }
 
+    public static void target2(float x, float y, float rad, float alpha, Color color){
+        // target but no border
+        Lines.stroke(1f);
+        Draw.color(color, alpha);
+        Lines.poly(x, y, 4, rad, Time.time * 1.5f);
+        Lines.spikes(x, y, 3f/7f * rad, 6f/7f * rad, 4, Time.time * 1.5f);
+        Draw.reset();
+    }
+
+    public static void targetc(float x, float y, float rad, float alpha, Color color){
+        // target but no border
+        Lines.stroke(1f);
+        Draw.color(color, alpha);
+        Lines.circle(x, y, rad);
+        Lines.spikes(x, y, 3f/7f * rad, 6f/7f * rad, 4, Time.time * 1.5f);
+        Draw.reset();
+    }
+
+    public static void targetd(float x, float y, float rad, float alpha, Color color){
+        // target but no border
+        Lines.stroke(1f);
+        Draw.color(color, alpha);
+        Lines.spikes(x, y, 3f/7f * rad, 6f/7f * rad, 4, Time.time * 1.5f);
+        Draw.reset();
+    }
+
     /** Sets Draw.z to the text layer, and returns the previous layer. */
     public static float text(){
         float z = Draw.z();
@@ -390,6 +423,27 @@ public class Drawf{
         Draw.color();
     }
 
+    public static void simpleArrow(float x, float y, float x2, float y2, float length, float radius){
+        float angle = Angles.angle(x, y, x2, y2);
+        Tmp.v1.set(x2, y2).sub(x, y).limit(length);
+        float vx = Tmp.v1.x + x, vy = Tmp.v1.y + y;
+        Fill.poly(vx, vy, 3, radius, angle);
+    }
+
+    public static void simpleArrow(float x, float y, float x2, float y2, float length, float radius, Color color){
+        simpleArrow(x, y, x2, y2, length, radius, color,1f);
+    }
+
+    public static void simpleArrow(float x, float y, float x2, float y2, float length, float radius, Color color,float alpha){
+        float angle = Angles.angle(x, y, x2, y2);
+        Tmp.v1.set(x2, y2).sub(x, y).limit(length);
+        float vx = Tmp.v1.x + x, vy = Tmp.v1.y + y;
+
+        Draw.color(color,alpha);
+        Fill.poly(vx, vy, 3, radius, angle);
+        Draw.color();
+    }
+
     public static void laser(TextureRegion line, TextureRegion edge, float x, float y, float x2, float y2){
         laser(line, edge, edge, x, y, x2, y2, 1f);
     }
diff --git a/core/src/mindustry/graphics/MenuRenderer.java b/core/src/mindustry/graphics/MenuRenderer.java
index 949d03f914d70c9bb9826ebeb033458fbeb19cc8..fd2e601e673dfcd266a9501db7121dd8bbbf79a9 100644
--- a/core/src/mindustry/graphics/MenuRenderer.java
+++ b/core/src/mindustry/graphics/MenuRenderer.java
@@ -27,9 +27,10 @@ public class MenuRenderer implements Disposable{
     private CacheBatch batch;
     private float time = 0f;
     private float flyerRot = 45f;
-    private int flyers = Mathf.chance(0.2) ? Mathf.random(35) : Mathf.random(15);
-    //no longer random or "dynamic", mod units in the menu look jarring, and it's not worth the configuration effort
-    private UnitType flyerType = Seq.with(UnitTypes.flare, UnitTypes.horizon, UnitTypes.zenith, UnitTypes.mono, UnitTypes.poly, UnitTypes.mega, UnitTypes.alpha, UnitTypes.beta, UnitTypes.gamma).random();
+    private int flyers = Mathf.chance(0.2) ? Mathf.random(45)  : Mathf.random(25) ;
+    //private UnitType flyerType = content.units().select(u -> !u.isHidden() && u.hitSize <= 20f && u.flying && u.region.found()).random();
+    private UnitType flyerType = content.units().select(u -> !u.isHidden() && u.hitSize >= 10f && u.region.found()).random();
+    private UnitType followType = content.units().select(u -> !u.isHidden() && u.hitSize < flyerType.hitSize*0.8f && u.region.found()).random();
 
     public MenuRenderer(){
         Time.mark();
@@ -230,7 +231,12 @@ public class MenuRenderer implements Disposable{
         batch.drawCache(cacheWall);
         batch.endDraw();
 
-        drawFlyers();
+        if (Core.settings.getBool("menuFlyersFollower")){
+            drawFollowFlyers();
+        }
+        else{
+            drawFlyers();
+        }
 
         Draw.proj(mat);
         Draw.color(0f, 0f, 0f, darkness);
@@ -238,6 +244,77 @@ public class MenuRenderer implements Disposable{
         Draw.color();
     }
 
+    private void drawFollowFlyers(){
+        Draw.color(0f, 0f, 0f, 0.4f);
+
+        TextureRegion icon = flyerType.fullIcon;
+
+        float size = Math.max(icon.width, icon.height) * Draw.scl * 1.6f;
+
+        float sizebehind = Math.max(icon.width, icon.height) * Draw.scl * 1.6f;
+
+        TextureRegion followcion = followType.fullIcon;
+        float followsize = Math.max(icon.width, icon.height) * Draw.scl * 1.6f;
+
+        flyers((x, y) -> {
+            Draw.rect(icon, x - 12f, y - 13f, flyerRot - 90);
+            Draw.rect(followcion, x - 12f - sizebehind/2, y - 13f - sizebehind/3, flyerRot - 90);
+            Draw.rect(followcion, x - 12f - sizebehind/3, y - 13f - sizebehind/2, flyerRot - 90);
+        });
+
+        flyers((x, y) -> {
+            Draw.rect("circle-shadow", x, y, size, size);
+            Draw.rect("circle-shadow", x - sizebehind/3, y - sizebehind/2, followsize, followsize);
+            Draw.rect("circle-shadow", x - sizebehind/2, y - sizebehind/3, followsize, followsize);
+        });
+        Draw.color();
+
+
+        flyers((x, y) -> {
+            float engineOffset = flyerType.engineOffset, engineSize = flyerType.engineSize, rotation = flyerRot;
+
+            Draw.color(Pal.engine);
+            Fill.circle(x + Angles.trnsx(rotation + 180, engineOffset), y + Angles.trnsy(rotation + 180, engineOffset),
+            engineSize + Mathf.absin(Time.time, 2f, engineSize / 4f));
+
+            Draw.color(Color.white);
+            Fill.circle(x + Angles.trnsx(rotation + 180, engineOffset - 1f), y + Angles.trnsy(rotation + 180, engineOffset - 1f),
+            (engineSize + Mathf.absin(Time.time, 2f, engineSize / 4f)) / 2f);
+            Draw.color();
+
+            Draw.rect(icon, x, y, flyerRot - 90);
+            //follower1
+            Draw.rect(followcion, x - sizebehind/3, y - sizebehind/2, flyerRot - 90);
+
+            //follower2
+            Draw.rect(followcion, x - sizebehind/2, y - sizebehind/3, flyerRot - 90);
+
+            if(Core.settings.getBool("menuFlyersRange")){
+                float curStroke = (float)Core.settings.getInt("playerEffectCurStroke")/10f;
+                Color effectcolor = Pal.accent;
+
+                float sectorRad = 0.14f, rotateSpeed = 0.5f;
+                int sectors = 5;
+
+                Lines.stroke(Lines.getStroke() * curStroke);
+
+                Draw.z(Layer.shields + 6.5f);
+                Draw.color(effectcolor);
+
+                //Tmp.v1.trns(flyerType.rotation - 90, x, y).add(x, y);
+                float rx = Tmp.v1.x, ry = Tmp.v1.y;
+
+                if(curStroke > 0){
+                    for(int i = 0; i < sectors; i++){
+                        float rot = i * 360f/sectors + Time.time * rotateSpeed;
+                        Lines.arc(x, y, flyerType.maxRange, sectorRad, rot);
+                    }
+                }
+                Draw.reset();
+            }
+        });
+    }
+
     private void drawFlyers(){
         Draw.color(0f, 0f, 0f, 0.4f);
 
@@ -267,6 +344,32 @@ public class MenuRenderer implements Disposable{
             Draw.color();
 
             Draw.rect(icon, x, y, flyerRot - 90);
+
+
+
+            if(Core.settings.getBool("menuFlyersRange")){
+                float curStroke = (float)Core.settings.getInt("playerEffectCurStroke")/10f;
+                Color effectcolor = Pal.accent;
+
+                float sectorRad = 0.14f, rotateSpeed = 0.5f;
+                int sectors = 5;
+
+                Lines.stroke(Lines.getStroke() * curStroke);
+
+                Draw.z(Layer.shields + 6.5f);
+                Draw.color(effectcolor);
+
+                //Tmp.v1.trns(flyerType.rotation - 90, x, y).add(x, y);
+                float rx = Tmp.v1.x, ry = Tmp.v1.y;
+
+                if(curStroke > 0){
+                    for(int i = 0; i < sectors; i++){
+                        float rot = i * 360f/sectors + Time.time * rotateSpeed;
+                        Lines.arc(x, y, flyerType.maxRange, sectorRad, rot);
+                    }
+                }
+                Draw.reset();
+            }
         });
     }
 
@@ -275,8 +378,9 @@ public class MenuRenderer implements Disposable{
         float th = height * tilesize * 1f + tilesize;
         float range = 500f;
         float offset = -100f;
+        int flyersCount = flyers + Core.settings.getInt("menuFlyersCount");
 
-        for(int i = 0; i < flyers; i++){
+        for(int i = 0; i < flyersCount; i++){
             Tmp.v1.trns(flyerRot, time * (flyerType.speed));
 
             cons.get(
diff --git a/core/src/mindustry/graphics/MinimapRenderer.java b/core/src/mindustry/graphics/MinimapRenderer.java
index e19cb5fb99d1013911ad892249a67b0575dcb1f6..2a3d3b92e5419286d1aba257e66c264e46fbc1f1 100644
--- a/core/src/mindustry/graphics/MinimapRenderer.java
+++ b/core/src/mindustry/graphics/MinimapRenderer.java
@@ -10,6 +10,7 @@ import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
 import arc.util.pooling.*;
+import mindustryX.features.MarkerType;
 import mindustry.content.*;
 import mindustry.entities.*;
 import mindustry.game.EventType.*;
@@ -32,6 +33,8 @@ public class MinimapRenderer{
 
     private float lastX, lastY, lastW, lastH, lastScl;
     private boolean worldSpace;
+    public boolean forceShowPlayer = true;
+    public boolean unitDetailsIcon = false;
     private IntSet updates = new IntSet();
     private float updateCounter = 0f;
 
@@ -104,7 +107,7 @@ public class MinimapRenderer{
     }
 
     public void setZoom(float amount){
-        zoom = Mathf.clamp(amount, 1f, Math.min(world.width(), world.height()) / baseSize / 2f);
+        zoom = Mathf.clamp(amount, 1f, Math.max(world.width(), world.height()) / baseSize / 2f);
     }
 
     public float getZoom(){
@@ -146,12 +149,41 @@ public class MinimapRenderer{
 
         rect.set((dx - sz) * tilesize, (dy - sz) * tilesize, sz * 2 * tilesize, sz * 2 * tilesize);
 
+        float Rwidth = !fullView ? Core.camera.width / rect.width * w : Core.camera.width / (world.width() * tilesize) * w;
+        float Rheight = !fullView ? Core.camera.height / rect.width * h : Core.camera.height / (world.height() * tilesize) * h;
+        Lines.rect(x + transfromX(fullView,w,Core.camera.position.x) - Rwidth/2,y + transfromY(fullView,h,Core.camera.position.y) - Rheight/2,Rwidth, Rheight );
+
+        MarkerType.eachActive(a -> {
+            Draw.color(a.color);
+            Lines.stroke(Scl.scl(3f) * (1 - (Time.time % 180 + 30) / 210));
+
+            float rx = transfromX(fullView, w, a.x);
+            float ry = transfromY(fullView, h, a.y);
+
+            Lines.circle(x + rx, y + ry, scale(100f) * (Time.time % 180) / 180);
+            Lines.stroke(Scl.scl(3f));
+            Lines.circle(x + rx, y + ry, scale(20f));
+            Lines.arc(x + rx, y + ry, scale(18f), 1 - (Time.time - a.time) / MarkerType.retainTime);
+            Draw.reset();
+        });
+
         for(Unit unit : units){
             if(unit.inFogTo(player.team()) || !unit.type.drawMinimap) continue;
 
             float rx = !fullView ? (unit.x - rect.x) / rect.width * w : unit.x / (world.width() * tilesize) * w;
             float ry = !fullView ? (unit.y - rect.y) / rect.width * h : unit.y / (world.height() * tilesize) * h;
 
+            if(unitDetailsIcon){
+                float scale = Scl.scl(1f) / 2f * scaling * 32f * unit.hitSize / tilesize / 2;
+                var region = unit.icon();
+                Draw.rect(region, x + rx, y + ry, scale, scale * (float)region.height / region.width, unit.rotation() - 90);
+                Draw.reset();
+                Draw.mixcol(unit.team.color, 0.3f);
+                Draw.rect(region, x + rx, y + ry, scale, scale * (float)region.height / region.width, unit.rotation() - 90);
+                Draw.reset();
+                continue;
+            }
+
             Draw.mixcol(unit.team.color, 1f);
             float scale = Scl.scl(1f) / 2f * scaling * 32f;
             var region = unit.icon();
@@ -159,11 +191,11 @@ public class MinimapRenderer{
             Draw.reset();
         }
 
-        if(fullView && net.active()){
+        if(net.active() && (fullView || forceShowPlayer)){
             for(Player player : Groups.player){
                 if(!player.dead()){
-                    float rx = player.x / (world.width() * tilesize) * w;
-                    float ry = player.y / (world.height() * tilesize) * h;
+                    float rx = !fullView ? (player.x - rect.x) / rect.width * w : player.x / (world.width() * tilesize) * w;
+                    float ry = !fullView ? (player.y - rect.y) / rect.width * h : player.y / (world.height() * tilesize) * h;
 
                     drawLabel(x + rx, y + ry, player.name, player.color);
                 }
@@ -260,8 +292,15 @@ public class MinimapRenderer{
         });
     }
 
+    private float transfromX(boolean withLabels,float w,float x){
+        return !withLabels ? (x - rect.x) / rect.width * w : x / (world.width() * tilesize) * w;
+    }
+    private float transfromY(boolean withLabels,float h,float y){
+        return !withLabels ? (y - rect.y) / rect.width * h : y / (world.height() * tilesize) * h;
+    }
+
     public void drawSpawns(float x, float y, float w, float h, float scaling){
-        if(!state.rules.showSpawns || !state.hasSpawns() || !state.rules.waves) return;
+        if(!(state.rules.showSpawns || Core.settings.getBool("alwaysshowdropzone")) || !state.hasSpawns() || !state.rules.waves) return;
 
         TextureRegion icon = Icon.units.getRegion();
 
@@ -302,7 +341,7 @@ public class MinimapRenderer{
     public @Nullable TextureRegion getRegion(){
         if(texture == null) return null;
 
-        float sz = Mathf.clamp(baseSize * zoom, baseSize, Math.min(world.width(), world.height()));
+        float sz = Mathf.clamp(baseSize * zoom, baseSize, Math.max(world.width(), world.height()));
         float dx = (Core.camera.position.x / tilesize);
         float dy = (Core.camera.position.y / tilesize);
         dx = Mathf.clamp(dx, sz, world.width() - sz);
diff --git a/core/src/mindustry/graphics/OverlayRenderer.java b/core/src/mindustry/graphics/OverlayRenderer.java
index cd452ca24acfa985edb46f995f9a880da0bc3dbd..2ac9284705a0bbd7230bd2dc6dc0257b327a64a0 100644
--- a/core/src/mindustry/graphics/OverlayRenderer.java
+++ b/core/src/mindustry/graphics/OverlayRenderer.java
@@ -15,10 +15,12 @@ import mindustry.game.*;
 import mindustry.game.Teams.*;
 import mindustry.gen.*;
 import mindustry.input.*;
-import mindustry.world.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
 
 import static mindustry.Vars.*;
+import static mindustry.arcModule.toolpack.arcScanMode.arcScan;
+import static mindustry.arcModule.toolpack.arcScanner.drawScanner;
+import static mindustry.arcModule.toolpack.arcWaveSpawner.drawSpawner;
 
 public class OverlayRenderer{
     private static final float indicatorLength = 14f;
@@ -182,39 +184,83 @@ public class OverlayRenderer{
                     //it must be clear that there is a core here.
                     if(/*core.wasVisible && */Core.camera.bounds(Tmp.r1).overlaps(Tmp.r2.setCentered(core.x, core.y, state.rules.enemyCoreBuildRadius * 2f))){
                         Draw.color(Color.darkGray);
+                        Draw.alpha(0.7f);
                         Lines.circle(core.x, core.y - 2, state.rules.enemyCoreBuildRadius);
                         Draw.color(Pal.accent, core.team.color, 0.5f + Mathf.absin(Time.time, 10f, 0.5f));
+                        Draw.alpha(0.7f);
                         Lines.circle(core.x, core.y, state.rules.enemyCoreBuildRadius);
                     }
                 });
-            }
-        }
+                player.team().cores().each(core ->{
+                    if(state.rules.pvp && Core.camera.bounds(Tmp.r1).overlaps(Tmp.r2.setCentered(core.x, core.y, state.rules.enemyCoreBuildRadius * 2f))){
 
-        Lines.stroke(2f);
-        Draw.color(Color.gray, Color.lightGray, Mathf.absin(Time.time, 8f, 1f));
+                        Draw.color(Color.darkGray);
+                        Draw.alpha(0.4f);
+                        Lines.circle(core.x, core.y - 2, state.rules.enemyCoreBuildRadius);
+                        Draw.color(Pal.accent, core.team.color, 0.5f + Mathf.absin(Time.time, 10f, 0.5f));
+                        Draw.alpha(0.4f);
+                        Lines.circle(core.x, core.y, state.rules.enemyCoreBuildRadius);
+                    }
 
+                });
+            }
+        }
+        /*
         if(state.hasSpawns()){
-            for(Tile tile : spawner.getSpawns()){
-                if(tile.within(player.x, player.y, state.rules.dropZoneRadius + spawnerMargin)){
-                    Draw.alpha(Mathf.clamp(1f - (player.dst(tile) - state.rules.dropZoneRadius) / spawnerMargin));
+            Lines.stroke(2f);
+            Draw.color(Color.gray, Color.lightGray, Mathf.absin(Time.time, 8f, 1f));
+
+            if (Core.settings.getBool("alwaysshowdropzone")) {
+                Draw.alpha(0.8f);
+                for(Tile tile : spawner.getSpawns()) {
                     Lines.dashCircle(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius);
                 }
             }
-        }
+            else {
+                for(Tile tile : spawner.getSpawns()) {
+                    if (tile.within(player.x, player.y, state.rules.dropZoneRadius + spawnerMargin)) {
+                        Draw.alpha(Mathf.clamp(1f - (player.dst(tile) - state.rules.dropZoneRadius) / spawnerMargin));
+                        Lines.dashCircle(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius);
+                    }
+                }
+            }
+            if (Core.settings.getBool("showFlyerSpawn") && spawner.countSpawns() < 20) {
+                for(Tile tile : spawner.getSpawns()) {
+                    float angle = Angles.angle(world.width() / 2f, world.height() / 2f, tile.x, tile.y);
+                    float trns = Math.max(world.width(), world.height()) * Mathf.sqrt2 * tilesize;
+                    float spawnX = Mathf.clamp(world.width() * tilesize / 2f + Angles.trnsx(angle, trns), 0, world.width() * tilesize);
+                    float spawnY = Mathf.clamp(world.height() * tilesize / 2f + Angles.trnsy(angle, trns), 0, world.height() * tilesize);
+                    if (Core.settings.getBool("showFlyerSpawnLine")) {
+                        Draw.color(Color.red, 0.5f);
+                        Lines.line(tile.worldx(), tile.worldy(), spawnX, spawnY);
+                    }
+                    Draw.color(Color.gray, Color.lightGray, Mathf.absin(Time.time, 8f, 1f));
+                    Draw.alpha(0.8f);
+                    Lines.dashCircle(spawnX, spawnY, 5f * tilesize);
 
-        Draw.reset();
+                    Draw.color();
+                    Draw.alpha(0.5f);
+                    Draw.rect(UnitTypes.zenith.fullIcon, spawnX, spawnY);
+                }
+            }
+            Draw.reset();
+        }
+        */
+        drawSpawner();
 
         //draw selected block
         if(input.block == null && !Core.scene.hasMouse()){
             Vec2 vec = Core.input.mouseWorld(input.getMouseX(), input.getMouseY());
             Building build = world.buildWorld(vec.x, vec.y);
 
-            if(build != null && build.team == player.team()){
+            //if(build != null && build.team == player.team()){
+            if(build != null){
                 build.drawSelect();
                 if(!build.enabled && build.block.drawDisabled){
                    build.drawDisabled();
                 }
-
+            }
+            if(build != null && build.team == player.team()){
                 if(Core.input.keyDown(Binding.rotateplaced) && build.block.rotate && build.block.quickRotate && build.interactable(player.team())){
                     control.input.drawArrow(build.block, build.tileX(), build.tileY(), build.rotation, true);
                     Draw.color(Pal.accent, 0.3f + Mathf.absin(4f, 0.2f));
@@ -226,12 +272,22 @@ public class OverlayRenderer{
 
         input.drawOverSelect();
 
+        //单位射程
+        if(ui.hudfrag.blockfrag.hover() instanceof Unit unit){
+            Draw.reset();
+            Draw.color(unit.team.color);
+            Lines.dashCircle(unit.x, unit.y, unit.type.range);
+        }
+
         if(ui.hudfrag.blockfrag.hover() instanceof Unit unit && unit.controller() instanceof LogicAI ai && ai.controller != null && ai.controller.isValid()){
             var build = ai.controller;
             Drawf.square(build.x, build.y, build.block.size * tilesize/2f + 2f);
             if(!unit.within(build, unit.hitSize * 2f)){
                 Drawf.arrow(unit.x, unit.y, build.x, build.y, unit.hitSize *2f, 4f);
             }
+			Draw.color(Pal.accent);
+            Lines.line(unit.x, unit.y, build.x, build.y);
+            Draw.color();
         }
 
         //draw selection overlay when dropping item
@@ -258,6 +314,9 @@ public class OverlayRenderer{
                 }
             }
         }
+
+        drawScanner();
+        arcScan();
     }
 
     private static class CoreEdge{
diff --git a/core/src/mindustry/input/Binding.java b/core/src/mindustry/input/Binding.java
index 7f6398a106d011022ba80b837e152a3a6d33a224..aa29727c8d724b988d3026acbf0989942ecaa5d6 100644
--- a/core/src/mindustry/input/Binding.java
+++ b/core/src/mindustry/input/Binding.java
@@ -79,6 +79,7 @@ public enum Binding implements KeyBind{
     block_info(KeyCode.f1),
     toggle_menus(KeyCode.c),
     screenshot(KeyCode.p),
+    superUnitEffect(KeyCode.o),
     toggle_power_lines(KeyCode.f5),
     toggle_block_status(KeyCode.f6),
     player_list(KeyCode.tab, "multiplayer"),
@@ -87,7 +88,11 @@ public enum Binding implements KeyBind{
     chat_history_next(KeyCode.down),
     chat_scroll(new Axis(KeyCode.scroll)),
     chat_mode(KeyCode.tab),
+    showRTSAi(KeyCode.l),
     console(KeyCode.f8),
+    arcDetail(KeyCode.unknown),
+    arcScanMode(KeyCode.unknown),
+    oreAdsorption(KeyCode.unknown),
 
     //MDTX
     toggle_unit(KeyCode.unknown),
diff --git a/core/src/mindustry/input/DesktopInput.java b/core/src/mindustry/input/DesktopInput.java
index 6d623a77a879ec2cbe74c79a3de31cd06f130416..5708a39280fc28f625d1440f7a1ff6cef904d718 100644
--- a/core/src/mindustry/input/DesktopInput.java
+++ b/core/src/mindustry/input/DesktopInput.java
@@ -13,17 +13,25 @@ import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
 import mindustry.*;
+import mindustry.content.Items;
+import mindustry.content.UnitTypes;
 import mindustry.core.*;
+import mindustry.entities.Predict;
+import mindustry.entities.Units;
 import mindustry.entities.units.*;
 import mindustry.game.EventType.*;
 import mindustry.game.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
+import mindustry.type.UnitType;
 import mindustry.ui.*;
 import mindustry.world.*;
+import mindustry.world.blocks.ControlBlock;
+import mindustryX.features.*;
 
 import static arc.Core.camera;
 import static arc.Core.*;
+import static mindustry.Vars.net;
 import static mindustry.Vars.*;
 import static mindustry.input.PlaceMode.*;
 
@@ -55,6 +63,10 @@ public class DesktopInput extends InputHandler{
     /** Time of most recent control group selection */
     public long lastCtrlGroupSelectMillis;
 
+    public boolean autoAim = false;
+    /** Current thing being shot at. */
+    public @Nullable Teamc target;
+
     boolean showHint(){
         return ui.hudfrag.shown && Core.settings.getBool("hints") && selectPlans.isEmpty() &&
             (!isBuilding && !Core.settings.getBool("buildautopause") || player.unit().isBuilding() || !player.dead() && !player.unit().spawnedByCore());
@@ -101,6 +113,10 @@ public class DesktopInput extends InputHandler{
                 b.table(a -> {
                     a.button("@schematic.add", Icon.save, this::showSchematicSave).colspan(2).size(250f, 50f).disabled(f -> lastSchematic == null || lastSchematic.file != null);
                 });
+                b.row();
+                b.table(a -> {
+                    a.button("@schematic.preview", Icon.info, this::showSchematicPreview).colspan(2).size(250f, 50f).disabled(f -> lastSchematic == null || lastSchematic.file != null);
+                });
             }).margin(6f);
         });
     }
@@ -228,7 +244,8 @@ public class DesktopInput extends InputHandler{
         }
 
         if((Math.abs(Core.input.axis(Binding.move_x)) > 0 || Math.abs(Core.input.axis(Binding.move_y)) > 0 || input.keyDown(Binding.mouse_move)) && (!scene.hasField())){
-            panning = false;
+            if(!Core.settings.getBool("removePan")) panning = false;
+            follow = null;
         }
 
         if(!locked){
@@ -265,6 +282,8 @@ public class DesktopInput extends InputHandler{
             commandMode = false;
         }
 
+        if(input.keyTap(Binding.arcScanMode)) arcScanMode = !arcScanMode;
+
         //validate commanding units
         selectedUnits.removeAll(u -> !u.isCommandable() || !u.isValid());
 
@@ -403,7 +422,8 @@ public class DesktopInput extends InputHandler{
             }
         }
 
-        if(player.dead() || locked){
+        //if(player.dead() || locked){
+        if(locked){
             cursorType = SystemCursor.arrow;
             if(!Core.scene.hasMouse()){
                 Core.graphics.cursor(cursorType);
@@ -477,7 +497,7 @@ public class DesktopInput extends InputHandler{
                 cursorType = SystemCursor.hand;
             }
 
-            if(canTapPlayer(Core.input.mouseWorld().x, Core.input.mouseWorld().y)){
+            if(canTapPlayer(Core.input.mouseWorld().x, Core.input.mouseWorld().y) && !settings.getBool("blockDrop", false)){
                 cursorType = ui.unloadCursor;
             }
 
@@ -633,6 +653,10 @@ public class DesktopInput extends InputHandler{
             }
         }
 
+        if(Core.input.keyTap(Binding.showRTSAi)){
+            settings.put("alwaysShowUnitRTSAi",!settings.getBool("alwaysShowUnitRTSAi"));
+        }
+
         if((cursorX != lastLineX || cursorY != lastLineY) && isPlacing() && mode == placing){
             updateLine(selectX, selectY);
             lastLineX = cursorX;
@@ -763,6 +787,20 @@ public class DesktopInput extends InputHandler{
                 Core.settings.put("lasersopacity", 0);
             }
         }
+
+        if (input.keyTap(Binding.superUnitEffect)) {
+            int level = settings.getInt("superUnitEffect");
+            settings.put("superUnitEffect", (level + 1) % 3);
+        }
+
+        if (input.keyDown(Binding.oreAdsorption) && player.unit().tileOn() != null) {
+            player.unit().tileOn().circle(Mathf.ceil(player.unit().type.mineRange / 8f), tile -> {
+                Tile ptile = player.unit().mineTile;
+                if ((ptile == null || player.dst(ptile) > player.dst(tile) || ptile.drop() == Items.sand) && canMine(tile) && tile.drop() != Items.sand) {
+                    player.unit().mineTile = tile;
+                }
+            });
+        }
     }
 
     @Override
@@ -833,7 +871,7 @@ public class DesktopInput extends InputHandler{
     }
 
     protected void updateMovement(Unit unit){
-        boolean omni = unit.type.omniMovement;
+        UnitType type = unit.type;
 
         float speed = unit.speed();
         float xa = Core.input.axis(Binding.move_x);
@@ -845,23 +883,69 @@ public class DesktopInput extends InputHandler{
             movement.add(input.mouseWorld().sub(player).scl(1f / 25f * speed)).limit(speed);
         }
 
-        float mouseAngle = Angles.mouseAngle(unit.x, unit.y);
-        boolean aimCursor = omni && player.shooting && unit.type.hasWeapons() && unit.type.faceTarget && !boosted;
+        boolean busy = unit.mining() || unit.activelyBuilding();
 
-        if(aimCursor){
-            unit.lookAt(mouseAngle);
-        }else{
+        if (Core.settings.getBool("playerNeedShooting")){
+            busy = false;
+        }
+
+        boolean manualShoot = Core.input.keyDown(Binding.select) && shouldShoot && !busy && (type.hasWeapons() || UnitTypes.block.equals(type)) && !boosted;
+
+        float mouseX = unit.aimX(), mouseY = unit.aimY();
+        Vec2 aimPos = Core.input.mouseWorld();
+
+        float lookAtAngle = Angles.mouseAngle(unit.x, unit.y);
+
+        if(target != null) {
+            boolean validHealTarget = type.canHeal && target instanceof Building b && b.isValid() && target.team() == unit.team && b.damaged() && target.within(unit, type.range);
+            if ((Units.invalidateTarget(target, unit, type.range) && !validHealTarget) || state.isEditor()) {
+                target = null;
+            }
+        }
+
+        if (!manualShoot && Core.settings.getBool("autotarget") && !busy) {
+            if (target == null) {
+                float range = unit.hasWeapons() ? unit.range() : 0f;
+                player.shooting = false;
+                if(!(player.unit() instanceof BlockUnitUnit u && u.tile() instanceof ControlBlock c && !c.shouldAutoTarget())){
+                    target = Units.closestTarget(unit.team, unit.x, unit.y, range, u -> u.checkTarget(type.targetAir, type.targetGround), u -> type.targetGround);
+
+                    if(type.canHeal && target == null){
+                        target = Geometry.findClosest(unit.x, unit.y, indexer.getDamaged(Team.sharded));
+                        if(target != null && !unit.within(target, range)){
+                            target = null;
+                        }
+                    }
+                }
+            }
+            else {
+                Vec2 intercept = Predict.intercept(unit, target, unit.hasWeapons() ? type.weapons.first().bullet.speed : 0f);
+
+                mouseX = intercept.x;
+                mouseY = intercept.y;
+                player.shooting = !boosted;
+
+                aimPos = intercept;
+                lookAtAngle = unit.angleTo(intercept);
+            }
+        }
+        else {
+            target = null;
+        }
+        if (type.omniMovement && type.faceTarget && unit.isShooting) {
+            unit.lookAt(lookAtAngle);
+        }
+        else {
             unit.lookAt(unit.prefRotation());
         }
 
         unit.movePref(movement);
-
-        unit.aim(Core.input.mouseWorld());
+        if (!autoAim) unit.aim(aimPos);
         unit.controlWeapons(true, player.shooting && !boosted);
 
-        player.boosting = Core.input.keyDown(Binding.boost);
-        player.mouseX = unit.aimX();
-        player.mouseY = unit.aimY();
+        player.boosting = Core.input.keyDown(Binding.boost) || Core.settings.getBool("forceBoost");
+        player.mouseX = mouseX;
+        player.mouseY = mouseY;
 
         //update payload input
         if(unit instanceof Payloadc){
diff --git a/core/src/mindustry/input/InputHandler.java b/core/src/mindustry/input/InputHandler.java
index e5e23114ce0d69f33bd42f32d337788250d1deca..c15ad871354a65887e0ac4e58699aea0eda2518a 100644
--- a/core/src/mindustry/input/InputHandler.java
+++ b/core/src/mindustry/input/InputHandler.java
@@ -17,6 +17,7 @@ import mindustry.*;
 import mindustry.ai.*;
 import mindustry.ai.types.*;
 import mindustry.annotations.Annotations.*;
+import mindustry.arcModule.*;
 import mindustry.content.*;
 import mindustry.core.*;
 import mindustry.entities.*;
@@ -35,6 +36,7 @@ import mindustry.world.*;
 import mindustry.world.blocks.ConstructBlock.*;
 import mindustry.world.blocks.*;
 import mindustry.world.blocks.distribution.*;
+import mindustry.world.blocks.logic.*;
 import mindustry.world.blocks.payloads.*;
 import mindustry.world.blocks.storage.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
@@ -54,6 +56,8 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     final static int maxLength = 100;
     final static Rect r1 = new Rect(), r2 = new Rect();
     final static Seq<Unit> tmpUnits = new Seq<>(false);
+    public static Player follow;
+    public static int followIndex = 0;
     final static Binding[] controlGroupBindings = {
     Binding.block_select_01,
     Binding.block_select_02,
@@ -103,6 +107,8 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     /** Groups of units saved to different hotkeys */
     public IntSeq[] controlGroups = new IntSeq[controlGroupBindings.length];
 
+    public Rect lastSelection = new Rect();
+    public boolean arcScanMode = false;
     private Seq<BuildPlan> plansOut = new Seq<>(BuildPlan.class);
     private QuadTree<BuildPlan> playerPlanTree = new QuadTree<>(new Rect());
 
@@ -262,7 +268,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
                 }
 
                 unit.lastCommanded = player.coloredName();
-                
+
                 //remove when other player command
                 if(!headless && player != Vars.player){
                     control.input.selectedUnits.remove(unit);
@@ -495,7 +501,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
         if(build == null) return;
 
         if(net.server() && (!Units.canInteract(player, build) ||
-            !netServer.admins.allowAction(player, ActionType.rotate, build.tile(), action -> action.rotation = Mathf.mod(build.rotation + Mathf.sign(direction), 4)))){
+        !netServer.admins.allowAction(player, ActionType.rotate, build.tile(), action -> action.rotation = Mathf.mod(build.rotation + Mathf.sign(direction), 4)))){
             throw new ValidateException(player, "Player cannot rotate a block.");
         }
 
@@ -512,7 +518,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     public static void tileConfig(@Nullable Player player, Building build, @Nullable Object value){
         if(build == null) return;
         if(net.server() && (!Units.canInteract(player, build) ||
-            !netServer.admins.allowAction(player, ActionType.configure, build.tile, action -> action.config = value))){
+        !netServer.admins.allowAction(player, ActionType.configure, build.tile, action -> action.config = value))){
 
             if(player.con != null){
                 var packet = new TileConfigCallPacket(); //undo the config on the client
@@ -522,7 +528,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
                 player.con.send(packet, true);
             }
 
-            throw new ValidateException(player, "Player cannot configure a tile.");
+            if(headless) throw new ValidateException(player, "Player cannot configure a tile.");
         }
         build.configured(player == null || player.dead() ? null : player.unit(), value);
         Events.fire(new ConfigEvent(build, player, value));
@@ -546,7 +552,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
             throw new ValidateException(player, "Player cannot control a building.");
         }
 
-        if(player.team() == build.team && build.canControlSelect(player.unit())){
+        if((player.team() == build.team || (build instanceof CoreBuild && state.rules.editor)) && build.canControlSelect(player.unit())){
             build.onControlSelect(player.unit());
         }
     }
@@ -735,6 +741,10 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
                 }
             }
         }
+
+        if(follow != null && !follow.dead()){
+            Core.camera.position.lerpDelta(follow, 0.08f);
+        }
     }
 
     public void checkUnit(){
@@ -884,6 +894,8 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
                     attack = selectedEnemyUnit(target.x, target.y);
                 }
 
+                if(input.keyDown(KeyCode.altLeft)) attack = null;
+
                 int[] ids = new int[selectedUnits.size];
                 for(int i = 0; i < ids.length; i++){
                     ids[i] = selectedUnits.get(i).id;
@@ -1007,10 +1019,10 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
                 Drawf.selected(blocker, Pal.remove);
                 Tmp.v1.set(cursorX, cursorY).scl(tilesize).add(block.offset, block.offset).sub(blocker).scl(-1f).nor();
                 Drawf.dashLineDst(Pal.remove,
-                cursorX * tilesize + block.offset + Tmp.v1.x * block.size * tilesize/2f,
-                cursorY * tilesize + block.offset + Tmp.v1.y * block.size * tilesize/2f,
-                blocker.x + Tmp.v1.x * -blocker.block.size * tilesize/2f,
-                blocker.y + Tmp.v1.y * -blocker.block.size * tilesize/2f
+                cursorX * tilesize + block.offset + Tmp.v1.x * block.size * tilesize / 2f,
+                cursorY * tilesize + block.offset + Tmp.v1.y * block.size * tilesize / 2f,
+                blocker.x + Tmp.v1.x * -blocker.block.size * tilesize / 2f,
+                blocker.y + Tmp.v1.y * -blocker.block.size * tilesize / 2f
                 );
             }
         }
@@ -1057,6 +1069,11 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
         });
     }
 
+    protected void showSchematicPreview(){
+        if(lastSchematic == null) return;
+        ui.schematics.showInfo(lastSchematic);
+    }
+
     public void rotatePlans(Seq<BuildPlan> plans, int direction){
         int ox = schemOriginX(), oy = schemOriginY();
 
@@ -1090,6 +1107,19 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
             plan.x = World.toTile(wx - plan.block.offset) + ox;
             plan.y = World.toTile(wy - plan.block.offset) + oy;
             plan.rotation = plan.block.planRotation(Mathf.mod(plan.rotation + direction, 4));
+
+            if(Core.settings.getBool("rotateCanvas") && plan.block instanceof CanvasBlock cb){
+                CanvasBlock.CanvasBuild temp = cb.new CanvasBuild();
+                Pixmap pix = cb.makePixmap((byte[])plan.config), pix2 = new Pixmap(cb.canvasSize, cb.canvasSize);
+                pix.each((px, py) -> pix2.setRaw(
+                direction >= 0 ? py : cb.canvasSize - py - 1,
+                direction >= 0 ? cb.canvasSize - px - 1 : px,
+                pix.getRaw(px, py)));
+                plan.config = temp.packPixmap(pix2);
+                temp.remove();
+                pix.dispose();
+                pix2.dispose();
+            }
         });
     }
 
@@ -1108,7 +1138,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
             }
 
             plan.pointConfig(p -> {
-                int corigin = x ? plan.originalWidth/2 : plan.originalHeight/2;
+                int corigin = x ? plan.originalWidth / 2 : plan.originalHeight / 2;
                 int nvalue = -(x ? p.x : p.y);
                 if(x){
                     plan.originalX = -(plan.originalX - corigin) + corigin;
@@ -1121,6 +1151,14 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
 
             //flip rotation
             plan.block.flipRotation(plan, x);
+
+            if(Core.settings.getBool("rotateCanvas") && plan.block instanceof CanvasBlock cb){
+                CanvasBlock.CanvasBuild temp = cb.new CanvasBuild();
+                Pixmap pix = cb.makePixmap((byte[])plan.config);
+                plan.config = temp.packPixmap(x ? pix.flipX() : pix.flipY());
+                temp.remove();
+                pix.dispose();
+            }
         });
     }
 
@@ -1241,12 +1279,19 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     protected void drawSelection(int x1, int y1, int x2, int y2, int maxLength, Color col1, Color col2){
         NormalizeDrawResult result = Placement.normalizeDrawArea(Blocks.air, x1, y1, x2, y2, false, maxLength, 1f);
 
+        String arcSelectionSize = "";
+        arcSelectionSize = Math.abs(x2 - x1) + 1 + "×" + (Math.abs(y1 - y2) + 1);
+
+        DrawUtilities.drawText(arcSelectionSize, 1f / 3f / Scl.scl(), (x1 + x2) / 2, Math.max(y1, y2) + 1, Pal.accent, Align.top);
         Lines.stroke(2f);
 
         Draw.color(col1);
         Lines.rect(result.x, result.y - 1, result.x2 - result.x, result.y2 - result.y);
         Draw.color(col2);
         Lines.rect(result.x, result.y, result.x2 - result.x, result.y2 - result.y);
+
+        lastSelection.set(x1, y1, x2 - x1, y2 - y1);
+        lastSelection.normalize();
     }
 
     protected void flushSelectPlans(Seq<BuildPlan> plans){
@@ -1429,7 +1474,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
         if(build.block.commandable && commandMode){
             //TODO handled in tap.
             consumed = true;
-        }else if(build.block.configurable && build.interactable(player.team())){ //check if tapped block is configurable
+        }else if(build.block.configurable && ARCVars.arcInfoControl(build.team)){ //check if tapped block is configurable
             consumed = true;
             if((!config.isShown() && build.shouldShowConfigure(player)) //if the config fragment is hidden, show
             //alternatively, the current selected block can 'agree' to switch config tiles
@@ -1458,7 +1503,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
         //consume tap event if necessary
         if(build.interactable(player.team()) && build.block.consumesTap){
             consumed = true;
-        }else if(build.interactable(player.team()) && build.block.synthetic() && (!consumed || build.block.allowConfigInventory)){
+        }else if(build.interactable(player.team()) && build.block.synthetic() && (!consumed || build.block.allowConfigInventory || settings.getBool("forceConfigInventory"))){
             if(build.block.hasItems && build.items.total() > 0){
                 inv.showFor(build);
                 consumed = true;
@@ -1475,7 +1520,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
 
     /** Tries to select the player to drop off items, returns true if successful. */
     boolean tryTapPlayer(float x, float y){
-        if(canTapPlayer(x, y)){
+        if(canTapPlayer(x, y) && !settings.getBool("blockDrop", false)){
             droppingItem = true;
             return true;
         }
@@ -1514,9 +1559,9 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
 
     boolean canMine(Tile tile){
         return !Core.scene.hasMouse()
-            && player.unit().validMine(tile)
-            && player.unit().acceptsItem(player.unit().getMineResult(tile))
-            && !((!Core.settings.getBool("doubletapmine") && tile.floor().playerUnmineable) && tile.overlay().itemDrop == null);
+        && player.unit().validMine(tile)
+        && player.unit().acceptsItem(player.unit().getMineResult(tile))
+        && !((!Core.settings.getBool("doubletapmine") && tile.floor().playerUnmineable) && tile.overlay().itemDrop == null);
     }
 
     /** Returns the tile at the specified MOUSE coordinates. */
@@ -1596,7 +1641,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
 
     public @Nullable Building selectedControlBuild(){
         Building build = world.buildWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
-        if(build != null && !player.dead() && build.canControlSelect(player.unit()) && build.team == player.team()){
+        if(build != null && !player.dead() && build.canControlSelect(player.unit()) && (build.team == player.team() || (build instanceof CoreBuild && state.rules.editor))){
             return build;
         }
         return null;
@@ -1606,8 +1651,8 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
         var tree = player.team().data().tree();
         tmpUnits.clear();
         float rad = 4f;
-        tree.intersect(x - rad/2f, y - rad/2f, rad, rad, tmpUnits);
-        return tmpUnits.min(u -> u.isCommandable(), u -> u.dst(x, y) - u.hitSize/2f);
+        tree.intersect(x - rad / 2f, y - rad / 2f, rad, rad, tmpUnits);
+        return tmpUnits.min(u -> u.isCommandable(), u -> u.dst(x, y) - u.hitSize / 2f);
     }
 
     public @Nullable Unit selectedEnemyUnit(float x, float y){
@@ -1621,14 +1666,14 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
             }
         }
 
-        return tmpUnits.min(u -> !u.inFogTo(player.team()), u -> u.dst(x, y) - u.hitSize/2f);
+        return tmpUnits.min(u -> !u.inFogTo(player.team()), u -> u.dst(x, y) - u.hitSize / 2f);
     }
 
     public Seq<Unit> selectedCommandUnits(float x, float y, float w, float h, Boolf<Unit> predicate){
         var tree = player.team().data().tree();
         tmpUnits.clear();
         float rad = 4f;
-        tree.intersect(Tmp.r1.set(x - rad/2f, y - rad/2f, rad*2f + w, rad*2f + h).normalize(), tmpUnits);
+        tree.intersect(Tmp.r1.set(x - rad / 2f, y - rad / 2f, rad * 2f + w, rad * 2f + h).normalize(), tmpUnits);
         tmpUnits.removeAll(u -> !u.isCommandable() || !predicate.get(u));
         return tmpUnits;
     }
@@ -1682,8 +1727,11 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     }
 
     public boolean canShoot(){
+        if(Core.settings.getBool("playerNeedShooting")){
+            return block == null && !onConfigurable() && !isDroppingItem() && !commandMode;
+        }
         return block == null && !onConfigurable() && !isDroppingItem() && !player.unit().activelyBuilding() &&
-            !(player.unit() instanceof Mechc && player.unit().isFlying()) && !player.unit().mining() && !commandMode;
+        !(player.unit() instanceof Mechc && player.unit().isFlying()) && !player.unit().mining() && !commandMode;
     }
 
     public boolean onConfigurable(){
@@ -1699,7 +1747,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     }
 
     public void tryDropItems(@Nullable Building build, float x, float y){
-        if(!droppingItem || player.unit().stack.amount <= 0 || canTapPlayer(x, y) || state.isPaused() ){
+        if(!droppingItem || player.unit().stack.amount <= 0 || canTapPlayer(x, y) || state.isPaused() || settings.getBool("blockDrop", false)){
             droppingItem = false;
             return;
         }
@@ -1709,7 +1757,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
         ItemStack stack = player.unit().stack;
 
         if(build != null && build.acceptStack(stack.item, stack.amount, player.unit()) > 0 && build.interactable(player.team()) &&
-                build.block.hasItems && player.unit().stack().amount > 0 && build.interactable(player.team())){
+        build.block.hasItems && player.unit().stack().amount > 0 && build.interactable(player.team())){
             if(!(state.rules.onlyDepositCore && !(build instanceof CoreBuild))){
                 Call.transferInventory(player, build);
             }
@@ -1779,8 +1827,8 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     public void drawArrow(Block block, int x, int y, int rotation, boolean valid){
         float trns = (block.size / 2) * tilesize;
         int dx = Geometry.d4(rotation).x, dy = Geometry.d4(rotation).y;
-        float offsetx = x * tilesize + block.offset + dx*trns;
-        float offsety = y * tilesize + block.offset + dy*trns;
+        float offsetx = x * tilesize + block.offset + dx * trns;
+        float offsety = y * tilesize + block.offset + dy * trns;
 
         Draw.color(!valid ? Pal.removeBack : Pal.accentBack);
         TextureRegion regionArrow = Core.atlas.find("place-arrow");
@@ -1818,7 +1866,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
         var end = world.build(endX, endY);
         if(diagonal && (block == null || block.allowDiagonal)){
             if(block != null && start instanceof ChainedBuilding && end instanceof ChainedBuilding
-                    && block.canReplace(end.block) && block.canReplace(start.block)){
+            && block.canReplace(end.block) && block.canReplace(start.block)){
                 points = Placement.upgradeLine(startX, startY, endX, endY);
             }else{
                 points = Placement.pathfindLine(block != null && block.conveyorPlacement, startX, startY, endX, endY);
diff --git a/core/src/mindustry/input/MobileInput.java b/core/src/mindustry/input/MobileInput.java
index dfac50b02c171c61b02f4e7da4d20ce7e5e00c1a..9d1cc972026994e22f65e5dc770786ebcaf16ed9 100644
--- a/core/src/mindustry/input/MobileInput.java
+++ b/core/src/mindustry/input/MobileInput.java
@@ -323,7 +323,7 @@ public class MobileInput extends InputHandler implements GestureListener{
                     //why the heck doesn't setOrigin work for scaling
                     img.setTranslation(img.getWidth(), 0f);
                 });
-
+                b.button(Icon.info, style, this::showSchematicPreview).disabled(f -> lastSchematic == null || lastSchematic.file != null);
             }).margin(4f);
         });
     }
@@ -1008,18 +1008,23 @@ public class MobileInput extends InputHandler implements GestureListener{
             payloadTarget = null;
         }
 
-        movement.set(targetPos).sub(player).limit(speed);
-        movement.setAngle(Mathf.slerp(movement.angle(), unit.vel.angle(), 0.05f));
+        if (!Core.settings.getBool("viewMode")) {
+            movement.set(targetPos).sub(player).limit(speed);
+            movement.setAngle(Mathf.slerp(movement.angle(), unit.vel.angle(), 0.05f));
 
-        if(player.within(targetPos, attractDst)){
+            if(player.within(targetPos, attractDst)){
+                movement.setZero();
+                unit.vel.approachDelta(Vec2.ZERO, unit.speed() * type.accel / 2f);
+            }
+        }
+        else {
             movement.setZero();
-            unit.vel.approachDelta(Vec2.ZERO, unit.speed() * type.accel / 2f);
         }
 
         unit.hitbox(rect);
         rect.grow(4f);
 
-        player.boosting = collisions.overlapsTile(rect, EntityCollisions::solid) || !unit.within(targetPos, 85f);
+        player.boosting = collisions.overlapsTile(rect, EntityCollisions::solid) || !unit.within(targetPos, 85f) || Core.settings.getBool("forceBoost");
 
         unit.movePref(movement);
 
diff --git a/core/src/mindustry/input/Placement.java b/core/src/mindustry/input/Placement.java
index 351cf7320eeaee44de486458dd9b3e8e534b1ce8..09935e4e5ccbfa0d67c102b2e62de5c385f37b79 100644
--- a/core/src/mindustry/input/Placement.java
+++ b/core/src/mindustry/input/Placement.java
@@ -113,18 +113,22 @@ public class Placement{
     }
 
     public static void calculateBridges(Seq<BuildPlan> plans, ItemBridge bridge){
-        if(isSidePlace(plans)) return;
+        calculateBridges(plans, bridge, t -> false);
+    }
+
+    public static void calculateBridges(Seq<BuildPlan> plans, ItemBridge bridge, Boolf<Block> avoid){
+        if(isSidePlace(plans) || plans.size == 0) return;
 
         //check for orthogonal placement + unlocked state
         if(!(plans.first().x == plans.peek().x || plans.first().y == plans.peek().y) || !bridge.unlockedNow()){
             return;
         }
 
-        Boolf<BuildPlan> placeable = plan -> (plan.placeable(player.team())) ||
-            (plan.tile() != null && plan.tile().block() == plan.block); //don't count the same block as inaccessible
+        Boolf<BuildPlan> placeable = plan ->
+            (plan.placeable(player.team()) || (plan.tile() != null && plan.tile().block() == plan.block)) &&  //don't count the same block as inaccessible
+           !(plan.build() != null && plan.build().rotation != plan.rotation && avoid.get(plan.tile().block()));
 
         var result = plans1.clear();
-        var team = player.team();
         var rotated = plans.first().tile() != null && plans.first().tile().absoluteRelativeTo(plans.peek().x, plans.peek().y) == Mathf.mod(plans.first().rotation + 2, 4);
 
         outer:
@@ -134,6 +138,7 @@ public class Placement{
 
             //gap found
             if(i < plans.size - 1 && placeable.get(cur) && !placeable.get(plans.get(i + 1))){
+                boolean wereSame = true;
 
                 //find the closest valid position within range
                 for(int j = i + 1; j < plans.size; j++){
@@ -147,18 +152,29 @@ public class Placement{
                         }
                         i = j;
                         continue outer;
-                    }else if(other.placeable(team)){
-                        //found a link, assign bridges
-                        cur.block = bridge;
-                        other.block = bridge;
-                        if(rotated){
-                            other.config = new Point2(cur.x - other.x,  cur.y - other.y);
+                    }else if(placeable.get(other)){
+
+                        if(wereSame){
+                            //the gap is fake, it's just conveyors that can be replaced with junctions
+                            i ++;
+                            continue outer;
                         }else{
-                            cur.config = new Point2(other.x - cur.x, other.y - cur.y);
+                            //found a link, assign bridges
+                            cur.block = bridge;
+                            other.block = bridge;
+                            if(rotated){
+                                other.config = new Point2(cur.x - other.x,  cur.y - other.y);
+                            }else{
+                                cur.config = new Point2(other.x - cur.x, other.y - cur.y);
+                            }
+
+                            i = j;
+                            continue outer;
                         }
+                    }
 
-                        i = j;
-                        continue outer;
+                    if(other.tile() != null && !avoid.get(other.tile().block())){
+                        wereSame = false;
                     }
                 }
 
@@ -175,21 +191,17 @@ public class Placement{
         plans.set(result);
     }
 
-    public static void calculateBridges(Seq<BuildPlan> plans, DirectionBridge bridge, boolean hasJunction, Boolf<Block> same){
-        if(isSidePlace(plans)) return;
+    public static void calculateBridges(Seq<BuildPlan> plans, DirectionBridge bridge, boolean hasJunction, Boolf<Block> avoid){
+        if(isSidePlace(plans) || plans.size == 0) return;
 
         //check for orthogonal placement + unlocked state
         if(!(plans.first().x == plans.peek().x || plans.first().y == plans.peek().y) || !bridge.unlockedNow()){
             return;
         }
 
-        Boolf<BuildPlan> rotated = plan -> plan.build() != null && same.get(plan.build().block) && plan.rotation != plan.build().rotation;
-
-        //TODO for chains of ducts, do not count consecutives in a different rotation as 'placeable'
         Boolf<BuildPlan> placeable = plan ->
-            !(!hasJunction && rotated.get(plan)) &&
-            (plan.placeable(player.team()) ||
-            (plan.tile() != null && same.get(plan.tile().block()))); //don't count the same block as inaccessible
+            (plan.placeable(player.team()) || (plan.tile() != null && plan.tile().block() == plan.block)) &&  //don't count the same block as inaccessible
+            !(plan.build() != null && plan.build().rotation != plan.rotation && avoid.get(plan.tile().block()));
 
         var result = plans1.clear();
 
@@ -199,10 +211,11 @@ public class Placement{
             result.add(cur);
 
             //gap found
-            if(i < plans.size - 1 && placeable.get(cur) && (!placeable.get(plans.get(i + 1)) || (hasJunction && rotated.get(plans.get(i + 1)) && i < plans.size - 2 && !placeable.get(plans.get(i + 2))))){
+            if(i < plans.size - 1 && placeable.get(cur) && !placeable.get(plans.get(i + 1))){
+                boolean wereSame = true;
 
                 //find the closest valid position within range
-                for(int j = i + 2; j < plans.size; j++){
+                for(int j = i + 1; j < plans.size; j++){
                     var other = plans.get(j);
 
                     //out of range now, set to current position and keep scanning forward for next occurrence
@@ -214,12 +227,22 @@ public class Placement{
                         i = j;
                         continue outer;
                     }else if(placeable.get(other)){
-                        //found a link, assign bridges
-                        cur.block = bridge;
-                        other.block = bridge;
 
-                        i = j;
-                        continue outer;
+                        if(wereSame && hasJunction){
+                            //the gap is fake, it's just conveyors that can be replaced with junctions
+                            i ++;
+                            continue outer;
+                        }else{
+                            //found a link, assign bridges
+                            cur.block = bridge;
+                            other.block = bridge;
+                            i = j;
+                            continue outer;
+                        }
+                    }
+
+                    if(other.tile() != null && !avoid.get(other.tile().block())){
+                        wereSame = false;
                     }
                 }
 
diff --git a/core/src/mindustry/logic/LCanvas.java b/core/src/mindustry/logic/LCanvas.java
index d8c28c046483618a8bfb5f6a457b54e555f69141..eba8ea3d68f2aeb729169f21fcbe6657ad9720ae 100644
--- a/core/src/mindustry/logic/LCanvas.java
+++ b/core/src/mindustry/logic/LCanvas.java
@@ -18,6 +18,9 @@ import mindustry.gen.*;
 import mindustry.graphics.*;
 import mindustry.logic.LStatements.*;
 import mindustry.ui.*;
+import mindustry.ui.dialogs.BaseDialog;
+
+import static mindustry.arcModule.ARCVars.arcui;
 
 public class LCanvas extends Table{
     public static final int maxJumpsDrawn = 100;
@@ -58,7 +61,7 @@ public class LCanvas extends Table{
 
     /** @return if statement elements should have rows. */
     public static boolean useRows(){
-        return Core.graphics.getWidth() < Scl.scl(900f) * 1.2f;
+        return Core.graphics.getWidth() - (Core.settings.getBool("logicSupport") ? 400f : 0f) < Scl.scl(900f) * 1.2f;
     }
 
     public static void tooltip(Cell<?> cell, String key){
@@ -164,6 +167,13 @@ public class LCanvas extends Table{
         this.statements.layout();
     }
 
+    public void clearAll(){
+        if(statements==null) return;
+        jumps.clear();
+        statements.clear();
+        rebuild();
+    }
+
     StatementElem checkHovered(){
         Element e = Core.scene.hit(Core.input.mouseX(), Core.input.mouseY(), true);
         if(e != null){
@@ -345,14 +355,19 @@ public class LCanvas extends Table{
 
                 addressLabel = t.add(index + "").style(Styles.outlineLabel).color(color).padRight(8).get();
 
+                t.button(Icon.add, Styles.logici, () -> {
+                }).size(24f).padRight(6).get().tapped(this::arcAppend);
+
                 t.button(Icon.copy, Styles.logici, () -> {
                 }).size(24f).padRight(6).get().tapped(this::copy);
 
+                t.button(st instanceof PrintStatement ? Icon.fileText : Icon.pencil, Styles.logici, () -> arcTrans()).size(24f).padRight(6).get().tapped(()->{});
+
                 t.button(Icon.cancel, Styles.logici, () -> {
                     remove();
                     dragging = null;
                     statements.layout();
-                }).size(24f);
+                }).size(24f).padLeft(Vars.mobile?48:0);
 
                 t.addListener(new InputListener(){
                     float lastx, lasty;
@@ -430,6 +445,80 @@ public class LCanvas extends Table{
             }
         }
 
+        public void arcAppend(){
+            BaseDialog dialog = new BaseDialog("@add");
+            dialog.cont.table(table -> {
+                table.background(Tex.button);
+                table.pane(t -> {
+                    for(Prov<LStatement> prov : LogicIO.allStatements){
+                        LStatement example = prov.get();
+                        if(example instanceof InvalidStatement || example.hidden() || (example.privileged() && !privileged) || (example.nonPrivileged() && privileged)) continue;
+
+                        LCategory category = example.category();
+                        Table cat = t.find(category.name);
+                        if(cat == null){
+                            t.table(s -> {
+                                if(category.icon != null){
+                                    s.image(category.icon, Pal.darkishGray).left().size(15f).padRight(10f);
+                                }
+                                s.add(category.localized()).color(Pal.darkishGray).left().tooltip(category.description());
+                                s.image(Tex.whiteui, Pal.darkishGray).left().height(5f).growX().padLeft(10f);
+                            }).growX().pad(5f).padTop(10f);
+
+                            t.row();
+
+                            cat = t.table(c -> {
+                                c.top().left();
+                            }).name(category.name).top().left().growX().fillY().get();
+                            t.row();
+                        }
+
+                        TextButton.TextButtonStyle style = new TextButton.TextButtonStyle(Styles.flatt);
+                        style.fontColor = category.color;
+                        style.font = Fonts.outline;
+
+                        cat.button(example.name(), style, () -> {
+                            statements.addChildAt(statements.getChildren().indexOf(this) + 1,new StatementElem(prov.get()));
+                            statements.layout();
+                            dialog.hide();
+                        }).size(130f, 50f).self(c -> tooltip(c, "lst." + example.name())).top().left();
+
+                        if(cat.getChildren().size % 3 == 0) cat.row();
+                    }
+                }).grow();
+            }).fill().maxHeight(Core.graphics.getHeight() * 0.8f);
+            dialog.addCloseButton();
+            dialog.show();
+        }
+
+        public void arcTrans(){ //LC：md这玩意真难搞，这一小段代码研究了一整天才找到如何解决。
+            LStatement stNew;
+            int child = statements.getChildren().indexOf(this) + 1;
+            if(st instanceof PrintStatement pst){ //print->代码
+                Seq<LStatement> lsStatement = LAssembler.read(pst.value.replace("_"," "),privileged);
+                stNew = lsStatement.first();
+                if (stNew instanceof InvalidStatement) arcui.arcInfo("[orange]警告：转换失败，请输入正确格式\n[cyan]" + LogicDialog.transText);
+                else if(stNew instanceof JumpStatement jst && jst.destIndex != -1){
+                    jst.dest = (StatementElem) statements.getChildren().get(jst.destIndex);
+                }
+            }else if (st instanceof InvalidStatement){
+                stNew = LogicIO.read(new String[]{"print",LogicDialog.transText},2);
+            }else{  //代码->print
+                StringBuilder thisText = new StringBuilder();
+                LogicIO.write(st,thisText);
+                LogicDialog.transText = thisText.toString();
+                stNew = LogicIO.read(new String[]{"print",LogicDialog.transText},2);
+            }
+            StatementElem stNewElem = new StatementElem(stNew);
+            statements.addChildAt(child, stNewElem);
+            remove();
+            for(Element ste :  statements.seq){
+                if(((StatementElem)ste).st instanceof JumpStatement jst && jst.dest == st.elem) jst.dest = stNewElem;
+            }
+            statements.layout();
+        }
+
+
         @Override
         public void draw(){
             float pad = 5f;
@@ -578,7 +667,7 @@ public class LCanvas extends Table{
             float dist = 100f;
 
             //square jumps
-            if(false){
+            if(Core.settings.getBool("rectJumpLine")){
                 float len = Scl.scl(Mathf.randomSeed(hashCode(), 10, 50));
 
                 float maxX = Math.max(x, x2) + len;
diff --git a/core/src/mindustry/logic/LExecutor.java b/core/src/mindustry/logic/LExecutor.java
index 697517800ce584175b9d4bbc4f1e229a776fc9c8..b673320b61515edfe46775524abf4f6f9a836bb2 100644
--- a/core/src/mindustry/logic/LExecutor.java
+++ b/core/src/mindustry/logic/LExecutor.java
@@ -9,6 +9,7 @@ import arc.util.*;
 import mindustry.*;
 import mindustry.ai.types.*;
 import mindustry.annotations.Annotations.*;
+import mindustry.arcModule.ui.dialogs.MessageDialog;
 import mindustry.content.*;
 import mindustry.core.*;
 import mindustry.ctype.*;
@@ -609,6 +610,7 @@ public class LExecutor{
         public void run(LExecutor exec){
             Object obj = exec.obj(target);
             if(obj instanceof Building b && (exec.privileged || (b.team == exec.team && exec.linkIds.contains(b.id)))){
+                b.lastLogicController = exec.build;
 
                 if(type == LAccess.enabled && !exec.bool(p1)){
                     b.lastDisabler = exec.build;
@@ -1206,7 +1208,7 @@ public class LExecutor{
         @Override
         public void run(LExecutor exec){
             if(headless) return;
-
+            if(Core.settings.getBool("removeLogicLock"))return;
             switch(action){
                 case pan -> {
                     control.input.logicCutscene = true;
@@ -1584,8 +1586,14 @@ public class LExecutor{
             }
 
             switch(type){
-                case notify -> ui.hudfrag.showToast(Icon.info, text);
-                case announce -> ui.announce(text, exec.numf(duration));
+                case notify -> {
+                    ui.hudfrag.showToast(Icon.info, text);
+                    MessageDialog.addMsg(new MessageDialog.advanceMsg(MessageDialog.arcMsgType.logicNotify,text).sendMessage());
+                }
+                case announce -> {
+                    ui.announce(text, exec.numf(duration));
+                    MessageDialog.addMsg(new MessageDialog.advanceMsg(MessageDialog.arcMsgType.logicAnnounce,text).sendMessage());
+                }
                 case toast -> ui.showInfoToast(text, exec.numf(duration));
                 //TODO desync?
                 case mission -> state.rules.mission = text;
diff --git a/core/src/mindustry/logic/LogicDialog.java b/core/src/mindustry/logic/LogicDialog.java
index ac2fd249a8a3a7032c358ec3c7a9ea4366012e86..e70837545f8c4f40ae07c100dae94d192d0af352 100644
--- a/core/src/mindustry/logic/LogicDialog.java
+++ b/core/src/mindustry/logic/LogicDialog.java
@@ -4,6 +4,7 @@ import arc.*;
 import arc.func.*;
 import arc.graphics.*;
 import arc.scene.actions.*;
+import arc.scene.event.*;
 import arc.scene.ui.*;
 import arc.scene.ui.TextButton.*;
 import arc.scene.ui.layout.*;
@@ -19,14 +20,25 @@ import mindustry.ui.*;
 import mindustry.ui.dialogs.*;
 
 import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
 import static mindustry.logic.LCanvas.*;
 
 public class LogicDialog extends BaseDialog{
     public LCanvas canvas;
     Cons<String> consumer = s -> {};
     boolean privileged;
+    public static float period = 15f;
+    float counter = 0f;
+    Table varTable = new Table();
+    Table mainTable = new Table();
+    public static boolean refreshing = true;
+
+    public static String transText = "";
+
     @Nullable LExecutor executor;
 
+    private boolean dispose = false;
+
     public LogicDialog(){
         super("logic");
 
@@ -38,20 +50,164 @@ public class LogicDialog extends BaseDialog{
         addCloseListener();
 
         shown(this::setup);
-        hidden(() -> consumer.get(canvas.save()));
+        hidden(() -> {
+            if(!dispose){
+                consumer.get(canvas.save());
+            } else {
+                dispose = false;
+            }});
         onResize(() -> {
             setup();
             canvas.rebuild();
+            varsTable();
         });
 
-        add(canvas).grow().name("canvas");
+
+        add(mainTable).grow().name("canvas");
+        rebuildMain();
 
         row();
 
         add(buttons).growX().name("canvas");
     }
 
-    private Color typeColor(Var s, Color color){
+    private void rebuildMain(){
+        mainTable.clear();
+        canvas.rebuild();
+        if(!Core.settings.getBool("logicSupport"))  {
+            mainTable.add(canvas).grow();
+        }else{
+            varsTable();
+            mainTable.add(varTable);
+            mainTable.add(canvas).grow();
+            counter=0;
+            varTable.update(()->{
+                counter+=Time.delta;
+                if(counter>period && refreshing){
+                    counter=0;
+                }
+            });
+        }
+    }
+    private void varsTable(){
+        varTable.clear();
+        varTable.table(t->{
+            t.table(tt->{
+                tt.add("刷新间隔").padRight(5f).left();
+                TextField field = tt.field((int)period + "", text -> {
+                    period = Integer.parseInt(text);
+                }).width(100f).valid(Strings::canParsePositiveInt).maxTextLength(5).get();
+                tt.slider(1, 60,1, period, res -> {
+                    period = res;
+                    field.setText((int)res + "");
+                });
+            });
+            t.row();
+            t.table(tt -> {
+                tt.button(Icon.cancelSmall, Styles.cleari, () -> {
+                    Core.settings.put("logicSupport", !Core.settings.getBool("logicSupport"));
+                    arcui.arcInfo("[orange]已关闭逻辑辅助器！");
+                    rebuildMain();
+                }).size(50f);
+                tt.button(Icon.refreshSmall, Styles.cleari, () -> {
+                    executor.build.updateCode(executor.build.code);
+                    varsTable();
+                    arcui.arcInfo("[orange]已更新逻辑显示！");
+                }).size(50f);
+                tt.button(Icon.pauseSmall, Styles.cleari, () -> {
+                    refreshing = !refreshing;
+                    arcui.arcInfo("[orange]已" + (refreshing ? "开启" : "关闭") + "逻辑刷新");
+                }).checked(refreshing).size(50f);
+                tt.button(Icon.rightOpenOutSmall, Styles.cleari, () -> {
+                    Core.settings.put("rectJumpLine", !Core.settings.getBool("rectJumpLine"));
+                    arcui.arcInfo("[orange]已" + (refreshing ? "开启" : "关闭") + "方形跳转线");
+                    this.canvas.rebuild();
+                }).checked(refreshing).size(50f);
+
+                tt.button(Icon.playSmall, Styles.cleari, () -> {
+                    if (state.isPaused()) state.set(State.playing);
+                    else state.set(State.paused);
+                    arcui.arcInfo(state.isPaused() ? "已暂停" : "已继续游戏");
+                }).checked(state.isPaused()).size(50f);
+            });
+        });
+        varTable.row();
+            varTable.pane(t->{
+                if(executor==null) return;
+                for(var s : executor.vars){
+                    if(s.name.startsWith("___")) continue;
+                    String text = arcVarsText(s);
+                    t.table(tt->{
+                        tt.background(Tex.whitePane);
+
+                        tt.table(tv->{
+                            tv.labelWrap(s.name).width(100f);
+                            tv.touchable = Touchable.enabled;
+                            tv.tapped(()->{
+                                Core.app.setClipboardText(s.name);
+                                arcui.arcInfo("[cyan]复制变量名[white]\n " + s.name);
+                            });
+                        });
+                        tt.table(tv->{
+                            Label varPro = tv.labelWrap(text).width(200f).get();
+                            tv.touchable = Touchable.enabled;
+                            tv.tapped(()->{
+                                Core.app.setClipboardText(varPro.getText().toString());
+                                arcui.arcInfo("[cyan]复制变量属性[white]\n " + varPro.getText());
+                            });
+                            tv.update(()->{
+                                if(counter + Time.delta>period && refreshing){
+                                    varPro.setText(arcVarsText(s));
+                                }
+                            });
+                        }).padLeft(20f);
+
+                        tt.update(()->{
+                            if(counter + Time.delta>period && refreshing){
+                                tt.setColor(arcVarsColor(s));
+                            }
+                        });
+
+                    }).padTop(10f).row();
+                }
+                t.table(tt->{
+                    tt.background(Tex.whitePane);
+
+                    tt.table(tv->{
+                        Label varPro = tv.labelWrap(executor.textBuffer.toString()).width(300f).get();
+                        tv.touchable = Touchable.enabled;
+                        tv.tapped(()->{
+                            Core.app.setClipboardText(varPro.getText().toString());
+                            arcui.arcInfo("[cyan]复制信息版[white]\n " + varPro.getText());
+                        });
+                        tv.update(()->{
+                            if(counter + Time.delta>period && refreshing){
+                                varPro.setText(executor.textBuffer.toString());
+                            }
+                        });
+                    }).padLeft(20f);
+
+                    tt.update(()->{
+                        if(counter + Time.delta>period && refreshing){
+                            tt.setColor(Color.valueOf("#e600e6"));
+                        }
+                    });
+
+                }).padTop(10f).row();
+            }).width(400f).padLeft(20f);
+    }
+
+    public static String arcVarsText(Var s){
+        return s.isobj ? PrintI.toString(s.objval) : Math.abs(s.numval - (long)s.numval) < 0.00001 ? (long)s.numval + "" : s.numval + "";
+    }
+
+    public static Color arcVarsColor(Var s){
+        if(s.constant && s.name.startsWith("@")) return Color.goldenrod;
+        else if (s.constant) return Color.valueOf("00cc7e");
+        else return typeColor(s,new Color());
+    }
+
+    private static Color typeColor(Var s, Color color){
         return color.set(
             !s.isobj ? Pal.place :
             s.objval == null ? Color.darkGray :
@@ -104,6 +260,19 @@ public class LogicDialog extends BaseDialog{
                             ui.showException(e);
                         }
                     }).marginLeft(12f).disabled(b -> Core.app.getClipboardText() == null);
+                    t.row();
+                    t.button("[orange]清空",Icon.trash,style,() -> canvas.clearAll()).marginLeft(12f);
+                    t.row();
+                    t.button("[orange]丢弃更改", Icon.cancel,style, () -> ui.showConfirm("确认丢弃?", () -> {
+                        dispose = true;
+                        dialog.hide();
+                        hide();
+                    })).marginLeft(12f);
+                    t.row();
+                    t.button("[orange]逻辑辅助器",Icon.settings,style,()-> {
+                        Core.settings.put("logicSupport",!Core.settings.getBool("logicSupport"));
+                        rebuildMain();
+                    }).marginLeft(12f);
                 });
             });
 
@@ -144,7 +313,6 @@ public class LogicDialog extends BaseDialog{
 
                         t.add(new Image(Tex.whiteui, Pal.gray.cpy().mul(mul))).width(stub);
                         t.table(Tex.pane, out -> {
-                            float period = 15f;
                             float[] counter = {-1f};
                             Label label = out.add("").style(Styles.outlineLabel).padLeft(4).padRight(4).width(140f).wrap().get();
                             label.update(() -> {
@@ -244,7 +412,7 @@ public class LogicDialog extends BaseDialog{
                 modified.get(result);
             }
         };
-
+        varsTable();
         show();
     }
 }
diff --git a/core/src/mindustry/maps/MapPreviewLoader.java b/core/src/mindustry/maps/MapPreviewLoader.java
index af13236bdb18e911f8c833a738e156271cea4892..9e419efc1c67fc2b20c103c0c9f3bf4b99ba7bb5 100644
--- a/core/src/mindustry/maps/MapPreviewLoader.java
+++ b/core/src/mindustry/maps/MapPreviewLoader.java
@@ -15,6 +15,8 @@ import mindustry.game.EventType.*;
 
 import java.lang.reflect.*;
 
+import static mindustry.Vars.*;
+
 public class MapPreviewLoader extends TextureLoader{
 
     public MapPreviewLoader(){
@@ -79,7 +81,7 @@ public class MapPreviewLoader extends TextureLoader{
                 previewLoaded[2] = false;
             });
             Events.run(Trigger.update, check = () -> {
-                if(previewLoaded[0]) Reflect.set(sup.get(), header, true);
+                if(previewLoaded[0]) Reflect.set(sup.get(), header, (state.rules.pvp && player.team().id != 255) || renderer.fogEnabled);
                 if(previewLoaded[1]) Reflect.set(sup.get(), worldLoader, false);
                 if(previewLoaded[2]) Reflect.set(sup.get(), worldUnloader, true);
             });
diff --git a/core/src/mindustry/service/GameService.java b/core/src/mindustry/service/GameService.java
index 79d9aec34248b04e5a9686d902383ffe9ea1eb2e..28ba5c13699d028b34883ec897d742a32ad2cce5 100644
--- a/core/src/mindustry/service/GameService.java
+++ b/core/src/mindustry/service/GameService.java
@@ -99,6 +99,7 @@ public class GameService{
         //periodically check for various conditions
         float updateInterval = 2f;
         Timer.schedule(this::checkUpdate, updateInterval, updateInterval);
+        Timer.schedule(()->SStat.arcPlayTime.add(15),15,15);
 
         if(Items.thorium.unlocked()) obtainThorium.complete();
         if(Items.titanium.unlocked()) obtainTitanium.complete();
@@ -146,7 +147,8 @@ public class GameService{
                         SStat.bossesDefeated.add();
                     }
                 }
-            }
+            }else if(e.unit.team != Vars.player.team())
+                SStat.arcUnitsDestroyed.add();
         });
 
         Events.on(TurnEvent.class, e -> {
@@ -275,6 +277,7 @@ public class GameService{
                     }
                 }
             }
+            else if(e.unit != null && e.unit.isLocal() && !e.breaking)  SStat.arcBlocksBuilt.add();
 
             if(campaign() && e.unit != null && e.unit.isLocal() && e.breaking){
                 //hacky way of testing for boulders without string contains/endsWith
@@ -333,6 +336,8 @@ public class GameService{
         Events.on(BlockDestroyEvent.class, e -> {
             if(campaign() && e.tile.team() != player.team()){
                 SStat.blocksDestroyed.add();
+            }else if(e.tile.team() != player.team()){
+                SStat.arcBlocksDestroyed.add();
             }
         });
 
@@ -379,6 +384,9 @@ public class GameService{
             if(campaign()){
                 SStat.reactorsOverheated.add();
             }
+            else{
+                SStat.arcReactorsOverheated.add();
+            }
         });
 
         Events.on(GeneratorPressureExplodeEvent.class, e -> {
@@ -420,6 +428,7 @@ public class GameService{
             if(campaign() && e.unit.team() == player.team()){
                 SStat.unitsBuilt.add();
             }
+            else if(e.unit.team() == player.team()) SStat.arcUnitsBuilt.add();
         });
 
         Events.on(SectorLaunchEvent.class, e -> {
@@ -521,6 +530,9 @@ public class GameService{
                 useAnimdustryEmoji.complete();
             }
         });
+        Events.on(WorldLoadEvent.class, e -> {
+            SStat.arcMapsPlayed.add();
+        });
     }
 
     private void checkUpdate(){
diff --git a/core/src/mindustry/service/SStat.java b/core/src/mindustry/service/SStat.java
index 598d96d102f562512da647ad88d228a7e2e23e38..6e69f89d1b37a452dea6f99297fcd4e674b2442c 100644
--- a/core/src/mindustry/service/SStat.java
+++ b/core/src/mindustry/service/SStat.java
@@ -24,6 +24,14 @@ public enum SStat{
     schematicsCreated,
     bouldersDeconstructed, //TODO
     totalCampaignItems, //TODO
+
+    arcUnitsBuilt,
+    arcUnitsDestroyed,
+    arcBlocksBuilt,
+    arcBlocksDestroyed,
+    arcPlayTime,
+    arcMapsPlayed,
+    arcReactorsOverheated
     ;
 
     public int get(){
diff --git a/core/src/mindustry/type/UnitType.java b/core/src/mindustry/type/UnitType.java
index 3c66132fabaf01d9fc2b023a1588046661eb3f19..83380a111b0d36161e460500ad7c4483a598fe6a 100644
--- a/core/src/mindustry/type/UnitType.java
+++ b/core/src/mindustry/type/UnitType.java
@@ -17,6 +17,7 @@ import mindustry.ai.*;
 import mindustry.ai.Pathfinder.*;
 import mindustry.ai.types.*;
 import mindustry.annotations.Annotations.*;
+import mindustry.arcModule.draw.ARCUnits;
 import mindustry.content.*;
 import mindustry.core.*;
 import mindustry.ctype.*;
@@ -38,7 +39,7 @@ import mindustry.world.blocks.units.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
 import mindustryX.features.*;
-import mindustryX.features.*;
+import mindustryX.features.ui.*;
 
 import static arc.graphics.g2d.Draw.*;
 import static mindustry.Vars.*;
@@ -46,6 +47,8 @@ import static mindustry.Vars.*;
 public class UnitType extends UnlockableContent implements Senseable{
     public static final float shadowTX = -12, shadowTY = -13;
     private static final Vec2 legOffset = new Vec2();
+    public static float unitTrans = 1f;//current unitTrans when draw
+    private Table unitStatus = new Table();
 
     /** Environmental flags that are *all* required for this unit to function. 0 = any environment */
     public int envRequired = 0;
@@ -503,23 +506,96 @@ public class UnitType extends UnlockableContent implements Senseable{
 
     public void landed(Unit unit){}
 
+    private void displayStatusEffect(Unit unit,Table table){
+        if (unit.statuses().isEmpty()) return;
+        table.row().table(t -> {
+            for(StatusEntry entry : unit.statuses()) {
+                if (t.getChildren().size % 5 == 0) t.row();
+                t.add(new ItemImage(entry.effect.uiIcon,
+                        entry.effect.permanent || entry.time > Time.toHours * 10f ? "Inf" : UI.formatTime(entry.time)
+                )).padLeft(8f);
+            }
+        });
+    }
+
+    private void updateStatusTable(Unit unit){
+        unitStatus.clear();
+        displayStatusEffect(unit,unitStatus);
+
+        Table statusText = getStatustext(unit.healthMultiplier(), unit.damageMultiplier(), unit.reloadMultiplier(), unit.speedMultiplier());
+        if(statusText != null){
+            unitStatus.row();
+            unitStatus.add(statusText).growX().wrap().left();
+        }
+    }
+
+    public static Table getStatustext(float healthMultiplier, float damageMultiplier, float reloadMultiplier, float speedMultiplier){
+        Seq<String> statusText = new Seq<>();
+        if(healthMultiplier != 1f){
+            statusText.add(" [acid]血量[white]: " + FormatDefault.format(healthMultiplier));
+        }
+        if(damageMultiplier != 1f){
+            statusText.add(" [red]伤害[white]: " + FormatDefault.format(damageMultiplier));
+        }
+        if(reloadMultiplier != 1f){
+            statusText.add(" [violet]攻速[white]: " + FormatDefault.format(reloadMultiplier));
+        }
+        if(speedMultiplier != 1f){
+            statusText.add(" [cyan]移速[white]: " + FormatDefault.format(speedMultiplier));
+        }
+        if (statusText.isEmpty()) return null;
+        Table table = new Table();
+        for (int i = 0;i < statusText.size;i++) {
+            if (i % 2 == 0) table.add(">>");
+            table.add(statusText.get(i)).left();
+            if (i % 2 == 1) table.row();
+        }
+        return table;
+    }
+
     public void display(Unit unit, Table table){
         table.table(t -> {
             t.left();
             t.add(new Image(uiIcon)).size(iconMed).scaling(Scaling.fit);
-            t.labelWrap(unit.isPlayer() ? unit.getPlayer().coloredName() + "\n[lightgray]" + localizedName : localizedName).left().width(190f).padLeft(5);
+            if(unit.team.id < 6){
+                if (unit.isPlayer()) {
+                    t.labelWrap(unit.getPlayer().coloredName() + "\n[#" + unit.team.color + "]" + localizedName).left().width(190f).padLeft(5);
+                } else {
+                    t.labelWrap("[#" + unit.team.color + "]" + localizedName).left().width(190f).padLeft(5);
+                }
+            }else{
+                if (unit.isPlayer()) {
+                    t.labelWrap(unit.getPlayer().coloredName() + "\n[#" + unit.team.color + "]" + localizedName + "[" + unit.team.id + "]").left().width(190f).padLeft(5);
+                } else {
+                    t.labelWrap("[#" + unit.team.color + "]" + localizedName + "[" + unit.team.id + "]").left().width(190f).padLeft(5);
+                }
+            }
         }).growX().left();
         table.row();
 
         table.table(bars -> {
             bars.defaults().growX().height(20f).pad(4);
 
-            //TODO overlay shields
-            bars.add(new Bar("stat.health", Pal.health, unit::healthf).blink(Color.white));
+            bars.add(new Bar(() -> {
+                updateStatusTable(unit);
+                StringBuilder str = new StringBuilder();
+                if(unit.shield() > 0){
+                    str.append(FormatDefault.format(unit.health)).append("[gray]+[white]").append(FormatDefault.format(unit.shield));
+                }else{
+                    str.append("\uE813 ").append(new Format(4).percent(unit.health, unit.maxHealth));
+                }
+                if (!Mathf.equal(unit.healthBalance.rawMean(), 0f, 0.1f)) {
+                    str.append(unit.healthBalance.rawMean() < 0 ? "[scarlet]" : "[acid]+");
+                    float number = unit.healthBalance.rawMean() * Time.toSeconds;
+                    str.append(FormatDefault.format(number));
+                    str.append("/s[]");
+                }
+                return str.toString();
+            }, () -> Pal.health, unit::healthf).blink(Color.white));
             bars.row();
 
             if(state.rules.unitAmmo){
-                bars.add(new Bar(ammoType.icon() + " " + Core.bundle.get("stat.ammo"), ammoType.barColor(), () -> unit.ammo / ammoCapacity));
+                bars.add(new Bar(() -> ammoType.icon() + " " + Core.bundle.format("stat.ammoDetail", unit.ammo, ammoCapacity), () -> ammoType.barColor(), () -> unit.ammo / ammoCapacity));
                 bars.row();
             }
 
@@ -527,8 +603,11 @@ public class UnitType extends UnlockableContent implements Senseable{
                 ability.displayBars(unit, bars);
             }
 
-            if(payloadCapacity > 0 && unit instanceof Payloadc payload){
-                bars.add(new Bar("stat.payloadcapacity", Pal.items, () -> payload.payloadUsed() / unit.type().payloadCapacity));
+            if(unit instanceof Payloadc payload){
+                bars.add(new Bar(Strings.format("装载：@/@ @",
+                Strings.autoFixed(payload.payloadUsed() / tilesize / tilesize, 4),
+                Strings.autoFixed(payloadCapacity / tilesize / tilesize, 4),
+                StatUnit.blocksSquared.localized()), Pal.items, () -> payload.payloadUsed() / unit.type().payloadCapacity));
                 bars.row();
 
                 var count = new float[]{-1};
@@ -538,18 +617,21 @@ public class UnitType extends UnlockableContent implements Senseable{
                         count[0] = payload.payloadUsed();
                     }
                 }).growX().left().height(0f).pad(0f);
+                bars.row();
             }
         }).growX();
+        table.row();
+        table.table(t-> unitStatus = t).growX();
 
         if(unit.controller() instanceof LogicAI ai){
             table.row();
-            table.add(Blocks.microProcessor.emoji() + " " + Core.bundle.get("units.processorcontrol")).growX().wrap().left();
-            if(ai.controller != null && (Core.settings.getBool("mouseposition") || Core.settings.getBool("position"))){
-                table.row();
-                table.add("[lightgray](" + ai.controller.tileX() + ", " + ai.controller.tileY() + ")").growX().wrap().left();
-            }
+            table.table(tt->{
+                tt.add(Blocks.microProcessor.emoji() + " " + Core.bundle.get("units.processorcontrol")).growX().left();
+                if(ai.controller != null && (Core.settings.getBool("mouseposition") || Core.settings.getBool("position"))){
+                    tt.add("[lightgray](" + ai.controller.tileX() + ", " + ai.controller.tileY() + ")").growX().right();
+                }
+            }).growX().wrap().left();
             table.row();
-            table.label(() -> Iconc.settings + " " + (long)unit.flag + "").color(Color.lightGray).growX().wrap().left();
             if(net.active() && ai.controller != null && ai.controller.lastAccessed != null){
                 table.row();
                 table.add(Core.bundle.format("lastaccessed", ai.controller.lastAccessed)).growX().wrap().left();
@@ -560,6 +642,11 @@ public class UnitType extends UnlockableContent implements Senseable{
         }
 
         table.row();
+        table.table(t -> {
+            t.add(Iconc.settings + " " + (long)unit.flag + "").color(Color.lightGray).growX();
+            t.add(Fonts.getUnicodeStr(unit.type().name) + unit.team.data().countType(unit.type()) + "/" + Units.getStringCap(unit.team)).color(Color.lightGray).growX();
+        }).growX();
+        table.row();
     }
 
     /** @return whether this block supports a specific environment. */
@@ -1193,8 +1280,13 @@ public class UnitType extends UnlockableContent implements Senseable{
 
         boolean isPayload = !unit.isAdded();
 
-        Mechc mech = unit instanceof Mechc ? (Mechc)unit : null;
-        float z = isPayload ? Draw.z() : unit.elevation > 0.5f ? (lowAltitude ? Layer.flyingUnitLow : Layer.flyingUnit) : groundLayer + Mathf.clamp(hitSize / 4000f, 0, 0.01f);
+        //透明度
+
+        Mechc mech = unit instanceof Mechc ? (Mechc) unit : null;
+        float z = unit.elevation > 0.5f ? (lowAltitude ? Layer.flyingUnitLow : Layer.flyingUnit) : groundLayer + Mathf.clamp(hitSize / 4000f, 0, 0.01f);
+
+        unitTrans = ARCUnits.drawARCUnits(unit);
+        if(unitTrans == 0) return;
 
         if(unit.controller().isBeingControlled(player.unit())){
             drawControl(unit);
@@ -1357,11 +1449,13 @@ public class UnitType extends UnlockableContent implements Senseable{
             float size = (itemSize + Mathf.absin(Time.time, 5f, 1f)) * unit.itemTime;
 
             Draw.mixcol(Pal.accent, Mathf.absin(Time.time, 5f, 0.1f));
+            Draw.alpha(unitTrans);
             Draw.rect(unit.item().fullIcon,
             unit.x + Angles.trnsx(unit.rotation + 180f, itemOffsetY),
             unit.y + Angles.trnsy(unit.rotation + 180f, itemOffsetY),
             size, size, unit.rotation);
             Draw.mixcol();
+            Draw.alpha(unitTrans);
 
             size = ((3f + Mathf.absin(Time.time, 5f, 1f)) * unit.itemTime + 0.5f) * 2;
             Draw.color(Pal.accent);
@@ -1370,7 +1464,7 @@ public class UnitType extends UnlockableContent implements Senseable{
             unit.y + Angles.trnsy(unit.rotation + 180f, itemOffsetY),
             size, size);
 
-            if(unit.isLocal() && !renderer.pixelator.enabled()){
+            if(Core.settings.getBool("unitItemCarried") || (unit.isLocal() && !renderer.pixelator.enabled())){
                 Fonts.outline.draw(unit.stack.amount + "",
                 unit.x + Angles.trnsx(unit.rotation + 180f, itemOffsetY),
                 unit.y + Angles.trnsy(unit.rotation + 180f, itemOffsetY) - 3,
@@ -1431,10 +1525,12 @@ public class UnitType extends UnlockableContent implements Senseable{
 
     public void drawOutline(Unit unit){
         Draw.reset();
+        Draw.alpha(unitTrans); //
 
         if(Core.atlas.isFound(outlineRegion)){
             applyColor(unit);
             applyOutlineColor(unit);
+            Draw.alpha(unitTrans);
             Draw.rect(outlineRegion, unit.x, unit.y, unit.rotation - 90);
             Draw.reset();
         }
@@ -1443,6 +1539,8 @@ public class UnitType extends UnlockableContent implements Senseable{
     public void drawBody(Unit unit){
         applyColor(unit);
 
+        Draw.alpha(unitTrans); //
+
         Draw.rect(region, unit.x, unit.y, unit.rotation - 90);
 
         Draw.reset();
@@ -1452,6 +1550,9 @@ public class UnitType extends UnlockableContent implements Senseable{
         applyColor(unit);
 
         Draw.color(cellColor(unit));
+
+        Draw.alpha(unitTrans); //
+
         Draw.rect(cellRegion, unit.x, unit.y, unit.rotation - 90);
         Draw.reset();
     }
@@ -1517,9 +1618,11 @@ public class UnitType extends UnlockableContent implements Senseable{
                 float scl = shadowElevation * invDrown;
                 float elev = Mathf.slope(1f - leg.stage) * scl;
                 Draw.color(Pal.shadow);
+                Draw.alpha(unitTrans); //
                 Draw.rect(footRegion, leg.base.x + shadowTX * elev, leg.base.y + shadowTY * elev, position.angleTo(leg.base));
                 Draw.color();
             }
+            Draw.alpha(unitTrans); //
 
             Draw.mixcol(Tmp.c3, Tmp.c3.a);
 
@@ -1534,12 +1637,14 @@ public class UnitType extends UnlockableContent implements Senseable{
             Lines.line(legBaseRegion, leg.joint.x + Tmp.v1.x, leg.joint.y + Tmp.v1.y, leg.base.x, leg.base.y, false);
 
             if(jointRegion.found()){
+                Draw.alpha(unitTrans);
                 Draw.rect(jointRegion, leg.joint.x, leg.joint.y);
             }
         }
 
         //base joints are drawn after everything else
         if(baseJointRegion.found()){
+            Draw.alpha(unitTrans);
             for(int j = legs.length - 1; j >= 0; j--){
                 //TODO does the index / draw order really matter?
                 Vec2 position = unit.legOffset(legOffset, (j % 2 == 0 ? j/2 : legs.length - 1 - j/2)).add(unit);
@@ -1548,6 +1653,7 @@ public class UnitType extends UnlockableContent implements Senseable{
         }
 
         if(baseRegion.found()){
+            Draw.alpha(unitTrans);
             Draw.rect(baseRegion, unit.x, unit.y, rotation - 90);
         }
 
@@ -1601,7 +1707,7 @@ public class UnitType extends UnlockableContent implements Senseable{
 
         for(int i : Mathf.signs){
             Draw.mixcol(Tmp.c1.set(mechLegColor).lerp(Color.white, Mathf.clamp(unit.hitTime)), Math.max(Math.max(0, i * extension / mechStride), unit.hitTime));
-
+            Draw.alpha(unitTrans); //
             Draw.rect(legRegion,
             unit.x + Angles.trnsx(mech.baseRotation(), extension * i - boostTrns, -boostTrns*i),
             unit.y + Angles.trnsy(mech.baseRotation(), extension * i - boostTrns, -boostTrns*i),
@@ -1618,6 +1724,8 @@ public class UnitType extends UnlockableContent implements Senseable{
             Draw.color(Color.white);
         }
 
+        Draw.alpha(unitTrans); //
+
         Draw.rect(baseRegion, unit, mech.baseRotation() - 90);
 
         Draw.mixcol();
@@ -1641,6 +1749,13 @@ public class UnitType extends UnlockableContent implements Senseable{
         }
     }
 
+    public String typeColor() {
+        if (naval) return "[cyan]";
+        else if (allowLegStep) return "[magenta]";
+        else if (flying) return "[acid]";
+        else if (hovering) return "[sky]";
+        else return "[stat]";
+    }
     //endregion
 
     public static class UnitEngine implements Cloneable{
@@ -1657,6 +1772,7 @@ public class UnitType extends UnlockableContent implements Senseable{
         }
 
         public void draw(Unit unit){
+            if(unitTrans == 0) return;
             UnitType type = unit.type;
             float scale = type.useEngineElevation ? unit.elevation : 1f;
 
@@ -1680,12 +1796,14 @@ public class UnitType extends UnlockableContent implements Senseable{
             Draw.z(z);*/
 
             Draw.color(color);
+            Draw.alpha(unitTrans);
             Fill.circle(
             unit.x + ex,
             unit.y + ey,
             (radius + Mathf.absin(Time.time, 2f, radius / 4f)) * scale
             );
             Draw.color(type.engineColorInner);
+            Draw.alpha(unitTrans);
             Fill.circle(
             unit.x + ex - Angles.trnsx(rot + rotation, 1f),
             unit.y + ey - Angles.trnsy(rot + rotation, 1f),
diff --git a/core/src/mindustry/type/Weapon.java b/core/src/mindustry/type/Weapon.java
index f5fd2a75caa099baf96010bed9e1a29b6d631d4c..397b2e13f76cb078d96f14440fb4bd9cab685651 100644
--- a/core/src/mindustry/type/Weapon.java
+++ b/core/src/mindustry/type/Weapon.java
@@ -12,6 +12,8 @@ import arc.struct.*;
 import arc.util.*;
 import mindustry.ai.types.*;
 import mindustry.annotations.Annotations.*;
+import mindustry.arcModule.ARCVars;
+import mindustry.arcModule.draw.*;
 import mindustry.audio.*;
 import mindustry.content.*;
 import mindustry.entities.*;
@@ -24,6 +26,7 @@ import mindustry.graphics.*;
 import mindustry.world.meta.*;
 import mindustryX.features.*;
 
+import static arc.math.Mathf.doubleRadDeg;
 import static mindustry.Vars.*;
 
 public class Weapon implements Cloneable{
@@ -208,6 +211,7 @@ public class Weapon implements Cloneable{
         wy = unit.y + Angles.trnsy(rotation, x, y) + Angles.trnsy(weaponRotation, 0, -realRecoil);
 
         Draw.xscl = -Mathf.sign(flipSprite);
+        Draw.alpha(0.5f);
         Draw.rect(outlineRegion, wx, wy, weaponRotation);
         Draw.xscl = 1f;
     }
@@ -217,6 +221,20 @@ public class Weapon implements Cloneable{
         float z = Draw.z();
         Draw.z(z + layerOffset);
 
+        float unitTrans = UnitType.unitTrans;
+        boolean draw_unit = (unit.maxHealth+unit.shield ) > (float)Core.settings.getInt("minhealth_unitshown");
+        boolean draw_minunithealthbar = (unit.maxHealth+unit.shield ) > (float)Core.settings.getInt("minhealth_unithealthbarshown");
+
+        if(draw_unit==false){
+            draw_minunithealthbar = false;
+            unitTrans = 0f;
+        }
+
+        if(Core.settings.getBool("alwaysShowPlayerUnit") && (unit.controller() instanceof Player ||  unit.controller().isBeingControlled(player.unit()))){
+            unitTrans = 100f;
+            draw_minunithealthbar = true;
+        }
+
         float
         rotation = unit.rotation - 90,
         realRecoil = Mathf.pow(mount.recoil, recoilPow) * recoil,
@@ -225,10 +243,11 @@ public class Weapon implements Cloneable{
         wy = unit.y + Angles.trnsy(rotation, x, y) + Angles.trnsy(weaponRotation, 0, -realRecoil);
 
         if(shadow > 0){
-            Drawf.shadow(wx, wy, shadow);
+            Drawf.shadow(wx, wy, shadow, unitTrans);
         }
 
         if(top){
+            Draw.alpha(unitTrans);
             drawOutline(unit, mount);
         }
 
@@ -249,16 +268,19 @@ public class Weapon implements Cloneable{
 
         //fix color
         unit.type.applyColor(unit);
+        Draw.alpha(unitTrans);
 
         if(region.found()) Draw.rect(region, wx, wy, weaponRotation);
 
         if(cellRegion.found()){
             Draw.color(unit.type.cellColor(unit));
+            Draw.alpha(unitTrans);
             Draw.rect(cellRegion, wx, wy, weaponRotation);
             Draw.color();
         }
 
         if(heatRegion.found() && mount.heat > 0){
+            Draw.alpha(unitTrans);
             Draw.color(heatColor, mount.heat);
             Draw.blend(Blending.additive);
             Draw.rect(heatRegion, wx, wy, weaponRotation);
@@ -281,6 +303,23 @@ public class Weapon implements Cloneable{
 
         Draw.xscl = 1f;
 
+        if (draw_minunithealthbar && Core.settings.getBool("unitWeaponTargetLine") && mount.shoot){
+            if(mount.aimX !=0 && mount.aimY != 0  && Mathf.len(mount.aimX - wx, mount.aimY - wy) <= 1200f){
+                Lines.stroke(1f);
+                if (unit.controller() == player) {
+                    Draw.color(ARCVars.getPlayerEffectColor());
+                } else {
+                    Draw.color(unit.team.color);
+                }
+                Draw.alpha(0.8f);
+                Lines.line(wx, wy, mount.aimX, mount.aimY);
+                if(Core.settings.getInt("unitTargetType")==0 || !(unit.controller() instanceof Player))
+                    Lines.spikes(mount.aimX,mount.aimY,4f,4f,4, (float) (Math.atan((mount.aimX-wx)/(mount.aimY-wy)*doubleRadDeg))+45f);
+                Draw.reset();
+
+            }
+        }
+
         Draw.z(z);
     }
 
diff --git a/core/src/mindustry/ui/Fonts.java b/core/src/mindustry/ui/Fonts.java
index b32847a353f8d9cda2424b17ecadd43be99afc5f..fe2ae3c4aa8e40ada9f91c93e77443b494a91f31 100644
--- a/core/src/mindustry/ui/Fonts.java
+++ b/core/src/mindustry/ui/Fonts.java
@@ -30,7 +30,7 @@ public class Fonts{
     private static final String mainFont = "fonts/font.woff";
     private static final ObjectSet<String> unscaled = ObjectSet.with("iconLarge");
     private static ObjectIntMap<String> unicodeIcons = new ObjectIntMap<>();
-    private static ObjectMap<String, String> stringIcons = new ObjectMap<>();
+    public static ObjectMap<String, String> stringIcons = new ObjectMap<>();
     private static ObjectMap<String, TextureRegion> largeIcons = new ObjectMap<>();
     private static TextureRegion[] iconTable;
     private static int lastCid;
@@ -212,13 +212,13 @@ public class Fonts{
         FreeTypeFontParameter param = new FreeTypeFontParameter(){{
             borderColor = Color.darkGray;
             incremental = true;
-            size = 18;
+            size = getFontSize();
         }};
 
         Core.assets.load("outline", Font.class, new FreeTypeFontLoaderParameter(mainFont, param)).loaded = t -> Fonts.outline = t;
 
         Core.assets.load("tech", Font.class, new FreeTypeFontLoaderParameter("fonts/tech.ttf", new FreeTypeFontParameter(){{
-            size = 18;
+            size = getFontSize();
         }})).loaded = f -> {
             Fonts.tech = f;
             Fonts.tech.getData().down *= 1.5f;
@@ -302,9 +302,15 @@ public class Fonts{
         return draw;
     }
 
+    static int getFontSize(){
+        if (Core.settings.getInt("fontSize") < 5) Core.settings.put("fontSize",10);
+        float multiplier = Core.settings.getInt("fontSize") / 10f;
+        return (int) (18 * multiplier);
+    }
+
     static FreeTypeFontParameter fontParameter(){
         return new FreeTypeFontParameter(){{
-            size = 18;
+            size = getFontSize();
             shadowColor = Color.darkGray;
             shadowOffsetY = 2;
             incremental = true;
diff --git a/core/src/mindustry/ui/ItemImage.java b/core/src/mindustry/ui/ItemImage.java
index 6f20b9cd229a15a67d629e56762d86df3ec97012..c86a5349acf70c8eb52addba48b45de70bb831ce 100644
--- a/core/src/mindustry/ui/ItemImage.java
+++ b/core/src/mindustry/ui/ItemImage.java
@@ -47,6 +47,19 @@ public class ItemImage extends Stack{
         }));
     }
 
+    public ItemImage(TextureRegion region, String text){
+        add(new Table(o -> {
+            o.left();
+            o.add(new Image(region)).size(26f).scaling(Scaling.fit);
+        }));
+
+        add(new Table(t -> {
+            t.left().bottom();
+            t.add(text).get().setFontScale(1f);
+            t.pack();
+        }));
+    }
+
     public ItemImage(ItemStack stack){
         this(stack.item.uiIcon, stack.amount);
     }
diff --git a/core/src/mindustry/ui/Minimap.java b/core/src/mindustry/ui/Minimap.java
index 770b034943c7a043d50f6191b8d3b6df4e228196..b076d1f3ead935623c3182376f5d51375be4be94 100644
--- a/core/src/mindustry/ui/Minimap.java
+++ b/core/src/mindustry/ui/Minimap.java
@@ -3,10 +3,14 @@ package mindustry.ui;
 import arc.*;
 import arc.graphics.g2d.*;
 import arc.input.*;
+import arc.math.*;
+import arc.math.geom.*;
 import arc.scene.*;
 import arc.scene.event.*;
 import arc.scene.ui.layout.*;
+import arc.util.*;
 import mindustry.gen.*;
+import mindustry.input.*;
 
 import static mindustry.Vars.*;
 
@@ -93,7 +97,18 @@ public class Minimap extends Table{
 
             @Override
             public void clicked(InputEvent event, float x, float y){
-                ui.minimapfrag.toggle();
+                float sz = 16 * renderer.minimap.getZoom();
+                float dx = Mathf.clamp(Core.camera.position.x / 8, sz, world.width() - sz);
+                float dy = Mathf.clamp(Core.camera.position.y / 8, sz, world.height() - sz);
+
+                float ptilex = sz * 2 / width, ptiley = sz * 2 / height;
+                Vec2 pos = Tmp.v1.set(dx, dy).sub(sz, sz).add(x * ptilex, y * ptiley).scl(8);
+
+                if(control.input instanceof DesktopInput input){
+                    input.panning = true;
+                }
+
+                Core.camera.position.set(pos);
             }
         });
 
diff --git a/core/src/mindustry/ui/dialogs/ContentInfoDialog.java b/core/src/mindustry/ui/dialogs/ContentInfoDialog.java
index 8defe26a2482e54d24d9b12e4a9ae453e13348f3..9d6a3199037a4e33f114056124c62223dcfc7981 100644
--- a/core/src/mindustry/ui/dialogs/ContentInfoDialog.java
+++ b/core/src/mindustry/ui/dialogs/ContentInfoDialog.java
@@ -8,11 +8,13 @@ import arc.util.*;
 import mindustry.ctype.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
+import mindustry.ui.Styles;
 import mindustry.input.*;
 import mindustry.world.meta.*;
 
 import static arc.Core.*;
 import static mindustry.Vars.*;
+import static mindustry.arcModule.RFuncs.getPrefix;
 
 public class ContentInfoDialog extends BaseDialog{
 
@@ -38,8 +40,9 @@ public class ContentInfoDialog extends BaseDialog{
         content.checkStats();
 
         table.table(title1 -> {
-            title1.image(content.uiIcon).size(iconXLarge).scaling(Scaling.fit);
-            title1.add("[accent]" + content.localizedName + (settings.getBool("console") ? "\n[gray]" + content.name : "")).padLeft(5);
+            title1.image(content.uiIcon).size(iconXLarge).scaling(Scaling.fit).get().clicked(() -> Core.app.setClipboardText(content.emoji()));
+            int logicId = content.getLogicId();
+            title1.add("[accent]" + content.localizedName + "\n[gray]" + content.name + (logicId != -1 ? " <#" + logicId +">": "")).padLeft(5);
         });
 
         table.row();
@@ -89,16 +92,58 @@ public class ContentInfoDialog extends BaseDialog{
         }
 
         if(content.details != null){
-            table.add("[gray]" + (content.unlocked() || !content.hideDetails ? content.details : Iconc.lock + " " + Core.bundle.get("unlock.incampaign"))).pad(6).padTop(20).width(400f).wrap().fillX();
+            //table.add("[gray]" + (content.unlocked() || !content.hideDetails ? content.details : Iconc.lock + " " + Core.bundle.get("unlock.incampaign"))).pad(6).padTop(20).width(400f).wrap().fillX();
+            table.add("[gray]" + content.details ).pad(6).padTop(20).width(400f).wrap().fillX();
             table.row();
         }
 
         content.displayExtra(table);
 
+        table.table(t -> {
+            t.row();
+            t.table(tt->{
+                tt.button(content.emoji(), Styles.cleart, () -> Core.app.setClipboardText(content.emoji())).width(60f).tooltip(content.emoji());
+                tt.button(Icon.info, Styles.clearNonei, () -> Core.app.setClipboardText(content.name)).width(50f).tooltip(content.name);
+                tt.button(Icon.book, Styles.clearNonei, () -> Core.app.setClipboardText(content.description)).width(50f).tooltip(content.description);
+            });
+
+            t.row();
+            t.table(tt->{
+                tt.add("♐");
+                tt.button("简",  Styles.cleart, () -> {
+                    String message = arcItemInfo(content,false);
+                    int seperator = 145;
+                    for (int i=0; i < message.length()/(float)seperator;i++){
+                        Call.sendChatMessage(message.substring(i*seperator,Math.min(message.length(),(i+1)*seperator)));
+                    }
+                }).width(50f).disabled(!Core.settings.getBool("arcShareWaveInfo"));
+                tt.button("详",  Styles.cleart, () -> {
+                    String message = arcItemInfo(content,true);
+                    int seperator = 145;
+                    for (int i=0; i < message.length()/(float)seperator;i++){
+                        Call.sendChatMessage(message.substring(i*seperator,Math.min(message.length(),(i+1)*seperator)));
+                    }
+                }).width(50f).disabled(!Core.settings.getBool("arcShareWaveInfo"));
+
+
+            });
+
+        }).fillX().padLeft(10);
+
         ScrollPane pane = new ScrollPane(table);
         cont.add(pane);
 
         show();
     }
 
+    private String arcItemInfo(UnlockableContent content, boolean description) {
+        StringBuilder builder = getPrefix("sky", "Content");
+        builder.append("标记了" + content.localizedName + content.emoji());
+        builder.append("(" + content.name + ")");
+        if (content.description != null && description) {
+            builder.append("。介绍: " + content.description);
+        }
+        return builder.toString();
+    }
+
 }
diff --git a/core/src/mindustry/ui/dialogs/CustomRulesDialog.java b/core/src/mindustry/ui/dialogs/CustomRulesDialog.java
index 4efed965d12b7e407b408a677fd8f0ac63d3c168..4d394d0cd4f3733dbf8f05529c7c948f6dc2e2f8 100644
--- a/core/src/mindustry/ui/dialogs/CustomRulesDialog.java
+++ b/core/src/mindustry/ui/dialogs/CustomRulesDialog.java
@@ -3,6 +3,7 @@ package mindustry.ui.dialogs;
 import arc.*;
 import arc.func.*;
 import arc.graphics.*;
+import arc.math.geom.*;
 import arc.scene.style.*;
 import arc.scene.ui.*;
 import arc.scene.ui.ImageButton.*;
@@ -16,13 +17,15 @@ import mindustry.game.*;
 import mindustry.game.Rules.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
+import mindustry.graphics.g3d.*;
 import mindustry.io.*;
 import mindustry.type.*;
 import mindustry.type.Weather.*;
 import mindustry.ui.*;
 import mindustry.world.*;
+import mindustryX.features.*;
 
-import static arc.util.Time.*;
+import static arc.util.Time.toMinutes;
 import static mindustry.Vars.*;
 
 public class CustomRulesDialog extends BaseDialog{
@@ -31,6 +34,8 @@ public class CustomRulesDialog extends BaseDialog{
     private Prov<Rules> resetter;
     private LoadoutDialog loadoutDialog;
 
+    private Seq<Team> teams;
+
     public CustomRulesDialog(){
         super("@mode.custom");
 
@@ -40,6 +45,8 @@ public class CustomRulesDialog extends BaseDialog{
         shown(this::setup);
         addCloseButton();
 
+        teams = Seq.with(Team.baseTeams);
+
         buttons.button("@edit", Icon.pencil, () -> {
             BaseDialog dialog = new BaseDialog("@waves.edit");
             dialog.addCloseButton();
@@ -187,12 +194,10 @@ public class CustomRulesDialog extends BaseDialog{
         check("@rules.wavesending", b -> rules.waveSending = b, () -> rules.waveSending, () -> rules.waves);
         check("@rules.wavetimer", b -> rules.waveTimer = b, () -> rules.waveTimer, () -> rules.waves);
         check("@rules.waitForWaveToEnd", b -> rules.waitEnemies = b, () -> rules.waitEnemies, () -> rules.waves && rules.waveTimer);
+        number("@rules.winWave", b -> rules.winWave = (int)b, () -> (int)rules.winWave);
         numberi("@rules.wavelimit", f -> rules.winWave = f, () -> rules.winWave, () -> rules.waves, 0, Integer.MAX_VALUE);
         number("@rules.wavespacing", false, f -> rules.waveSpacing = f * 60f, () -> rules.waveSpacing / 60f, () -> rules.waves && rules.waveTimer, 1, Float.MAX_VALUE);
-        //this is experimental, because it's not clear that 0 makes it default.
-        if(experimental){
-            number("@rules.initialwavespacing", false, f -> rules.initialWaveSpacing = f * 60f, () -> rules.initialWaveSpacing / 60f, () -> rules.waves && rules.waveTimer, 0, Float.MAX_VALUE);
-        }
+        number("@rules.initialwavespacing", false, f -> rules.initialWaveSpacing = f * 60f, () -> rules.initialWaveSpacing / 60f, () -> rules.waves && rules.waveTimer, 0, Float.MAX_VALUE);
         number("@rules.dropzoneradius", false, f -> rules.dropZoneRadius = f * tilesize, () -> rules.dropZoneRadius / tilesize, () -> rules.waves);
 
         title("@rules.title.resourcesbuilding");
@@ -211,7 +216,7 @@ public class CustomRulesDialog extends BaseDialog{
         check("@rules.reactorexplosions", b -> rules.reactorExplosions = b, () -> rules.reactorExplosions);
         check("@rules.schematic", b -> rules.schematicsAllowed = b, () -> rules.schematicsAllowed);
         check("@rules.coreincinerates", b -> rules.coreIncinerates = b, () -> rules.coreIncinerates);
-        check("@rules.cleanupdeadteams", b -> rules.cleanupDeadTeams = b, () -> rules.cleanupDeadTeams, () -> rules.pvp);
+        check("@rules.cleanupdeadteams", b -> rules.cleanupDeadTeams = b, () -> rules.cleanupDeadTeams);
         check("@rules.disableworldprocessors", b -> rules.disableWorldProcessors = b, () -> rules.disableWorldProcessors);
         number("@rules.buildcostmultiplier", false, f -> rules.buildCostMultiplier = f, () -> rules.buildCostMultiplier, () -> !rules.infiniteResources);
         number("@rules.buildspeedmultiplier", f -> rules.buildSpeedMultiplier = f, () -> rules.buildSpeedMultiplier, 0.001f, 50f);
@@ -227,6 +232,7 @@ public class CustomRulesDialog extends BaseDialog{
         )).left().width(300f).row();
 
         main.button("@bannedblocks", () -> showBanned("@bannedblocks", ContentType.block, rules.bannedBlocks, Block::canBeBuilt)).left().width(300f).row();
+        main.button("@revealedblocks", () -> showBanned("@revealedblocks", ContentType.block, rules.revealedBlocks, b -> b.showUnlock() && (!b.isVanilla() || b.hasEmoji()))).left().width(300f).row();
         check("@rules.hidebannedblocks", b -> rules.hideBannedBlocks = b, () -> rules.hideBannedBlocks);
         check("@bannedblocks.whitelist", b -> rules.blockWhitelist = b, () -> rules.blockWhitelist);
 
@@ -253,6 +259,7 @@ public class CustomRulesDialog extends BaseDialog{
         check("@rules.explosions", b -> rules.damageExplosions = b, () -> rules.damageExplosions);
         check("@rules.fire", b -> rules.fire = b, () -> rules.fire);
         check("@rules.fog", b -> rules.fog = b, () -> rules.fog);
+        check("@rules.staticFog", b -> rules.staticFog = b, () -> rules.staticFog);
         check("@rules.lighting", b -> rules.lighting = b, () -> rules.lighting);
 
         if(experimental){
@@ -274,9 +281,43 @@ public class CustomRulesDialog extends BaseDialog{
             }).margin(4).size(50f).padRight(10);
             b.add("@rules.ambientlight");
         }, () -> ui.picker.show(rules.ambientLight, rules.ambientLight::set)).left().width(250f).row();
+        main.button(b -> {
+            b.left();
+            b.table(Tex.pane, in -> {
+                in.stack(new Image(Tex.alphaBg), new Image(Tex.whiteui){{
+                    update(() -> setColor(rules.staticColor));
+                }}).grow();
+            }).margin(4).size(50f).padRight(10);
+            b.add("@rules.staticColor");
+        }, () -> ui.picker.show(rules.staticColor, rules.staticColor::set)).left().width(250f).row();
+        main.button(b -> {
+            b.left();
+            b.table(Tex.pane, in -> {
+                in.stack(new Image(Tex.alphaBg), new Image(Tex.whiteui){{
+                    update(() -> setColor(rules.dynamicColor));
+                }}).grow();
+            }).margin(4).size(50f).padRight(10);
+            b.add("@rules.dynamicColor");
+        }, () -> ui.picker.show(rules.dynamicColor, rules.dynamicColor::set)).left().width(250f).row();
 
         main.button("@rules.weather", this::weatherDialog).width(250f).left().row();
 
+        title("@rules.title.arcExperimental");
+        check("@rules.logicUnitBuild", b -> rules.logicUnitBuild = b, () -> rules.logicUnitBuild);
+        check("@rules.coreDestroyClear",b->rules.coreDestroyClear = b,()->rules.coreDestroyClear);
+        check("@rules.unitPayloadUpdate",b->rules.unitPayloadUpdate = b,()->rules.unitPayloadUpdate);
+        check("@rules.showSpawns",b->rules.showSpawns = b,()->rules.showSpawns);
+        check("允许控制单位", b -> rules.possessionAllowed = b, () -> rules.possessionAllowed);
+        check("禁用重建", b -> rules.ghostBlocks = b, () -> !rules.ghostBlocks);
+        main.button("@hiddenBuildItems", () -> showBanned("@hiddenBuildItems", ContentType.item, rules.hiddenBuildItems, Item::showUnlock)).left().width(300f).row();
+
+        check("@rules.limitarea", b -> rules.limitMapArea = b, () -> rules.limitMapArea);
+        numberi("x", x -> state.rules.limitX = x, () -> state.rules.limitX, () -> state.rules.limitMapArea, 0, 10000);
+        numberi("y", y -> state.rules.limitY = y, () -> state.rules.limitY, () -> state.rules.limitMapArea, 0, 10000);
+        numberi("w", w -> state.rules.limitWidth = w, () -> state.rules.limitWidth, () -> state.rules.limitMapArea, 0, 10000);
+        numberi("h", h -> state.rules.limitHeight = h, () -> state.rules.limitHeight, () -> state.rules.limitMapArea, 0, 10000);
+        check("@rules.disableOutsideArea",b -> rules.disableOutsideArea = b, () -> rules.disableOutsideArea);
+
         title("@rules.title.planet");
 
         main.table(Tex.button, t -> {
@@ -286,7 +327,7 @@ public class CustomRulesDialog extends BaseDialog{
 
             t.defaults().size(140f, 50f);
 
-            for(Planet planet : content.planets().select(p -> p.accessible && p.visible && p.isLandable())){
+            for(Planet planet : content.planets()){
                 t.button(planet.localizedName, style, () -> {
                     planet.applyRules(rules);
                 }).group(group).checked(b -> rules.planet == planet);
@@ -305,10 +346,29 @@ public class CustomRulesDialog extends BaseDialog{
 
         title("@rules.title.teams");
 
+        main.button("所有队伍开启无限火力", () -> {
+            for(Team team : Team.all){
+                team.rules().cheat = true;
+            }
+            setup();
+        }).width(256f).height(32f).row();
+        main.button("所有队伍关闭无限火力", () -> {
+            for(Team team : Team.all){
+                team.rules().cheat = false;
+            }
+            setup();
+        }).width(256f).height(32f).row();
+
         team("@rules.playerteam", t -> rules.defaultTeam = t, () -> rules.defaultTeam);
         team("@rules.enemyteam", t -> rules.waveTeam = t, () -> rules.waveTeam);
 
-        for(Team team : Team.baseTeams){
+        main.button("更多队伍设置", Styles.flatBordert, () -> UIExt.teamSelect.select(team -> teams.contains(team), team -> {
+            if(teams.contains(team)) teams.remove(team);
+            else teams.add(team);
+            setup();
+        })).marginLeft(14f).fillX().height(55f).row();
+
+        for(Team team : teams){
             boolean[] shown = {false};
             Table wasMain = main;
 
@@ -324,6 +384,10 @@ public class CustomRulesDialog extends BaseDialog{
                 main = t;
                 TeamRule teams = rules.teams.get(team);
 
+                check("@rules.cheat", b -> teams.cheat = b, () -> teams.cheat);
+                check("@rules.infiniteAmmo",b -> teams.infiniteAmmo = b, () -> teams.infiniteAmmo);
+                check("@rules.aiCoreSpawn", b -> teams.aiCoreSpawn = b, () -> teams.aiCoreSpawn);
+
                 number("@rules.blockhealthmultiplier", f -> teams.blockHealthMultiplier = f, () -> teams.blockHealthMultiplier);
                 number("@rules.blockdamagemultiplier", f -> teams.blockDamageMultiplier = f, () -> teams.blockDamageMultiplier);
 
@@ -348,6 +412,33 @@ public class CustomRulesDialog extends BaseDialog{
                 main = wasMain;
             }, () -> shown[0]).growX().row();
         }
+
+        title("地图背景[lightgray]需要设置空地板");
+        check("自定义背景", t -> {
+            rules.planetBackground = t ? new PlanetParams(){{planet = Planets.sun;zoom=1f;camPos = new Vec3(1.2388899f, 1.6047299f, 2.4758825f);}} : null;
+            setup();
+        }, () -> rules.planetBackground != null);
+        if (rules.planetBackground != null){
+            main.table(Tex.button, t -> {
+                t.margin(10f);
+                var group = new ButtonGroup<>();
+                var style = Styles.flatTogglet;
+
+                t.defaults().size(140f, 50f);
+
+                for(Planet planet : content.planets()){
+                    t.button(planet.localizedName, style, () -> rules.planetBackground.planet = planet).group(group).checked(b -> rules.planetBackground.planet == planet);
+                    if(t.getChildren().size % 3 == 0){
+                        t.row();
+                    }
+                }
+            }).left().fill(false).expand(false, false).row();
+            number("放缩", f -> rules.planetBackground.zoom = f, () -> rules.planetBackground.zoom, 0.0001f, 999);
+            number("位置x", f -> rules.planetBackground.camPos.x = f, () -> rules.planetBackground.camPos.x);
+            number("位置y", f -> rules.planetBackground.camPos.y = f, () -> rules.planetBackground.camPos.y);
+            number("位置z", f -> rules.planetBackground.camPos.z = f, () -> rules.planetBackground.camPos.z);
+        }
+
     }
 
     void team(String text, Cons<Team> cons, Prov<Team> prov){
@@ -360,6 +451,7 @@ public class CustomRulesDialog extends BaseDialog{
                     cons.get(team);
                 }).pad(1f).checked(b -> prov.get() == team).size(60f).tooltip(team.coloredName()).with(i -> i.getStyle().imageUpColor = team.color);
             }
+            t.button(Icon.add, Styles.squareTogglei, 38f, () -> UIExt.teamSelect.pickOne(cons, prov.get())).pad(1f).checked(b -> !Seq.with(Team.baseTeams).contains(prov.get())).size(60f).tooltip("[acid]更多队伍选择");
         }).padTop(0).row();
     }
 
@@ -391,7 +483,7 @@ public class CustomRulesDialog extends BaseDialog{
             t.field((prov.get()) + "", s -> cons.get(Strings.parseInt(s)))
                 .update(a -> a.setDisabled(!condition.get()))
                 .padRight(100f)
-                .valid(f -> Strings.parseInt(f) >= min && Strings.parseInt(f) <= max).width(120f).left();
+                .valid(f -> Strings.parseInt(f) >= -999999 && Strings.parseInt(f) <= 999999999).width(120f).left();
         }).padTop(0).row();
     }
 
@@ -403,7 +495,8 @@ public class CustomRulesDialog extends BaseDialog{
             t.field((integer ? (int)prov.get() : prov.get()) + "", s -> cons.get(Strings.parseFloat(s)))
             .padRight(100f)
             .update(a -> a.setDisabled(!condition.get()))
-            .valid(f -> Strings.canParsePositiveFloat(f) && Strings.parseFloat(f) >= min && Strings.parseFloat(f) <= max).width(120f).left();
+            //.valid(f -> Strings.canParsePositiveFloat(f) && Strings.parseFloat(f) >= min && Strings.parseFloat(f) <= max).width(120f).left();
+            .valid(f ->  Strings.canParsePositiveFloat(f)).width(120f).left();
         }).padTop(0);
         main.row();
     }
@@ -418,7 +511,7 @@ public class CustomRulesDialog extends BaseDialog{
     }
 
     void title(String text){
-        main.add(text).color(Pal.accent).padTop(20).padRight(100f).padBottom(-3);
+        main.add(text).color(Pal.accent).padTop(20).center().padBottom(-3);
         main.row();
         main.image().color(Pal.accent).height(3f).padRight(100f).padBottom(20);
         main.row();
diff --git a/core/src/mindustry/ui/dialogs/DatabaseDialog.java b/core/src/mindustry/ui/dialogs/DatabaseDialog.java
index 9ef878c280d567340d9fc4753d310b73be3397a2..41f4c1d4d2d578ac16604c3224d25c17e0d87a7b 100644
--- a/core/src/mindustry/ui/dialogs/DatabaseDialog.java
+++ b/core/src/mindustry/ui/dialogs/DatabaseDialog.java
@@ -16,9 +16,10 @@ import mindustry.graphics.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.*;
+import mindustryX.features.ui.*;
 
-import static arc.Core.*;
 import static mindustry.Vars.*;
+import static mindustry.arcModule.RFuncs.colorizeContent;
 
 public class DatabaseDialog extends BaseDialog{
     private TextField search;
@@ -41,6 +42,7 @@ public class DatabaseDialog extends BaseDialog{
         }).fillX().padBottom(4).row();
 
         cont.pane(all).scrollX(false);
+        colorizeContent();
     }
 
     void rebuild(){
@@ -53,7 +55,8 @@ public class DatabaseDialog extends BaseDialog{
             ContentType type = ContentType.all[j];
 
             Seq<UnlockableContent> array = allContent[j]
-                .select(c -> c instanceof UnlockableContent u && !u.isHidden()  &&
+                .select(c -> c instanceof UnlockableContent u &&
+                    (AdvanceToolTable.allBlocksReveal || !u.isHidden()) &&
                     (text.isEmpty() || u.localizedName.toLowerCase().contains(text.toLowerCase()))).as();
             if(array.size == 0) continue;
 
@@ -98,7 +101,7 @@ public class DatabaseDialog extends BaseDialog{
                                 ui.content.show(unlock);
                             }
                         });
-                        image.addListener(new Tooltip(t -> t.background(Tex.button).add(unlock.localizedName + (settings.getBool("console") ? "\n[gray]" + unlock.name : ""))));
+                        image.addListener(new Tooltip(t -> t.background(Tex.button).add(unlock.localizedName + "\n[gray]" + unlock.name + (logicVars.lookupLogicId(unlock) != -1 ? " <#" + logicVars.lookupLogicId(unlock) +">": ""))));
                     }
 
                     if((++count) % cols == 0){
@@ -115,6 +118,7 @@ public class DatabaseDialog extends BaseDialog{
     }
 
     boolean unlocked(UnlockableContent content){
-        return (!Vars.state.isCampaign() && !Vars.state.isMenu()) || content.unlocked();
+        //return (!Vars.state.isCampaign() && !Vars.state.isMenu()) || content.unlocked();
+        return true;
     }
 }
diff --git a/core/src/mindustry/ui/dialogs/JoinDialog.java b/core/src/mindustry/ui/dialogs/JoinDialog.java
index b6b2476761f45f88824645cd9870b543d217a530..d2c1840681112e0751c36ac0273c7c1a395946dc 100644
--- a/core/src/mindustry/ui/dialogs/JoinDialog.java
+++ b/core/src/mindustry/ui/dialogs/JoinDialog.java
@@ -12,6 +12,7 @@ import arc.util.*;
 import arc.util.Timer.*;
 import arc.util.serialization.*;
 import mindustry.*;
+import mindustry.arcModule.ui.dialogs.USIDDialog;
 import mindustry.core.*;
 import mindustry.game.EventType.*;
 import mindustry.gen.*;
@@ -143,6 +144,10 @@ public class JoinDialog extends BaseDialog{
         remote.clear();
 
         for(Server server : servers){
+            if(server.lastHost != null){
+                int ServerVersion = server.lastHost.version;
+                if(Core.settings.getBool("showAccessibleServer") && (ServerVersion != Version.build && Version.build != -1 && ServerVersion != -1)) continue;
+            }
             //why are java lambdas this bad
             Button[] buttons = {null};
 
@@ -328,6 +333,14 @@ public class JoinDialog extends BaseDialog{
         hosts.marginBottom(70f);
 
         section(steam ? "@servers.local.steam" : "@servers.local", local, false);
+        section("学术功能", new Table(t -> {
+            t.button("", Styles.flatBordert, () -> {
+                Core.settings.put("showAccessibleServer", !Core.settings.getBool("showAccessibleServer"));
+                setupRemote();
+            }).growX().height(48).update(b -> b.setText((Core.settings.getBool("showAccessibleServer") ? "显示" : "隐藏") + "版本不对的服务器"));
+            t.button("usid管理器", Styles.flatBordert, () -> new USIDDialog().show()).growX().height(48);
+            USIDDialog.chooseUSID = Core.settings.getBool("arc-chooseUSID", false);
+        }), false);
         section("@servers.remote", remote, false);
         section("@servers.global", global, true);
 
@@ -551,6 +564,8 @@ public class JoinDialog extends BaseDialog{
             netClient.disconnectQuietly();
         });
 
+        if (net.client()) netClient.disconnectQuietly();
+
         Time.runTask(2f, () -> {
             logic.reset();
             net.reset();
diff --git a/core/src/mindustry/ui/dialogs/KeybindDialog.java b/core/src/mindustry/ui/dialogs/KeybindDialog.java
index 1f9ead9a31e94f8a4380c53889d31b229904ecc9..339d2b3afddbb3d128fec9e0aac336cc1e0eaf62 100644
--- a/core/src/mindustry/ui/dialogs/KeybindDialog.java
+++ b/core/src/mindustry/ui/dialogs/KeybindDialog.java
@@ -143,7 +143,7 @@ public class KeybindDialog extends Dialog{
                         rebindAxis = true;
                         rebindMin = true;
                         openDialog(section, keybind);
-                    }).width(130f);
+                    }).width(100f);
                 }else{
                     table.add(bundle.get("keybind." + keybind.name() + ".name", Strings.capitalize(keybind.name())), Color.white).left().padRight(40).padLeft(8);
                     table.label(() -> keybinds.get(section, keybind).key.toString()).color(Pal.accent).left().minWidth(90).padRight(20);
@@ -152,9 +152,12 @@ public class KeybindDialog extends Dialog{
                         rebindAxis = false;
                         rebindMin = false;
                         openDialog(section, keybind);
-                    }).width(130f);
+                    }).width(100f);
                 }
-                table.button("@settings.resetKey", tstyle, () -> keybinds.resetToDefault(section, keybind)).width(130f).pad(2f).padLeft(4f);
+                table.button("取消绑定", tstyle, () -> {
+                    section.binds.get(section.device.type(), OrderedMap::new).put(keybind, new Axis(KeyCode.unknown));
+                }).width(100f).pad(2f).padLeft(4f);
+                table.button("@settings.resetKey", tstyle, () -> keybinds.resetToDefault(section, keybind)).width(100f).pad(2f).padLeft(4f);
                 table.row();
             }
 
diff --git a/core/src/mindustry/ui/dialogs/ModsDialog.java b/core/src/mindustry/ui/dialogs/ModsDialog.java
index cfc64166ab474960ad13e1784605e9078c33d16e..fd3a32ec5767d989cee9c4e0b254e7d59a830407 100644
--- a/core/src/mindustry/ui/dialogs/ModsDialog.java
+++ b/core/src/mindustry/ui/dialogs/ModsDialog.java
@@ -49,6 +49,10 @@ public class ModsDialog extends BaseDialog{
     public ModsDialog(){
         super("@mods");
         addCloseButton();
+        buttons.addChild(new Table(t->{
+            t.setFillParent(true);
+            t.right().button("?", () -> ui.showInfo("@mods.info")).size(60f, 64f);
+        }));
 
         browser = new BaseDialog("@mods.browser");
 
diff --git a/core/src/mindustry/ui/dialogs/PausedDialog.java b/core/src/mindustry/ui/dialogs/PausedDialog.java
index 129e64d65876b8282e74e333e2ed320c44566a5f..83908f9aa063e0f83a2208aba43782a13e3cdbe6 100644
--- a/core/src/mindustry/ui/dialogs/PausedDialog.java
+++ b/core/src/mindustry/ui/dialogs/PausedDialog.java
@@ -41,7 +41,7 @@ public class PausedDialog extends BaseDialog{
             cont.button("@back", Icon.left, this::hide).name("back");
             cont.button("@settings", Icon.settings, ui.settings::show).name("settings");
 
-            if(!state.isCampaign() && !state.isEditor()){
+            if(Core.settings.getBool("save_more_map") || (!state.isCampaign() && !state.isEditor())){
                 cont.row();
                 cont.button("@savegame", Icon.save, save::show);
                 cont.button("@loadgame", Icon.upload, load::show).disabled(b -> net.active());
@@ -59,6 +59,10 @@ public class PausedDialog extends BaseDialog{
 
             cont.row();
 
+            cont.button("@joingame", Icon.host, () -> {
+                this.hide();
+                ui.join.show();
+            });
             cont.button("@quit", Icon.exit, this::showQuitConfirm).colspan(2).width(dw + 10f).update(s -> s.setText(control.saves.getCurrent() != null && control.saves.getCurrent().isAutosave() ? "@save.quit" : "@quit"));
 
         }else{
@@ -91,6 +95,12 @@ public class PausedDialog extends BaseDialog{
                 s.setText(control.saves.getCurrent() != null && control.saves.getCurrent().isAutosave() ? "@save.quit" : "@quit");
                 s.getLabelCell().growX().wrap();
             });
+
+            if(mobile){
+                cont.row();
+                int columns = cont.getColumns();
+                cont.button("@database", Icon.book, ui.database::show).colspan(columns).size(Float.NEGATIVE_INFINITY, 60).fillX();
+            }
         }
     }
 
diff --git a/core/src/mindustry/ui/dialogs/PlanetDialog.java b/core/src/mindustry/ui/dialogs/PlanetDialog.java
index 16d5d9e304dacd2ae477e26d5094e6cdfc87e605..a9be9507de3128df0b37f218e10ab060a1be757b 100644
--- a/core/src/mindustry/ui/dialogs/PlanetDialog.java
+++ b/core/src/mindustry/ui/dialogs/PlanetDialog.java
@@ -18,6 +18,7 @@ import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
 import mindustry.*;
+import mindustry.arcModule.*;
 import mindustry.content.*;
 import mindustry.content.TechTree.*;
 import mindustry.core.*;
@@ -38,6 +39,7 @@ import mindustry.world.blocks.storage.*;
 
 import static arc.Core.*;
 import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
 import static mindustry.graphics.g3d.PlanetRenderer.*;
 import static mindustry.ui.dialogs.PlanetDialog.Mode.*;
 
@@ -74,9 +76,13 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
     private Texture[] planetTextures;
 
+    private boolean alwaysShowName = false;
+
+    private int viewInt = 60;
+
     public PlanetDialog(){
         super("", Styles.fullDialog);
-        
+
         state.renderer = this;
         state.drawUi = true;
 
@@ -185,7 +191,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
                         b.row();
                         b.image(new TextureRegionDrawable(tex)).grow().scaling(Scaling.fit);
                     }, Styles.togglet, () -> selected[0] = planet).size(mobile ? 220f : 320f).group(group);
-                    i ++;
+                    i++;
                 }
 
                 diag.cont.row();
@@ -290,6 +296,13 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
             buttons.add().growX();
             buttons.add(sectorTop).minWidth(230f);
             buttons.add().growX();
+            buttons.button("显示周期", Icon.settings, () -> {
+                if(viewInt == 1) viewInt = 60;
+                else if(viewInt == 60) viewInt = 120;
+                else viewInt = 1;
+                arcui.arcInfo("调整资源输入|输出显示周期为 [orange]" + viewInterval(viewInt));
+            }).size(100f, 54f).pad(2).bottom();
+            buttons.button("区块名称", Icon.bookOpen, () -> alwaysShowName = !alwaysShowName).size(100f, 54f).pad(2).bottom();
             addTech();
         }
     }
@@ -391,9 +404,9 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
         }
 
         return sector.planet.generator != null ?
-            //use planet impl when possible
-            sector.planet.generator.allowLanding(sector) :
-            sector.hasBase() || sector.near().contains(Sector::hasBase); //near an occupied sector
+        //use planet impl when possible
+        sector.planet.generator.allowLanding(sector) :
+        sector.hasBase() || sector.near().contains(Sector::hasBase); //near an occupied sector
     }
 
     Sector findLauncher(Sector to){
@@ -430,8 +443,8 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
                     Color color =
                     sec.hasBase() ? Tmp.c2.set(Team.sharded.color).lerp(Team.crux.color, sec.hasEnemyBase() ? 0.5f : 0f) :
                     sec.preset != null ?
-                        sec.preset.unlocked() ? Tmp.c2.set(Team.derelict.color).lerp(Color.white, Mathf.absin(Time.time, 10f, 1f)) :
-                        Color.gray :
+                    sec.preset.unlocked() ? Tmp.c2.set(Team.derelict.color).lerp(Color.white, Mathf.absin(Time.time, 10f, 1f)) :
+                    Color.gray :
                     sec.hasEnemyBase() ? Team.crux.color :
                     null;
 
@@ -500,7 +513,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
     @Override
     public void renderProjections(Planet planet){
-        float iw = 48f/4f;
+        float iw = 48f / 4f;
 
         for(Sector sec : planet.sectors){
             if(sec != hovered){
@@ -520,6 +533,11 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
                         Draw.rect(icon, 0, 0, iw, iw * icon.height / icon.width);
                     });
                 }
+                planets.drawPlane(sec, () -> {
+                    if((canSelect(sec) || sec.hasBase()) && alwaysShowName){
+                        DrawUtilities.drawText((sec.preset != null ? "" : "[gray]") + sec.name(), 0.5f, 0, 0, 0);
+                    }
+                });
             }
         }
 
@@ -664,7 +682,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
             //sector notifications & search
             c.top().right();
-            c.defaults().width(290f);
+            c.defaults().width(350f);
 
             c.button(bundle.get("sectorlist") +
             (attacked == 0 ? "" : "\n[red]⚠[lightgray] " + bundle.format("sectorlist.attacked", "[red]" + attacked + "[]")),
@@ -708,7 +726,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
             readd[0] = () -> {
                 con.clearChildren();
-                for(Sector sec : all){
+                for(Sector sec : all.copy().sort(sector -> sector.info.production.size)){
                     if(sec.hasBase() && (searchText.isEmpty() || sec.name().toLowerCase().contains(searchText.toLowerCase()))){
                         con.button(t -> {
                             t.marginRight(10f);
@@ -727,6 +745,19 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
                                 String ic = sec.iconChar() == null ? "" : sec.iconChar() + " ";
 
                                 head.add(ic + sec.name()).growX().wrap();
+
+                                if(!mobile && !sec.info.export.isEmpty() && sec.info.destination != null && sec.info.destination.hasBase()){
+                                    String des = sec.info.destination.iconChar();
+                                    String text = Iconc.rightOpen + " " + (des == null || des.isEmpty() ? "" : des + " ") + sec.info.destination.name();
+                                    head.button(text, Styles.cleart, () -> {
+                                        ui.planet.showSelect(sec, other -> {
+                                            if(other.planet == sec.planet){
+                                                sec.info.destination = other;
+                                            }
+                                        });
+                                    }).minWidth(150f).right().padRight(10f);
+                                }
+
                             }).growX().row();
 
                             if(sec.isAttacked()){
@@ -765,7 +796,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
             buffer.end();
 
             Draw.color(color);
-            Draw.rect(Draw.wrap(buffer.getTexture()), width/2f, height/2f, width, -height);
+            Draw.rect(Draw.wrap(buffer.getTexture()), width / 2f, height / 2f, width, -height);
             Draw.color();
         }
     }
@@ -874,14 +905,15 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
         Table t = new Table().left();
 
         int i = 0;
+        int rowSet = settings.getInt("itemSelectionWidth");
         for(var item : content.items()){
             var stat = stats.get(item);
             if(stat == null) continue;
-            int total = (int)(stat.mean * 60 * scl);
-            if(total > 1){
+            int total = (int)(stat.mean * viewInt * scl);
+            if(total != 0){
                 t.image(item.uiIcon).padRight(3);
-                t.add(UI.formatAmount(total) + " " + Core.bundle.get("unit.perminute")).color(Color.lightGray).padRight(3);
-                if(++i % 3 == 0){
+                t.add(UI.formatAmount(total)).color(Color.lightGray).padRight(3);
+                if(++i % rowSet == 0){
                     t.row();
                 }
             }
@@ -889,7 +921,8 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
         if(t.getChildren().any()){
             c.defaults().left();
-            c.add(name).row();
+            c.add(name + "  (" + viewInterval(viewInt) + ")").color(Pal.accent).center().row();
+            c.image().color(Pal.accent).fillX().row();
             builder.get(c);
             c.add(t).padLeft(10f).row();
         }
@@ -916,7 +949,8 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
             }
 
             if(sector.save != null && sector.info.resources.any()){
-                c.add("@sectors.resources").left().row();
+                c.add("@sectors.resources").color(Pal.accent).center().row();
+                c.image().color(Pal.accent).fillX().row();
                 c.table(t -> {
                     for(UnlockableContent uc : sector.info.resources){
                         if(uc == null) continue;
@@ -951,7 +985,8 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
             //stored resources
             if(sector.hasBase() && items.total > 0){
 
-                c.add("@sectors.stored").left().row();
+                c.add("@sectors.stored").color(Pal.accent).center().row();
+                c.image().color(Pal.accent).fillX().row();
                 c.table(t -> {
                     t.left();
 
@@ -961,7 +996,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
                         for(ItemStack stack : items){
                             res.image(stack.item.uiIcon).padRight(3);
                             res.add(UI.formatAmount(Math.max(stack.amount, 0))).color(Color.lightGray);
-                            if(++i % 4 == 0){
+                            if(++i % settings.getInt("itemSelectionWidth") == 0){
                                 res.row();
                             }
                         }
@@ -1041,17 +1076,17 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
                 title.add().growX();
 
                 title.button(Icon.pencilSmall, Styles.clearNonei, () -> {
-                   ui.showTextInput("@sectors.rename", "@name", 20, sector.name(), v -> {
-                       sector.setName(v);
-                       updateSelected();
-                       rebuildList();
-                   });
+                    ui.showTextInput("@sectors.rename", "@name", 20, sector.name(), v -> {
+                        sector.setName(v);
+                        updateSelected();
+                        rebuildList();
+                    });
                 }).size(40f).padLeft(4);
             }
 
             var icon = sector.info.contentIcon != null ?
-                new TextureRegionDrawable(sector.info.contentIcon.uiIcon) :
-                Icon.icons.get(sector.info.icon + "Small");
+            new TextureRegionDrawable(sector.info.contentIcon.uiIcon) :
+            Icon.icons.get(sector.info.icon + "Small");
 
             title.button(icon == null ? Icon.noneSmall : icon, Styles.clearNonei, iconSmall, () -> {
                 new Dialog(""){{
@@ -1080,10 +1115,11 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
                             int cols = (int)Math.min(20, Core.graphics.getWidth() / Scl.scl(52f));
 
                             int i = 1;
-                            for(var key : defaultIcons){
-                                var value = Icon.icons.get(key);
+                            for(var entry : Icon.icons.entries()){
+                                if(entry.key.endsWith("Small") || entry.key.contains("none")) continue;
+                                String key = entry.key;
 
-                                t.button(value, Styles.squareTogglei, () -> {
+                                t.button(entry.value, Styles.squareTogglei, () -> {
                                     sector.info.icon = key;
                                     sector.info.contentIcon = null;
                                     refresh.run();
@@ -1165,11 +1201,11 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
         if((sector.hasBase() && mode == look) || canSelect(sector) || (sector.preset != null && sector.preset.alwaysUnlocked) || debugSelect){
             stable.button(
-                mode == select ? "@sectors.select" :
-                sector.isBeingPlayed() ? "@sectors.resume" :
-                sector.hasBase() ? "@sectors.go" :
-                locked ? "@locked" : "@sectors.launch",
-                locked ? Icon.lock : Icon.play, this::playSelected).growX().height(54f).minWidth(170f).padTop(4).disabled(locked);
+            mode == select ? "@sectors.select" :
+            sector.isBeingPlayed() ? "@sectors.resume" :
+            sector.hasBase() ? "@sectors.go" :
+            locked ? "@locked" : "@sectors.launch",
+            locked ? Icon.lock : Icon.play, this::playSelected).growX().height(54f).minWidth(170f).padTop(4).disabled(locked);
         }
 
         stable.pack();
@@ -1198,7 +1234,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
             if(!planet.allowWaveSimulation && !debugSelect && planet.allowWaveSimulation == sector.planet.allowWaveSimulation){
                 //if there are two or more attacked sectors... something went wrong, don't show the dialog to prevent softlock
                 Sector attacked = planet.sectors.find(s -> s.isAttacked() && s != sector);
-                if(attacked != null &&  planet.sectors.count(s -> s.isAttacked()) < 2){
+                if(attacked != null && planet.sectors.count(s -> s.isAttacked()) < 2 && !settings.getBool("forceIgnoreAttack")){
                     BaseDialog dialog = new BaseDialog("@sector.noswitch.title");
                     dialog.cont.add(bundle.format("sector.noswitch", attacked.name(), attacked.planet.localizedName)).width(400f).labelAlign(Align.center).center().wrap();
                     dialog.addCloseButton();
@@ -1211,6 +1247,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
                     return;
                 }
+                if(attacked != sector && settings.getBool("forceIgnoreAttack")) ui.showInfo("[red]警告：你的一个区块正在遭受攻击。[white]\n但你使用了学术端的作弊功能来强行切换区块，这可能导致未知问题！");
             }
         }
 
@@ -1293,6 +1330,13 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
         if(shouldHide) hide();
     }
 
+    private String viewInterval(int viewInt){
+        if(viewInt == 60) return "每分";
+        else if(viewInt == 120) return "每周期";
+        else if(viewInt == 1) return "每秒";
+        else return "每" + viewInt + "秒";
+    }
+
     public enum Mode{
         /** Look around for existing sectors. Can only deploy. */
         look,
diff --git a/core/src/mindustry/ui/dialogs/SchematicsDialog.java b/core/src/mindustry/ui/dialogs/SchematicsDialog.java
index 51b4e294ec2ec99bdd92fe4d1f2f4862edc9e931..1fc427b6fd4f3a189e11e426d86ed778273321a2 100644
--- a/core/src/mindustry/ui/dialogs/SchematicsDialog.java
+++ b/core/src/mindustry/ui/dialogs/SchematicsDialog.java
@@ -15,6 +15,14 @@ import arc.scene.ui.layout.*;
 import arc.scene.utils.*;
 import arc.struct.*;
 import arc.util.*;
+import mindustry.Vars;
+import mindustry.arcModule.ARCVars;
+import mindustry.arcModule.RFuncs;
+import mindustry.arcModule.toolpack.picToMindustry;
+import mindustry.arcModule.ui.dialogs.MessageDialog;
+import mindustry.content.Blocks;
+import mindustry.content.Planets;
+import mindustry.content.UnitTypes;
 import mindustry.ctype.*;
 import mindustry.game.*;
 import mindustry.gen.*;
@@ -22,10 +30,16 @@ import mindustry.graphics.*;
 import mindustry.input.*;
 import mindustry.type.*;
 import mindustry.ui.*;
+import mindustry.world.Block;
+import mindustry.world.blocks.production.GenericCrafter;
+import mindustry.world.meta.StatUnit;
 
 import java.util.regex.*;
 
 import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.arcModule.RFuncs.getPrefix;
+import static mindustry.content.Items.*;
 
 public class SchematicsDialog extends BaseDialog{
     private static final float tagh = 42f;
@@ -37,9 +51,37 @@ public class SchematicsDialog extends BaseDialog{
     private Pattern ignoreSymbols = Pattern.compile("[`~!@#$%^&*()\\-_=+{}|;:'\",<.>/?]");
     private Seq<String> tags, selectedTags = new Seq<>();
     private boolean checkedTags;
+    private String blueprintlink = "https://docs.qq.com/sheet/DVHNoS3lIcm1NbFFS";
+
+    private String surpuloTags = UnitTypes.gamma.emoji(), erekirTags = UnitTypes.emanate.emoji();
+    private  Seq<String> planetTags = new Seq<String>().add(surpuloTags,erekirTags);
+    public static final String ShareType = "[blue]<Schem>";
+
+    private boolean clipbroad = true;
+    private boolean fromShare = false;
 
     public SchematicsDialog(){
         super("@schematics");
+
+        Vars.netClient.addPacketHandler("arcNetSchematic", url -> Http.get(url, r -> readShare(r.getResultAsString().replace(" ", "+"), null)));
+
+        Events.on(EventType.WorldLoadEvent.class, event -> {
+            if(state.rules.env == Planets.serpulo.defaultEnv){
+                if (state.rules.hiddenBuildItems.equals(Planets.erekir.hiddenItems)){
+                    if (selectedTags.contains(erekirTags)) selectedTags.remove(erekirTags);
+                    if (!selectedTags.contains(surpuloTags)) selectedTags.add(surpuloTags);
+                }else{
+                    if (selectedTags.contains(erekirTags)) selectedTags.remove(erekirTags);
+                    if (selectedTags.contains(surpuloTags)) selectedTags.remove(surpuloTags);
+                }
+
+            }
+            else if(state.rules.env == Planets.erekir.defaultEnv){
+                if (selectedTags.contains(surpuloTags)) selectedTags.remove(surpuloTags);
+                if (!selectedTags.contains(erekirTags)) selectedTags.add(erekirTags);
+            }
+        });
+
         Core.assets.load("sprites/schematic-background.png", Texture.class).loaded = t -> t.setWrap(TextureWrap.repeat);
 
         tags = Core.settings.getJson("schematic-tags", Seq.class, String.class, Seq::new);
@@ -47,6 +89,14 @@ public class SchematicsDialog extends BaseDialog{
         shouldPause = true;
         addCloseButton();
         buttons.button("@schematic.import", Icon.download, this::showImport);
+        if (mobile) buttons.row();
+        buttons.button("[cyan]蓝图档案馆", Icon.link, () -> {
+            if(!Core.app.openURI(blueprintlink)){
+                ui.showErrorMessage("@linkfail");
+                Core.app.setClipboardText(blueprintlink);
+            }
+        });
+        buttons.button("[violet]转换器[white] " + Blocks.canvas.emoji() + Blocks.logicDisplay.emoji() + Blocks.sorter.emoji(), Icon.image, picToMindustry::show);
         makeButtonOverlay();
         shown(this::setup);
         onResize(this::setup);
@@ -105,6 +155,48 @@ public class SchematicsDialog extends BaseDialog{
 
         cont.row();
 
+        cont.table(in -> {
+            in.left();
+            in.add("科技树：").padRight(4);
+
+            //tags (no scroll pane visible)
+            in.pane(Styles.noBarPane, t -> {
+                rebuildTags = () -> {
+                    t.clearChildren();
+                    t.left();
+
+                    t.defaults().pad(2).height(tagh);
+                    for(var tag : planetTags){
+                        t.button(tag, Styles.togglet, () -> {
+                            if(selectedTags.contains(tag)){
+                                selectedTags.remove(tag);
+                            }else{
+                                selectedTags.add(tag);
+                            }
+                            rebuildPane.run();
+                        }).checked(selectedTags.contains(tag)).with(c -> c.getLabel().setWrap(false));
+                    }
+                };
+                rebuildTags.run();
+            }).fillX().height(tagh).scrollY(false);
+
+            in.button(Icon.refreshSmall, this::syncPlanetTags).size(tagh).pad(2).tooltip("刷新");
+            in.add("辅助筛选：").padLeft(20f).padRight(4);
+            in.button(copper.emoji(), Styles.togglet, () -> {
+                        Core.settings.put("arcSchematicCanBuild", !Core.settings.getBool("arcSchematicCanBuild"));
+                        rebuildPane.run();
+                    }).size(tagh).pad(2).tooltip("可建造(核心有此类资源+地图未禁用)").checked(t->Core.settings.getBool("arcSchematicCanBuild"));
+            if (Core.settings.getBool("autoSelSchematic")) {
+                in.add("蓝图包含：").padLeft(20f).padRight(4);
+                in.button(control.input.block == null ? "[red]\uE815" : control.input.block.emoji(), Styles.togglet, () -> {
+                    control.input.block = null;
+                    rebuildPane.run();
+                }).size(tagh).pad(2).tooltip("蓝图需包含此建筑").checked(t -> control.input.block != null);
+            }
+        }).height(tagh).fillX();
+
+        cont.row();
+
         cont.pane(t -> {
             t.top();
 
@@ -133,6 +225,9 @@ public class SchematicsDialog extends BaseDialog{
                     if(selectedTags.any() && !s.labels.containsAll(selectedTags)) continue;
                     //make sure search fits
                     if(!search.isEmpty() && !ignoreSymbols.matcher(s.name().toLowerCase()).replaceAll("").contains(searchString)) continue;
+
+                    if(Core.settings.getBool("autoSelSchematic") && control.input.block!=null && !s.containsBlock(control.input.block)) continue;
+                    if (Core.settings.getBool("arcSchematicCanBuild") && !arcSchematicCanBuild(s)) continue;
                     if(firstSchematic == null) firstSchematic = s;
 
                     Button[] sel = {null};
@@ -205,6 +300,10 @@ public class SchematicsDialog extends BaseDialog{
 
             rebuildPane.run();
         }).grow().scrollX(false);
+
+        if(Core.settings.getBool("autoSelSchematic") && control.input.block!=null){
+            arcui.arcInfo("[orange]蓝图筛选模式[white]:蓝图必须包含 "+control.input.block.emoji(),5f);
+        }
     }
 
     public void showInfo(Schematic schematic){
@@ -275,23 +374,136 @@ public class SchematicsDialog extends BaseDialog{
                     t.row();
                     dialog.hide();
                 }
-                t.button("@schematic.copy", Icon.copy, style, () -> {
+                t.button("@schematic.exportfile", Icon.export, style, () -> {
                     dialog.hide();
-                    ui.showInfoFade("@copied");
-                    Core.app.setClipboardText(schematics.writeBase64(s));
+                    platform.export(s.name(), schematicExtension, file -> Schematics.write(s, file));
                 }).marginLeft(12f);
                 t.row();
-                t.button("@schematic.exportfile", Icon.export, style, () -> {
+                t.button("[cyan]剪贴板[white]/[gray]消息框", Icon.copy, style, () -> {
+                    clipbroad = !clipbroad;
+                }).marginLeft(12f).update(button -> button.setText(clipbroad? "[cyan]剪贴板[white]/[gray]消息框" : "[gray]剪贴板[white]/[cyan]消息框"));
+                t.row();
+
+                t.button("蓝图代码", Icon.copy, style, () -> {
+                    dialog.hide();
+                    arcSendBlueprintMsg(schematics.writeBase64(s));
+                }).marginLeft(12f);
+                t.row();
+                t.button("记录蓝图[cyan][简]", Icon.export, style, () -> {
+                    dialog.hide();
+                    arcSendBlueprintMsg(arcSchematicsInfo(s,false));
+                }).marginLeft(12f);
+                t.row();
+                t.button("记录蓝图[cyan][详]", Icon.export, style, () -> {
+                    dialog.hide();
+                    arcSendBlueprintMsg(arcSchematicsInfo(s,true));
+                }).marginLeft(12f);
+                t.row();
+                t.button("分享蓝图", Icon.export, style, () -> {
+                    try {
+                        Http.HttpRequest req = Http.post("https://pastebin.com/api/api_post.php", "api_dev_key=sdBDjI5mWBnHl9vBEDMNiYQ3IZe0LFEk&api_option=paste&api_paste_expire_date=10M&api_paste_code=" + schematics.writeBase64(s));
+                        req.submit(r -> {
+                            String code = r.getResultAsString();
+                            if (clipbroad) arcSendClipBroadMsg(s, code);
+                            else RFuncs.sendChatMsg(getPrefix("blue", "Schem") + " " + code.substring(code.lastIndexOf('/') + 1));
+                        });
+                        req.error(e -> Core.app.post(() -> {ui.showException("分享失败", e);if (clipbroad) arcSendClipBroadMsg(s, "x");}));
+                    } catch (Exception e) {
+                        ui.showException("分享失败", e);
+                    }
                     dialog.hide();
-                    platform.export(s.name(), schematicExtension, file -> Schematics.write(s, file));
                 }).marginLeft(12f);
             });
         });
-
         dialog.addCloseButton();
         dialog.show();
     }
 
+    private void arcSendBlueprintMsg(String msg) {
+        if (clipbroad) Core.app.setClipboardText(msg);
+        else RFuncs.sendChatMsg(msg);
+        arcui.arcInfo(clipbroad ? "已保存至剪贴板" : "已发送到聊天框");
+    }
+
+    private void arcSendClipBroadMsg(Schematic schem, String msg){
+        StringBuilder s = new StringBuilder();
+        s.append("这是一条来自").append(ARCVars.arcVersionPrefix).append("的分享记录\n");
+        s.append("分享者：").append(player.name).append("\n");
+        s.append("蓝图代码链接：").append(msg).append("\n");
+        s.append("蓝图名：").append(schem.name()).append("\n");
+        s.append("蓝图造价：");
+        ItemSeq arr = schem.requirements();
+        for(ItemStack stack : arr){
+            s.append(stack.item.localizedName).append(stack.amount).append("|");
+        }
+        s.append("\n").append("电力：");
+        float cons = schem.powerConsumption() * 60, prod = schem.powerProduction() * 60;
+        if(!Mathf.zero(prod)){
+            s.append("+").append(Strings.autoFixed(prod, 2));
+            if(!Mathf.zero(cons)){
+                s.append("|");
+            }
+        }
+        if(!Mathf.zero(cons)){
+            s.append("-").append(Strings.autoFixed(cons, 2));
+        }
+        if (schematics.writeBase64(schem).length() > 3500) s.append("\n").append("蓝图代码过长，请点击链接查看");
+        else s.append("\n").append("蓝图代码：\n").append(schematics.writeBase64(schem));
+        Core.app.setClipboardText(Strings.stripColors(s.toString()));
+        arcui.arcInfo("已保存至剪贴板");
+    }
+
+    public boolean resolveSchematic(String msg, @Nullable Player sender) {
+        if ((!msg.contains(ShareType)) || (!MessageDialog.arcMsgType.schematic.show)) {
+            return false;
+        }
+        int start = msg.indexOf(' ', msg.indexOf(ShareType) + ShareType.length());
+        Http.get("https://pastebin.com/raw/" + msg.substring(start + 1), r -> readShare(r.getResultAsString().replace(" ", "+"), sender));
+        return true;
+    }
+
+    private void readShare(String base64, @Nullable Player sender) {
+        Core.app.post(() -> {
+            try {
+                Schematic s = Schematics.readBase64(base64);
+                s.removeSteamID();
+                s.tags.put("name", sender == null ? "来自服务器的蓝图" : "来自" + sender.plainName() + "的蓝图");
+                fromShare = true;
+                SchematicsDialog.this.showInfo(s);
+            } catch(Throwable e) {
+                ui.showException(e);
+            }
+        });
+    }
+
+    private String arcSchematicsInfo(Schematic schem, boolean description){
+        String builder = ARCVars.arcVersionPrefix;
+        builder+="标记了蓝图["+schem.name()+"]";
+        builder+="。属性："+schem.width+"x"+schem.height+"，"+schem.tiles.size+"个建筑。";
+        if(description){
+            builder+="耗材：";
+            ItemSeq arr = schem.requirements();
+            for(ItemStack s : arr){
+                builder+=s.item.emoji()+ s.amount+"|";
+            }
+
+            builder+="。电力：";
+            cont.row();
+            float cons = schem.powerConsumption() * 60, prod = schem.powerProduction() * 60;
+            if(!Mathf.zero(prod)){
+                builder+="+"+ Strings.autoFixed(prod, 2);
+                if(!Mathf.zero(cons)){
+                    builder+="|";
+                }
+            }
+            if(!Mathf.zero(cons)){
+                builder+="-"+ Strings.autoFixed(cons, 2);
+            }
+        }
+        return builder;
+    }
+
+
     public void showEdit(Schematic s){
         new BaseDialog("@schematic.edit"){{
             setFillParent(true);
@@ -464,9 +676,11 @@ public class SchematicsDialog extends BaseDialog{
 
                 for(var tag : tags){
 
-                    var next = new Table(n -> {
-                        n.table(Tex.pane, move -> {
-                            move.margin(2);
+                    var next = new Table(Tex.whiteui, n -> {
+                        n.setColor(Pal.gray);
+                        n.margin(5f);
+
+                        n.table(move -> {
 
                             //move up
                             move.button(Icon.upOpen, Styles.emptyi, () -> {
@@ -486,10 +700,9 @@ public class SchematicsDialog extends BaseDialog{
                                     rebuild[0].run();
                                 }
                             }).tooltip("@editor.movedown");
-                        }).fillY().margin(6f);
+                        }).fillY();
 
-                        n.table(Tex.whiteui, t -> {
-                            t.setColor(Pal.gray);
+                        n.table(t -> {
                             t.add(tag).left().row();
                             t.add(Core.bundle.format("schematic.tagged", schematics.all().count(s -> s.labels.contains(tag)))).left()
                             .update(b -> b.setColor(b.hasMouse() ? Pal.accent : Color.lightGray)).get().clicked(() -> {
@@ -498,9 +711,9 @@ public class SchematicsDialog extends BaseDialog{
                                 rebuildTags.run();
                                 rebuildPane.run();
                             });
-                        }).growX().fillY().margin(8f);
+                        }).growX().fillY();
 
-                        n.table(Tex.pane, b -> {
+                        n.table(b -> {
                             b.margin(2);
 
                             //rename tag
@@ -541,13 +754,13 @@ public class SchematicsDialog extends BaseDialog{
                                     rebuild[0].run();
                                 });
                             }).tooltip("@save.delete");
-                        }).fillY().margin(6f);
+                        }).fillY();
                     });
 
                     next.pack();
-                    float w = next.getPrefWidth() + Scl.scl(6f);
+                    float w = next.getWidth() + Scl.scl(6f);
 
-                    if(w + sum >= Core.graphics.getWidth() * (Core.graphics.isPortrait() ? 1f : 0.8f)){
+                    if(w*2f + sum >= Core.graphics.getWidth() * 0.8f){
                         p.add(current).row();
                         current = new Table();
                         current.left();
@@ -570,6 +783,11 @@ public class SchematicsDialog extends BaseDialog{
                     t.button("@schematic.texttag", Icon.add, () -> showNewTag(res -> rebuild[0].run())).wrapLabel(false).get().getLabelCell().padLeft(5);
                     t.button("@schematic.icontag", Icon.add, () -> showNewIconTag(res -> rebuild[0].run())).wrapLabel(false).get().getLabelCell().padLeft(5);
                 });
+                p.row();
+                p.table(t ->{
+                    t.left().defaults().fillX().height(tagh).pad(2);
+                    t.button("自动标签", Icon.add, () -> arcAutoTags(res -> rebuild[0].run())).wrapLabel(false).get().getLabelCell().padLeft(5);
+                });
 
             };
 
@@ -578,6 +796,135 @@ public class SchematicsDialog extends BaseDialog{
         dialog.show();
     }
 
+    void arcAutoTags(Cons<String> cons){
+        new Dialog(){{
+            closeOnBack();
+            setFillParent(true);
+
+            cont.pane(t -> {
+                resized(true, () -> {
+                    t.clearChildren();
+                    t.marginRight(19f);
+                    t.defaults().size(48f);
+
+                    int cols = (int)Math.min(20, Core.graphics.getWidth() / Scl.scl(52f));
+
+                    for(ContentType ctype : defaultContentIcons){
+                        t.row();
+                        t.image().colspan(cols).growX().width(Float.NEGATIVE_INFINITY).height(3f).color(Pal.accent);
+                        t.row();
+
+                        int i = 0;
+                        for(UnlockableContent u : content.getBy(ctype).<UnlockableContent>as()){
+                            if(!u.isHidden() && u.unlockedNow() && u.hasEmoji() && !tags.contains(u.emoji())){
+                                t.button(new TextureRegionDrawable(u.uiIcon), Styles.flati, iconMed, () -> {
+                                    String out = u.emoji() + "";
+
+                                    tags.add(out);
+                                    tagsChanged();
+
+                                    if(u instanceof Block block){
+                                        for(Schematic s : schematics.all()){
+                                            s.tiles.each(sBlock -> {
+                                                if(sBlock.block == block){
+                                                    addTag(s,out);
+                                                    cons.get(out);
+                                                    hide();
+                                                }
+                                            });
+                                        }
+                                    }
+                                    else if(u instanceof Item item){
+                                        Seq<Block> blocklist = new Seq<>();
+                                        for (Block factory : content.blocks()) {
+                                            if(factory instanceof GenericCrafter crafter){
+                                                if(crafter.outputItems == null) continue;
+                                                for(ItemStack stack:crafter.outputItems){
+                                                if (stack.item == item) blocklist.add(factory);
+                                                }
+                                            }
+                                        }
+                                        for(Schematic s : schematics.all()){
+                                            s.tiles.each(sBlock -> {
+                                                if(blocklist.contains(sBlock.block)){
+                                                    addTag(s,out);
+                                                    cons.get(out);
+                                                    hide();
+                                                }
+                                            });
+                                        }
+                                    }
+                                    else if(u instanceof Liquid liquid){
+                                        Seq<Block> blocklist = new Seq<>();
+                                        for (Block factory : content.blocks()) {
+                                            if(factory instanceof GenericCrafter crafter){
+                                                if(crafter.outputLiquids==null) continue;
+                                                for(LiquidStack stack: crafter.outputLiquids){
+                                                    if (stack.liquid == liquid) blocklist.add(factory);
+                                                }
+                                            }
+                                        }
+                                        for(Schematic s : schematics.all()){
+                                            s.tiles.each(sBlock -> {
+                                                if(blocklist.contains(sBlock.block)){
+                                                    addTag(s,out);
+                                                    cons.get(out);
+                                                    hide();
+                                                }
+                                            });
+                                        }
+                                    }
+
+
+                                    cons.get(out);
+
+                                    hide();
+                                });
+
+                                if(++i % cols == 0) t.row();
+                            }
+                        }
+                    }
+                });
+            });
+            buttons.button("@back", Icon.left, this::hide).size(210f, 64f);
+        }}.show();
+    }
+
+    void syncPlanetTags(){
+        arcui.arcInfo("标签自动分类中...请稍后");
+        for(Schematic s : schematics.all()){
+            Boolean surpulo = true;
+            Boolean erekir = true;
+            for (Item item:erekirOnlyItems){
+                if(s.requirements().has(item)) {
+                    surpulo = false;
+                    break;
+                }
+            }
+            for(Item item : serpuloItems.copy().removeAll(erekirItems::contains)){
+                if(s.requirements().has(item)) {
+                    erekir = false;
+                    break;
+                }
+            }
+
+            if(surpulo && !s.labels.contains(surpuloTags)) addTag(s,surpuloTags);
+            if(erekir && !s.labels.contains(erekirTags)) addTag(s,erekirTags);
+        }
+        arcui.arcInfo("标签分类完成");
+    }
+
+    boolean arcSchematicCanBuild(Schematic s){
+        for (ItemStack item : s.requirements()){
+            if (!ui.hudfrag.coreItems.hadItem(item.item)) return false;
+        }
+        for (Block block: state.rules.bannedBlocks){
+            if (s.containsBlock(block)) return false;
+        }
+        return true;
+    }
+
     void buildTags(Schematic schem, Table t){
         buildTags(schem, t, true);
     }
@@ -788,13 +1135,44 @@ public class SchematicsDialog extends BaseDialog{
                     }
                 });
             }
+            cont.row();
 
+            schem.calProduction();
+            cont.table(r -> {
+                int i = 0;
+                for(Item item : schem.items.keys()){
+                    r.image(item.uiIcon).left().size(iconMed);
+                    r.label(
+                            () -> (schem.items.get(item, 0) > 0 ? "+" : "") + Strings.autoFixed(schem.items.get(item, 0), 2) + StatUnit.perSecond.localized()
+                    ).padLeft(2).left().padRight(5).color(Color.lightGray);
+                    if(++i % 4 == 0){
+                        r.row();
+                    }
+                }
+                for (Liquid liquid : schem.liquids.keys()) {
+                    r.image(liquid.uiIcon).left().size(iconMed);
+                    r.label(
+                            () -> (schem.liquids.get(liquid, 0) > 0 ? "+" : "") + Strings.autoFixed(schem.liquids.get(liquid, 0), 2) + StatUnit.perSecond.localized()
+                    ).padLeft(2).left().padRight(5).color(Color.lightGray);
+                    if(++i % 4 == 0){
+                        r.row();
+                    }
+                }
+            });
             buttons.clearChildren();
             buttons.defaults().size(Core.graphics.isPortrait() ? 150f : 210f, 64f);
             buttons.button("@back", Icon.left, this::hide);
             buttons.button("@editor.export", Icon.upload, () -> showExport(schem));
             buttons.button("@edit", Icon.edit, () -> showEdit(schem));
-
+            if (fromShare) {
+                fromShare = false;
+                buttons.button("@save", Icon.save, () -> {
+                    schematics.add(schem);
+                    setup();
+                    ui.showInfoFade("@schematic.saved");
+                    checkTags(schem);
+                });
+            }
             show();
         }
     }
diff --git a/core/src/mindustry/ui/dialogs/SettingsMenuDialog.java b/core/src/mindustry/ui/dialogs/SettingsMenuDialog.java
index db57b3ecdb84a4a2a7417c4f68186997a138a5ee..f3b82a035e79e8e57699c6eb2c1c03c62935337a 100644
--- a/core/src/mindustry/ui/dialogs/SettingsMenuDialog.java
+++ b/core/src/mindustry/ui/dialogs/SettingsMenuDialog.java
@@ -46,6 +46,10 @@ public class SettingsMenuDialog extends BaseDialog{
     public SettingsMenuDialog(){
         super(bundle.get("settings", "Settings"));
         addCloseButton();
+        buttons.addChild(new Table(t->{
+            t.setFillParent(true);
+            t.right().button("?", () -> ui.showInfo("@settings.info")).size(60f, 64f);
+        }));
 
         cont.add(main = new SettingsTable());
         shouldPause = true;
diff --git a/core/src/mindustry/ui/fragments/ChatFragment.java b/core/src/mindustry/ui/fragments/ChatFragment.java
index 7a968f1c21275eb4a571350adfcf59df1fa37df9..03bbbbfca69229893fc097479f4078843ea0c56d 100644
--- a/core/src/mindustry/ui/fragments/ChatFragment.java
+++ b/core/src/mindustry/ui/fragments/ChatFragment.java
@@ -30,7 +30,7 @@ public class ChatFragment extends Table{
     private boolean shown = false;
     private TextField chatfield;
     private Label fieldlabel = new Label(">");
-    private ChatMode mode = ChatMode.normal;
+    public ChatMode mode = ChatMode.normal;
     private Font font;
     private GlyphLayout layout = new GlyphLayout();
     private float offsetx = Scl.scl(4), offsety = Scl.scl(4), fontoffsetx = Scl.scl(2), chatspace = Scl.scl(50);
@@ -163,7 +163,10 @@ public class ChatFragment extends Table{
         Draw.alpha(shadowColor.a * opacity);
 
         float theight = offsety + spacing + getMarginBottom() + scene.marginBottom;
-        for(int i = scrollPos; i < messages.size && i < messagesShown + scrollPos && (i < fadetime || shown); i++){
+        int messageCount = 0;
+        for(int i = scrollPos; i < messages.size && messageCount < messagesShown && (i < fadetime || shown); i++){
+            if(!chatValidType(messages.get(i))) continue;
+            messageCount += 1;
 
             layout.setText(font, messages.get(i), Color.white, textWidth, Align.bottomLeft, true);
             theight += layout.height + textspacing;
@@ -194,6 +197,17 @@ public class ChatFragment extends Table{
         }
     }
 
+    private boolean chatValidType(String msg){
+        int chatType = settings.getInt("chatValidType");
+        if(chatType == 0 && (msg.contains("[acid][公屏][white]") || msg.contains("[逻辑~"))) return false;
+        else if(chatType == 1 &&
+        (msg.contains("加入了服务器") || msg.contains("离开了服务器") || msg.contains("小贴士") || msg.contains("自动存档完成") ||
+        msg.contains("登录成功") || msg.contains("经验+") || msg.contains("[ARC")
+        || (msg.contains("[acid][公屏][white]")) || msg.contains("[逻辑~"))) return false;
+        else if(chatType == 2 && !(msg.contains("[acid][公屏][white]") || msg.contains("[逻辑~"))) return false;
+        return true;
+    }
+
     private void sendMessage(){
         String message = chatfield.getText().trim();
         clearChatInput();
@@ -216,6 +230,8 @@ public class ChatFragment extends Table{
             if(mobile){
                 TextInput input = new TextInput();
                 input.maxLength = maxTextLength;
+                //MDTX mobile chatField support (from ARC)
+                input.text = chatfield.getText() + " ";
                 input.accepted = text -> {
                     chatfield.setText(text);
                     sendMessage();
@@ -245,7 +261,12 @@ public class ChatFragment extends Table{
     }
 
     public void updateChat(){
-        chatfield.setText(mode.normalizedPrefix() + history.get(historyPos));
+        //MDTX: better prefix handle (from ARC)
+        if(history.get(historyPos).contains(mode.normalizedPrefix())){
+            chatfield.setText(history.get(historyPos));
+        }else{
+            chatfield.setText(mode.normalizedPrefix() + history.get(historyPos));
+        }
         updateCursor();
     }
 
@@ -290,7 +311,7 @@ public class ChatFragment extends Table{
         if(scrollPos > 0) scrollPos++;
     }
 
-    private enum ChatMode{
+    public enum ChatMode{
         normal(""),
         team("/t"),
         admin("/a", player::admin)
diff --git a/core/src/mindustry/ui/fragments/ConsoleFragment.java b/core/src/mindustry/ui/fragments/ConsoleFragment.java
index e74e6a12e3da57eb58598eb4e679a7990c109def..476b5ac3794d6eb1d9ae5a4392d886f206bff7d3 100644
--- a/core/src/mindustry/ui/fragments/ConsoleFragment.java
+++ b/core/src/mindustry/ui/fragments/ConsoleFragment.java
@@ -12,6 +12,7 @@ import arc.scene.ui.TextField.*;
 import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
+import mindustry.arcModule.ui.dialogs.MessageDialog;
 import mindustry.game.EventType.*;
 import mindustry.input.*;
 import mindustry.ui.*;
@@ -163,6 +164,7 @@ public class ConsoleFragment extends Table{
         clearChatInput();
 
         if(message.replace(" ", "").isEmpty()) return;
+        MessageDialog.addMsg(new MessageDialog.advanceMsg(MessageDialog.arcMsgType.console,message));
 
         //special case for 'clear' command
         if(message.equals("clear")){
diff --git a/core/src/mindustry/ui/fragments/HudFragment.java b/core/src/mindustry/ui/fragments/HudFragment.java
index 7965f8d000e5f2619e3fa568d62bf8b51798fbb7..6cf9afc111970d774993617b365994021648dd7e 100644
--- a/core/src/mindustry/ui/fragments/HudFragment.java
+++ b/core/src/mindustry/ui/fragments/HudFragment.java
@@ -14,7 +14,11 @@ import arc.scene.ui.ImageButton.*;
 import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
+import mindustry.Vars;
 import mindustry.annotations.Annotations.*;
+import mindustry.arcModule.ui.*;
+import mindustry.arcModule.ui.auxilliary.*;
+import mindustry.arcModule.ui.quickTool.QuickToolTable;
 import mindustry.content.*;
 import mindustry.core.GameState.*;
 import mindustry.core.*;
@@ -27,10 +31,13 @@ import mindustry.input.*;
 import mindustry.net.Packets.*;
 import mindustry.type.*;
 import mindustry.ui.*;
+import mindustry.ui.dialogs.BaseDialog;
 import mindustryX.features.*;
 
 import static mindustry.Vars.*;
+import static mindustry.arcModule.RFuncs.arcColorTime;
 import static mindustry.gen.Tex.*;
+import static mindustry.ui.Styles.*;
 
 public class HudFragment{
     private static final float dsize = 65f, pauseHeight = 36f;
@@ -39,7 +46,16 @@ public class HudFragment{
     public boolean shown = true;
 
     private ImageButton flip;
-    private CoreItemsDisplay coreItems = new CoreItemsDisplay();
+    private Slider minimapSlider;
+    public RCoreItemsDisplay coreItems = new RCoreItemsDisplay();
+    public OtherCoreItemDisplay otherCoreItemDisplay = new OtherCoreItemDisplay();
+
+    private AuxilliaryTable auxilliaryTable;
+    public QuickToolTable quickToolTable = new QuickToolTable();
+
+    private boolean hideObjectives = true;
+
+    private boolean editorMainShow = true;
 
     private String hudText = "";
     private boolean showHudText;
@@ -48,7 +64,10 @@ public class HudFragment{
     private Table lastUnlockLayout;
     private long lastToast;
 
+    private final Table arcStatus = new Table();
+
     public void build(Group parent){
+        auxilliaryTable = new AuxilliaryTable();
 
         //warn about guardian/boss waves
         Events.on(WaveEvent.class, e -> {
@@ -72,7 +91,11 @@ public class HudFragment{
         });
 
         Events.on(SectorCaptureEvent.class, e -> {
-            showToast(Core.bundle.format("sector.captured", e.sector.isBeingPlayed() ? "" : e.sector.name() + " "));
+            if(e.sector.isBeingPlayed()){
+                ui.announce("@sector.capture.current", 5f);
+            }else{
+                showToast(Core.bundle.format("sector.capture", e.sector.name()));
+            }
         });
 
         Events.on(SectorLoseEvent.class, e -> {
@@ -88,6 +111,15 @@ public class HudFragment{
             coreItems.clear();
         });
 
+        Events.on(WorldLoadEvent.class,e->{
+            auxilliaryTable.toggle();
+            hideObjectives = false;
+            rebuildArcStatus();
+            if(minimapSlider != null){
+                minimapSlider.setRange(0.1f, Math.min(world.width(), world.height()) / 16f / 2f);
+            }
+        });
+
         //paused table
         parent.fill(t -> {
             t.name = "paused";
@@ -111,14 +143,43 @@ public class HudFragment{
             //minimap
             t.add(new Minimap()).name("minimap");
             t.row();
+            if(mobile){
+                t.table(tt -> {
+                    tt.button(Icon.play, cleari, () -> {
+                        ui.minimapfrag.toggle();
+                    }).left();
+
+                    minimapSlider = tt.slider(1, 1, 0.1f, (n) -> {
+                        renderer.minimap.setZoom(n);
+                    }).fillX().get();
+                }).fillX().row();
+            }
+
             //position
-            t.label(() ->
-                (Core.settings.getBool("position") ? player.tileX() + "," + player.tileY() + "\n" : "") +
-                (Core.settings.getBool("mouseposition") ? "[lightgray]" + World.toTile(Core.input.mouseWorldX()) + "," + World.toTile(Core.input.mouseWorldY()) : ""))
-            .visible(() -> Core.settings.getBool("position") || Core.settings.getBool("mouseposition"))
-            .touchable(Touchable.disabled)
-            .style(Styles.outlineLabel)
-            .name("position");
+            t.table(tt-> {
+                tt.label(() -> player.unit().type.emoji() +
+                                (Core.settings.getBool("position") ? player.tileX() + "," + player.tileY() + "\n" : "") +
+                                (Core.settings.getBool("mouseposition") ? "[lightgray]" + "♐" + World.toTile(Core.input.mouseWorldX()) + "," + World.toTile(Core.input.mouseWorldY()) : ""))
+                        .visible(() -> Core.settings.getBool("position") || Core.settings.getBool("mouseposition"))
+                        .touchable(Touchable.disabled)
+                        .style(Styles.outlineLabel)
+                        .name("position");
+                    if(Core.settings.getBool("minimapTools")){
+                        tt.button(Iconc.cancel + "",cleart,()->Core.settings.put("minimap",!Core.settings.getBool("minimap"))).size(30,30).tooltip("关闭小地图(再次打开去设置里开)");
+                        tt.button("+",cleart,()->Core.settings.put("minimapSize",(int)(Core.settings.getInt("minimapSize") * 1.2))).size(30,30).tooltip("增加小地图大小");
+                        tt.button("-",cleart,()->Core.settings.put("minimapSize",(int)(Core.settings.getInt("minimapSize") / 1.2))).size(30,30).tooltip("减少小地图大小");
+                        tt.button(Iconc.players + "",cleart,()-> renderer.minimap.forceShowPlayer = !renderer.minimap.forceShowPlayer).size(30,30).tooltip("开关玩家名显示");
+                        tt.button(Iconc.alphaaaa + "",cleart,() -> renderer.minimap.unitDetailsIcon = !renderer.minimap.unitDetailsIcon).size(30,30).tooltip("单位图标细节");
+                    }
+                    tt.button("♐",cleart,()-> MarkerType.lockOnLastMark()).size(30,30).tooltip("锁定上个标记点");
+            }).style(Styles.outlineLabel);
+            if(Core.settings.getInt("AuxiliaryTable") == 3){
+                t.row();
+                t.table(infoWave -> {
+                    infoWave.left().top();
+                    infoWave.add(auxilliaryTable);
+                }).left().top();
+            }
             t.top().right();
         });
 
@@ -214,6 +275,10 @@ public class HudFragment{
             wavesMain.top().left().name = "waves";
 
             wavesMain.table(s -> {
+                if(Core.settings.getBool("arcSpecificTable")){
+                    s.add(makeStatusTableArc()).grow().name("status");
+                    return;
+                }
                 //wave info button with text
                 s.add(makeStatusTable()).grow().name("status");
 
@@ -233,14 +298,33 @@ public class HudFragment{
                     }else{
                         logic.skipWave();
                     }
-                }).growY().fillX().right().width(40f).disabled(b -> !canSkipWave()).name("skip").get().toBack();
-            }).width(dsize * 5 + 4f).name("statustable");
+                }).growY().fillX().right().width(40f).disabled(b -> !Core.settings.getBool("overrideSkipWave") && !canSkipWave()).name("skip");
+                // Power bar display
+                if (Core.settings.getBool("powerStatistic")){
+                    s.row();
+                    s.add(PowerInfo.getBars()).growX().colspan(s.getColumns());
+                }
+
+            }).width(dsize * 5 + 4f).name("statustable").left();
 
             wavesMain.row();
 
+            if(Core.settings.getInt("AuxiliaryTable") == 2){
+                wavesMain.table(t->{
+                    t.name = "AuxiliaryTable";
+                    t.left().top().add(auxilliaryTable);
+                }).left();
+                wavesMain.row();
+            }
+
             addInfoTable(wavesMain.table().width(dsize * 5f + 4f).left().get());
 
             editorMain.name = "editor";
+            editorMain.button("[green]队", () -> {
+                editorMainShow = !editorMainShow;
+            }).left().width(40f).padBottom(40f);
+            editorMain.row();
+
             editorMain.table(Tex.buttonEdge4, t -> {
                 //t.margin(0f);
                 t.name = "teams";
@@ -250,7 +334,7 @@ public class HudFragment{
                     teams.left();
                     int i = 0;
                     for(Team team : Team.baseTeams){
-                        ImageButton button = teams.button(Tex.whiteui, Styles.clearNoneTogglei, 40f, () -> Call.setPlayerTeamEditor(player, team))
+                        ImageButton button = teams.button(Tex.whiteui, Styles.clearTogglei, 40f, () -> Call.setPlayerTeamEditor(player, team))
                         .size(50f).margin(6f).get();
                         button.getImageCell().grow();
                         button.getStyle().imageUpColor = team.color;
@@ -260,9 +344,48 @@ public class HudFragment{
                             teams.row();
                         }
                     }
+                    teams.button("更多", () -> {
+                        BaseDialog dialog = new BaseDialog("队伍选择器");
+                        Table selectTeam = new Table().top();
+
+                        dialog.cont.pane(td->{
+                                int j = 0;
+                                for(Team team : Team.all){
+                                    ImageButton button = new ImageButton(Tex.whiteui, Styles.clearTogglei);
+                                    button.getStyle().imageUpColor = team.color;
+                                    button.margin(10f);
+                                    button.resizeImage(40f);
+                                    button.clicked(() -> {Call.setPlayerTeamEditor(player, team);dialog.hide();});
+                                    button.update(() -> button.setChecked(player.team() == team));
+                                    td.add(button);
+                                    j++;
+                                    if(j==5) {td.row();td.add("队伍："+j+"~"+(j+10));}
+                                    else if((j-5)%10==0) {td.row();td.add("队伍："+j+"~"+(j+10));}
+                                }
+                            }
+                        );
+
+                        dialog.add(selectTeam).center();
+                        dialog.row();
+
+                        dialog.addCloseButton();
+
+                        dialog.show();
+                    }).center().row();
                 }).left();
+
+                t.visible(() -> editorMainShow);
             }).width(dsize * 5 + 4f);
-            editorMain.visible(() -> shown && state.isEditor());
+            editorMain.visible(() -> shown && (state.isEditor() || Core.settings.getBool("selectTeam")) && !Core.settings.getBool("showAdvanceToolTable"));
+
+            //map info/nextwave display
+            if(Core.settings.getInt("AuxiliaryTable") == 1){
+                cont.table(infoWave -> {
+                    infoWave.name = "map/wave";
+                    infoWave.left().top();
+                    infoWave.add(auxilliaryTable);
+                }).left().top();
+            }
 
             //fps display
             cont.table(info -> {
@@ -275,6 +398,8 @@ public class HudFragment{
                 IntFormat mem = new IntFormat("memory");
                 IntFormat memnative = new IntFormat("memory2");
 
+                info.add("MDTX~"+ Version.mdtXBuild).color(Pal.accent).left();
+                info.row();
                 info.label(() -> fps.get(Core.graphics.getFramesPerSecond())).left().style(Styles.outlineLabel).name("fps");
                 info.row();
                 info.label(() -> Strings.format("LG/DW/UI(ms) @/@/@", Time.nanosToMillis(DebugUtil.logicTime), Time.nanosToMillis(DebugUtil.rendererTime), Time.nanosToMillis(DebugUtil.uiTime)))
@@ -282,6 +407,10 @@ public class HudFragment{
                 info.row();
                 info.label(() -> "Draws: " + DebugUtil.lastDrawRequests).left().style(Styles.outlineLabel).name("draw");
                 info.row();
+                if (!android){
+                    info.label(() -> "缩放: " + String.format("%.2f", renderer.getScale())).left().style(Styles.outlineLabel);
+                    info.row();
+                }
 
                 if(android){
                     info.label(() -> memnative.get((int)(Core.app.getJavaHeap() / 1024 / 1024), (int)(Core.app.getNativeHeap() / 1024 / 1024))).left().style(Styles.outlineLabel).name("memory2");
@@ -312,7 +441,7 @@ public class HudFragment{
 
             t.table(c -> {
                 //core items
-                c.top().collapser(coreItems, () -> Core.settings.getBool("coreitems") && !mobile && shown).fillX().row();
+                c.top().collapser(coreItems, () -> Core.settings.getInt("arccoreitems")>0  && shown).fillX().row();
 
                 float notifDuration = 240f;
                 float[] coreAttackTime = {0};
@@ -360,7 +489,7 @@ public class HudFragment{
                 }
                 return max == 0f ? 0f : val / max;
             }).blink(Color.white).outline(new Color(0, 0, 0, 0.6f), 7f)).grow())
-            .fillX().width(320f).height(60f).name("boss").visible(() -> state.rules.waves && state.boss() != null && !(mobile && Core.graphics.isPortrait())).padTop(7).row();
+            .fillX().width(320f).height(60f).name("boss").visible(() -> Core.settings.getBool("override_boss_shown") && state.rules.waves && state.boss() != null && !(mobile && Core.graphics.isPortrait())).padTop(7).row();
 
             t.table(Styles.black3, p -> p.margin(4).label(() -> hudText).style(Styles.outlineLabel)).touchable(Touchable.disabled).with(p -> p.visible(() -> {
                 p.color.a = Mathf.lerpDelta(p.color.a, Mathf.num(showHudText), 0.2f);
@@ -373,6 +502,17 @@ public class HudFragment{
             }));
         });
 
+        parent.fill(t -> {
+            t.name = "otherCore";
+            t.left().add(otherCoreItemDisplay);
+            t.visible(() -> Core.settings.getBool("showOtherTeamResource") && shown);
+        });
+
+        parent.fill(t -> {
+            t.right().add(quickToolTable);
+            t.visible(() -> Core.settings.getBool("showQuickToolTable") && shown);
+        });
+
         //spawner warning
         parent.fill(t -> {
             t.name = "nearpoint";
@@ -380,7 +520,7 @@ public class HudFragment{
             t.table(Styles.black6, c -> c.add("@nearpoint")
             .update(l -> l.setColor(Tmp.c1.set(Color.white).lerp(Color.scarlet, Mathf.absin(Time.time, 10f, 1f))))
             .labelAlign(Align.center, Align.center))
-            .margin(6).update(u -> u.color.a = Mathf.lerpDelta(u.color.a, Mathf.num(spawner.playerNear()), 0.1f)).get().color.a = 0f;
+            .margin(6).update(u -> u.color.a = Mathf.lerpDelta(u.color.a, Mathf.num(spawner.playerNear() && player.unit().hittable()), 0.1f)).get().color.a = 0f;
         });
 
         //'saving' indicator
@@ -430,7 +570,7 @@ public class HudFragment{
 
     @Remote(targets = Loc.both, forward = true, called = Loc.both)
     public static void setPlayerTeamEditor(Player player, Team team){
-        if(state.isEditor() && player != null){
+        if((state.isEditor() || Core.settings.getBool("selectTeam")) && player != null){
             player.team(team);
         }
     }
@@ -887,6 +1027,143 @@ public class HudFragment{
         return table;
     }
 
+
+    private Table makeStatusTableArc() {
+        Table table = new Table(buttonEdge4);
+
+        table.name = "waves";
+
+        table.marginTop(0).marginBottom(4).marginLeft(4);
+
+        table.table(t -> {
+            t.margin(0);
+            t.clicked(() -> {
+                if (!player.dead() && mobile) {
+                    Call.unitClear(player);
+                    control.input.recentRespawnTimer = 1f;
+                    control.input.controlledType = null;
+                }
+            });
+            t.image(() -> player.icon()).size(iconMed);
+            t.row();
+            t.add(new Bar(
+                    () -> {
+                        if (player.unit().shield > 0) {
+                            return UI.formatAmount((long) player.unit().health) + "[gray]+[white]" + UI.formatAmount((long) player.unit().shield);
+                        } else {
+                            return UI.formatAmount((long) player.unit().health);
+                        }
+                    },
+                    () -> Pal.health,
+                    () -> Math.min(player.unit().health / player.unit().maxHealth, 1))).height(18).growX();
+            t.row();
+            t.add(new Bar(
+                    () -> {
+                        if (state.rules.unitAmmo)
+                            return player.unit().type.ammoType.icon() + (int) player.unit().ammo + "/" + player.unit().type.ammoCapacity;
+                        else return player.unit().type.ammoType.icon();
+                    },
+                    () -> player.unit().type.ammoType.barColor(),
+                    () -> {
+                        if (state.rules.unitAmmo) return player.unit().ammo / player.unit().type.ammoCapacity;
+                        else return 1;
+                    })).height(18).growX();
+            t.row();
+
+        }).size(110, 80).padRight(4);
+
+        rebuildArcStatus();
+        table.add(arcStatus).growX().pad(4f);
+
+        // Power bar display
+        if (Core.settings.getBool("powerStatistic")) {
+            table.row();
+            table.add(PowerInfo.getBars()).growX().colspan(table.getColumns());
+        }
+        return table;
+    }
+
+    private void rebuildArcStatus() {
+        arcStatus.clear();
+
+        boolean showSkipWave = canSkipWave();
+
+        arcStatus.clicked(() -> {
+            hideObjectives = !hideObjectives;
+            rebuildArcStatus();
+        });
+
+        if (!getStatusText().isEmpty()) {
+            arcStatus.labelWrap(() -> hideObjectives && getStatusText().length() > 20 ? getStatusText().substring(0, 20) : getStatusText()).width(showSkipWave ? 150f : 190f);
+        } else {
+            arcStatus.table(tt->{
+                tt.update(() -> {
+                    if (!getStatusText().isEmpty()) rebuildArcStatus();
+                });
+                tt.add(new Bar(
+                        this::calWaveShower,
+                        () -> Color.valueOf("ccffcc"),
+                        () -> {
+                            if (CalWinWave() >= 1 && CalWinWave() >= state.wave)
+                                return state.wave / (float) CalWinWave();
+                            else return 1f;
+                        })).height(18).growX().row();
+                tt.add(new Bar(
+                        () -> arcColorTime(state.rules.waveTimer? (int)state.wavetime : (int) state.tick),
+                        () -> Color.valueOf("F5DEB3"),
+                        () -> state.wavetime / state.rules.waveSpacing)).height(18).growX().row();
+                tt.add(new Bar(
+                        () -> {
+                            if (Vars.spawner.countSpawns() <= 1 || state.rules.mode() == Gamemode.pvp) {
+                                return "[orange]" + state.enemies + "[gray](+" + calWaveEnemy(state.wave - 1) + ")";
+                            } else if (calWaveEnemy(state.wave - 1) > 0) {
+                                return "[orange]" + state.enemies + "[gray](+" + calWaveEnemy(state.wave - 1) + "×" + Vars.spawner.countSpawns() + ")";
+                            } else {
+                                return "[orange]" + state.enemies + "[gray](+0)";
+                            }
+                        },
+                        () -> Color.valueOf("F4A460"),
+                        () -> state.enemies / ((float) calWaveEnemy(state.wave - 2) * Vars.spawner.countSpawns()))).height(18).growX();
+            }).width(showSkipWave? 150f : 190f);
+        }
+        arcStatus.update(() -> {
+            if (showSkipWave !=  canSkipWave()) rebuildArcStatus();
+        });
+
+        if (canSkipWave()) {
+            arcStatus.button(Icon.play, clearNonei, 30f, () -> {
+                if (net.client() && player.admin) {
+                    Call.adminRequest(player, AdminAction.wave, null);
+                } else {
+                    logic.skipWave();
+                }
+            }).growY().fillX().right().width(40f);
+        }
+    }
+
+    public String getStatusText() {
+        StringBuilder objBuilder = new StringBuilder();
+
+        if (state.rules.objectives.any()) {
+            boolean first = true;
+            for (var obj : state.rules.objectives) {
+                if (!obj.qualified()) continue;
+
+                String text = obj.text();
+                if (text != null) {
+                    if (!first) objBuilder.append('\n');
+                    objBuilder.append(text);
+
+                    first = false;
+                }
+            }
+        }
+        if (objBuilder.length() == 0 && state.rules.mission != null)
+            objBuilder.append(state.rules.mission);
+
+        return objBuilder.toString();
+    }
+
     private void addInfoTable(Table table){
         table.name = "infotable";
         table.left();
@@ -931,7 +1208,51 @@ public class HudFragment{
     }
 
     private boolean canSkipWave(){
-        return state.rules.waves && state.rules.waveSending && ((net.server() || player.admin) || !net.active()) && state.enemies == 0 && !spawner.isSpawning();
+        return Core.settings.getBool("overrideSkipWave") || state.rules.waves && state.rules.waveSending && ((net.server() || player.admin) || !net.active()) && state.enemies == 0 && !spawner.isSpawning();
+    }
+
+    private String calWaveShower(){
+        StringBuilder builder = new StringBuilder();
+
+
+        if(!state.rules.waves && state.rules.attackMode){
+            int sum = Math.max(state.teams.present.sum(t -> t.team != player.team() ? t.cores.size : 0), 1);
+            builder.append("敌人核心：[orange]").append(sum);
+            return builder.toString();
+        }
+
+        if(!state.rules.waves && state.isCampaign()){
+            builder.append("[lightgray]").append(Core.bundle.get("sector.curcapture"));
+        }
+
+        if(!state.rules.waves){
+            return builder.toString();
+        }
+
+        if(CalWinWave() > 1 && CalWinWave() >= state.wave){
+            builder.append("[orange]").append(state.wave).append("[white]/[yellow]").append(CalWinWave());
+        }else{
+            builder.append("波次：[orange]").append(state.wave);
+        }
+        return builder.toString();
+    }
+
+    private int calWaveEnemy(int wave){
+        int waveEnemy = 0;
+        for(SpawnGroup group : state.rules.spawns){
+            waveEnemy += group.getSpawned(Math.max(0, wave));
+        }
+        return waveEnemy;
+    }
+
+    private int CalWinWave(){
+        if (state.rules.winWave >= 1) return state.rules.winWave;
+        int maxwave = 0;
+        for(SpawnGroup group : state.rules.spawns){
+            maxwave = Math.max(maxwave ,group.end);
+        }
+        if (maxwave > 10000) return 0;
+        return maxwave + 1;
     }
 
 }
diff --git a/core/src/mindustry/ui/fragments/MenuFragment.java b/core/src/mindustry/ui/fragments/MenuFragment.java
index cdf4295a544656573aea87416e8957b2c338e239..4a2cb7f2e86d8e968b6f648e78f612673a7a64c5 100644
--- a/core/src/mindustry/ui/fragments/MenuFragment.java
+++ b/core/src/mindustry/ui/fragments/MenuFragment.java
@@ -1,6 +1,7 @@
 package mindustry.ui.fragments;
 
 import arc.*;
+import arc.files.*;
 import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
@@ -10,7 +11,6 @@ import arc.scene.event.*;
 import arc.scene.style.*;
 import arc.scene.ui.*;
 import arc.scene.ui.ImageButton.*;
-import arc.scene.ui.TextButton.*;
 import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
@@ -18,12 +18,15 @@ import mindustry.core.*;
 import mindustry.game.EventType.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
+import mindustry.service.*;
 import mindustry.ui.*;
 import mindustryX.features.*;
 import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
 import static mindustry.gen.Tex.*;
+import static mindustry.ui.Styles.cleart;
 
 public class MenuFragment{
     private Table container, submenu;
@@ -33,8 +36,17 @@ public class MenuFragment{
 
     MenuFloatLabel floatLabel;
 
+    Fi arcBackground;
+    String arcBackgroundPath = Core.settings.getString("arcBackgroundPath");
+    Seq<Fi> arcBGList;
+
+    Image img = new Image();
+
+    int arcBackgroundIndex = 0;
+
     public void build(Group parent){
         renderer = new MenuRenderer();
+        initAchievement();
 
         Group group = new WidgetGroup();
         group.setFillParent(true);
@@ -44,7 +56,18 @@ public class MenuFragment{
         parent.addChild(floatLabel = new MenuFloatLabel());
         parent = group;
 
-        parent.fill((x, y, w, h) -> renderer.render());
+        if(arcBackgroundPath != null && Core.files.absolute(arcBackgroundPath).exists() && Core.files.absolute(arcBackgroundPath).list().length >= 1){
+            arcBackgroundIndex = (int)(Math.random() * Core.files.absolute(arcBackgroundPath).list().length);
+            nextBackGroundImg();
+            if(arcBGList.size == 0){
+                parent.fill((x, y, w, h) -> renderer.render());
+            }else{
+                group.addChild(img);
+                img.setFillParent(true);
+            }
+        }else{
+            parent.fill((x, y, w, h) -> renderer.render());
+        }
 
         parent.fill(c -> {
             c.pane(Styles.noBarPane, cont -> {
@@ -78,32 +101,10 @@ public class MenuFragment{
         }
 
 
-        //info icon
-        if(mobile){
-            parent.fill(c -> c.bottom().left().button("", new TextButtonStyle(){{
-                font = Fonts.def;
-                fontColor = Color.white;
-                up = infoBanner;
-            }}, ui.about::show).size(84, 45).name("info"));
-
-            parent.fill((x, y, w, h) -> {
-                if(Core.scene.marginBottom > 0){
-                    Tex.paneTop.draw(0, 0, Core.graphics.getWidth(), Core.scene.marginBottom);
-                }
-            });
-        }else if(becontrol.active()){
-            parent.fill(c -> c.bottom().right().button("@be.check", Icon.refresh, () -> {
-                ui.loadfrag.show();
-                becontrol.checkUpdate(result -> {
-                    ui.loadfrag.hide();
-                    if(!result){
-                        ui.showInfo("@be.noupdates");
-                    }
-                });
-            }).size(200, 60).name("becheck").update(t -> {
-                t.getLabel().setColor(becontrol.isUpdateAvailable() ? Tmp.c1.set(Color.white).lerp(Pal.accent, Mathf.absin(5f, 1f)) : Color.white);
-            }));
-        }
+        parent.fill(c -> c.bottom().left().table(t -> {
+            t.background(Tex.buttonEdge3);
+            t.button("\uE83D", cleart, this::nextBackGroundImg).width(50f);
+        }).visible(() -> Core.settings.getString("arcBackgroundPath", "").length() != 0).left().width(100));
 
         String versionText = ((Version.build == -1) ? "[#fc8140aa]" : "[#ffffffba]") + Version.combined();
         parent.fill((x, y, w, h) -> {
@@ -130,6 +131,22 @@ public class MenuFragment{
         }).touchable = Touchable.disabled;
     }
 
+    private void nextBackGroundImg(){
+        arcBGList = Core.files.absolute(arcBackgroundPath).findAll(f -> !f.isDirectory() && (f.extEquals("png") || f.extEquals("jpg") || f.extEquals("jpeg")));
+        if(arcBGList.size == 0) return;
+        arcBackgroundPath = Core.settings.getString("arcBackgroundPath");
+        arcBackgroundIndex += 1;
+        arcBackgroundIndex = arcBackgroundIndex % arcBGList.size;
+        new Thread(() -> {
+            try{
+                arcBackground = arcBGList.get(arcBackgroundIndex);
+                Core.app.post(() -> img.setDrawable(new TextureRegion(new Texture(arcBackground))));
+            }catch(Exception e){
+                Core.app.post(() -> ui.showException("背景图片无效:" + arcBGList.get(arcBackgroundIndex).path(), e));
+            }
+        }).start();
+    }
+
     private void buildMobile(){
         container.clear();
         container.name = "buttons";
@@ -147,7 +164,9 @@ public class MenuFragment{
             tools = new MobileButton(Icon.settings, "@settings", ui.settings::show),
             mods = new MobileButton(Icon.book, "@mods", ui.mods::show),
             exit = new MobileButton(Icon.exit, "@quit", () -> Core.app.exit()),
-            about = new MobileButton(Icon.info, "@about.button", ui.about::show);
+            //mindustrywiki = new MobileButton(Icon.book, "@mindustrywiki.button", ui.mindustrywiki::show),
+            database = new MobileButton(Icon.book, "@database", ui.database::show),
+            achievements = new MobileButton(Icon.star, "@achievements", arcui.achievements::show);
 
         Seq<MobileButton> customs = customButtons.map(b -> new MobileButton(b.icon, b.text, b.runnable == null ? () -> {} : b.runnable));
 
@@ -166,11 +185,14 @@ public class MenuFragment{
             container.add(editor);
             container.add(tools);
             container.add(mods);
+            container.add(achievements);
             // add even custom buttons (before the exit button)
             for(int i = 0; i < customs.size; i += 2){
                 container.add(customs.get(i));
             }
-            container.add(ios ? about : exit);
+            container.row();
+            container.add(database);
+            if(!ios) container.add(exit);
         }else{
             container.marginTop(0f);
             container.add(play);
@@ -188,10 +210,48 @@ public class MenuFragment{
                 container.add(customs.get(i));
                 if(i % 2 == 0) container.row();
             }
-            container.add(ios ? about : exit);
+            if(!ios) container.add(exit);
+            container.row();
+            container.add(database);
+            container.row();
+            container.add(achievements);
         }
     }
 
+    void initAchievement(){
+        if(service.enabled()) return;
+        service = new GameService(){
+            @Override
+            public boolean enabled(){
+                return true;
+            }
+
+            @Override
+            public void completeAchievement(String name){
+                Core.settings.put("achievement." + name, true);
+                //TODO draw the sprite of the achievement
+                ui.hudfrag.showToast(Core.atlas.getDrawable("error"), Core.bundle.get("achievement.unlocked") + "\n" + Core.bundle.get("achievement." + name + ".name"));
+            }
+
+            @Override
+            public boolean isAchieved(String name){
+                return Core.settings.getBool("achievement." + name, false);
+            }
+
+            @Override
+            public int getStat(String name, int def){
+                return Core.settings.getInt("achievementstat." + name, def);
+            }
+
+            @Override
+            public void setStat(String name, int amount){
+                Core.settings.put("achievementstat." + name, amount);
+            }
+        };
+
+        service.init();
+    }
+
     private void buildDesktop(){
         container.clear();
         container.setSize(Core.graphics.getWidth(), Core.graphics.getHeight());
@@ -200,7 +260,7 @@ public class MenuFragment{
         Drawable background = Styles.black6;
 
         container.left();
-        container.add().width(Core.graphics.getWidth()/10f);
+        container.add().width(Core.graphics.getWidth() / 10f);
         container.table(background, t -> {
             t.defaults().width(width).height(70f);
             t.name = "buttons";
@@ -210,14 +270,16 @@ public class MenuFragment{
                     new MenuButton("@campaign", Icon.play, () -> checkPlay(ui.planet::show)),
                     new MenuButton("@joingame", Icon.add, () -> checkPlay(ui.join::show)),
                     new MenuButton("@customgame", Icon.terrain, () -> checkPlay(ui.custom::show)),
-                    new MenuButton("@loadgame", Icon.download, () -> checkPlay(ui.load::show))
-                ),
+                    new MenuButton("@loadgame", Icon.download, () -> checkPlay(ui.load::show)),
+                    new MenuButton("@editor", Icon.terrain, () -> checkPlay(ui.maps::show)),
+                     steam ? new MenuButton("@workshop", Icon.steam, platform::openWorkshop) : null
+            ),
                 new MenuButton("@database.button", Icon.menu,
                     new MenuButton("@schematics", Icon.paste, ui.schematics::show),
                     new MenuButton("@database", Icon.book, ui.database::show),
                     new MenuButton("@about.button", Icon.info, ui.about::show)
                 ),
-                new MenuButton("@editor", Icon.terrain, () -> checkPlay(ui.maps::show)), steam ? new MenuButton("@workshop", Icon.steam, platform::openWorkshop) : null,
+                new MenuButton("@achievements", Icon.star, arcui.achievements::show),
                 new MenuButton("@mods", Icon.book, ui.mods::show),
                 new MenuButton("@settings", Icon.settings, ui.settings::show)
             );
diff --git a/core/src/mindustry/ui/fragments/PlacementFragment.java b/core/src/mindustry/ui/fragments/PlacementFragment.java
index ec32b1df8d50829e5af8817dbd4e05dae79bd04b..b0ab3be676e6be2ec0a1d681ba5455b440ea6db6 100644
--- a/core/src/mindustry/ui/fragments/PlacementFragment.java
+++ b/core/src/mindustry/ui/fragments/PlacementFragment.java
@@ -1,6 +1,7 @@
 package mindustry.ui.fragments;
 
 import arc.*;
+import arc.func.Boolf;
 import arc.graphics.*;
 import arc.input.*;
 import arc.math.geom.*;
@@ -12,6 +13,7 @@ import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
 import mindustry.ai.*;
+import mindustry.arcModule.ui.dialogs.BlockSelectDialog;
 import mindustry.content.*;
 import mindustry.core.*;
 import mindustry.entities.*;
@@ -24,23 +26,28 @@ import mindustry.input.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.*;
+import mindustry.world.blocks.ConstructBlock;
 import mindustry.world.blocks.ConstructBlock.*;
 import mindustryX.features.*;
+import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
 
 public class PlacementFragment{
-    final int rowWidth = 4;
+    private int rowWidth, maxRow;
 
     public Category currentCategory = Category.distribution;
 
     Seq<Block> returnArray = new Seq<>(), returnArray2 = new Seq<>();
     Seq<Category> returnCatArray = new Seq<>();
     boolean[] categoryEmpty = new boolean[Category.all.length];
-    ObjectMap<Category,Block> selectedBlocks = new ObjectMap<>();
+    public ObjectMap<Category,Block> selectedBlocks = new ObjectMap<>();
     ObjectFloatMap<Category> scrollPositions = new ObjectFloatMap<>();
     @Nullable Block menuHoverBlock;
-    @Nullable Displayable hover;
+    @Nullable Displayable hover,hover2;
+    @Nullable Tile hoverTile;
+    @Nullable Object lastDisplayTile;
     @Nullable Building lastFlowBuild, nextFlowBuild;
     @Nullable Object lastDisplayState;
     @Nullable Team lastTeam;
@@ -107,6 +114,10 @@ public class PlacementFragment{
                 if(nextFlowBuild.flowItems() != null) nextFlowBuild.flowItems().updateFlow();
                 if(nextFlowBuild.liquids != null) nextFlowBuild.liquids.updateFlow();
             }
+
+            if(rowWidth != Core.settings.getInt("itemSelectionWidth", 4) || maxRow != Core.settings.getInt("itemSelectionHeight", 4)){
+                rebuild();
+            }
         });
     }
 
@@ -114,7 +125,7 @@ public class PlacementFragment{
         return hover;
     }
 
-    void rebuild(){
+    public void rebuild(){
         //category does not change on rebuild anymore, only on new world load
         Group group = toggler.parent;
         int index = toggler.getZIndex();
@@ -129,6 +140,27 @@ public class PlacementFragment{
         if(Core.input.keyTap(Binding.pick) && player.isBuilder() && !Core.scene.hasDialog()){ //mouse eyedropper select
             var build = world.buildWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
 
+            if (build == null && AdvanceToolTable.worldCreator) {
+                var tile = world.tileWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
+                if (tile != null) {
+                    Block target;
+                    if (tile.block() != Blocks.air) {
+                        target = tile.block();
+                    }
+                    else if (tile.overlay() != Blocks.air) {
+                        target = tile.overlay();
+                    }
+                    else {
+                        target = tile.floor();
+                    }
+                    if (target != Blocks.air && (target.isVisible() || AdvanceToolTable.allBlocksReveal)) {
+                        input.block = target;
+                        currentCategory = input.block.category;
+                        return true;
+                    }
+
+                }
+            }
             //can't middle click buildings in fog
             if(build != null && build.inFogTo(player.team())){
                 build = null;
@@ -210,17 +242,21 @@ public class PlacementFragment{
         }
 
         if(Core.input.keyTap(Binding.category_prev)){
+            int i = 0;
             do{
                 currentCategory = currentCategory.prev();
-            }while(categoryEmpty[currentCategory.ordinal()]);
+                i ++;
+            }while(categoryEmpty[currentCategory.ordinal()] && i < categoryEmpty.length);
             input.block = getSelectedBlock(currentCategory);
             return true;
         }
 
         if(Core.input.keyTap(Binding.category_next)){
+            int i = 0;
             do{
                 currentCategory = currentCategory.next();
-            }while(categoryEmpty[currentCategory.ordinal()]);
+                i ++;
+            }while(categoryEmpty[currentCategory.ordinal()] && i < categoryEmpty.length);
             input.block = getSelectedBlock(currentCategory);
             return true;
         }
@@ -239,6 +275,8 @@ public class PlacementFragment{
     }
 
     public void build(Group parent){
+        rowWidth = Core.settings.getInt("itemSelectionWidth", 4);
+        maxRow = Core.settings.getInt("itemSelectionHeight", 4);
         parent.fill(full -> {
             toggler = full;
             full.bottom().right().visible(() -> ui.hudfrag.shown);
@@ -257,13 +295,14 @@ public class PlacementFragment{
                     group.setMinCheckCount(0);
 
                     for(Block block : getUnlockedByCategory(currentCategory)){
-                        if(!unlocked(block)) continue;
+                        if(!unlocked(block) && !AdvanceToolTable.allBlocksReveal) continue;
+                        if (block == Blocks.air || block instanceof ConstructBlock) continue;
                         if(index++ % rowWidth == 0){
                             blockTable.row();
                         }
 
                         ImageButton button = blockTable.button(new TextureRegionDrawable(block.uiIcon), Styles.selecti, () -> {
-                            if(unlocked(block)){
+                            if(unlocked(block) || AdvanceToolTable.allBlocksReveal){
                                 if((Core.input.keyDown(KeyCode.shiftLeft) || Core.input.keyDown(KeyCode.controlLeft)) && Fonts.getUnicode(block.name) != 0){
                                     Core.app.setClipboardText((char)Fonts.getUnicode(block.name) + "");
                                     ui.showInfoFade("@copied");
@@ -315,19 +354,22 @@ public class PlacementFragment{
 
                         //find current hovered thing
                         Displayable hovered = hover;
+                        Displayable hovered2 = hover2;
+                        Displayable hoveredTile = hoverTile;
                         Block displayBlock = menuHoverBlock != null ? menuHoverBlock : control.input.block;
                         Object displayState = displayBlock != null ? displayBlock : hovered;
                         boolean isHovered = displayBlock == null; //use hovered thing if displayblock is null
 
                         //don't refresh unnecessarily
                         //refresh only when the hover state changes, or the displayed block changes
-                        if(wasHovered == isHovered && lastDisplayState == displayState && lastTeam == player.team()) return;
+                        if(wasHovered == isHovered && lastDisplayState == displayState && lastDisplayTile == hoveredTile) return;
 
                         topTable.clear();
                         topTable.top().left().margin(5);
 
                         lastDisplayState = displayState;
                         wasHovered = isHovered;
+                        lastDisplayTile = hoveredTile;
                         lastTeam = player.team();
 
                         //show details of selected block, with costs
@@ -349,10 +391,10 @@ public class PlacementFragment{
                                 final String keyComboFinal = keyCombo;
                                 header.left();
                                 header.add(new Image(displayBlock.uiIcon)).size(8 * 4);
-                                header.labelWrap(() -> !unlocked(displayBlock) ? Core.bundle.get("block.unknown") : displayBlock.localizedName + keyComboFinal)
+                                header.labelWrap(() -> !unlocked(displayBlock) && !AdvanceToolTable.allBlocksReveal ? Core.bundle.get("block.unknown") : displayBlock.localizedName + keyComboFinal)
                                 .left().width(190f).padLeft(5);
                                 header.add().growX();
-                                if(unlocked(displayBlock)){
+                                if(unlocked(displayBlock) || AdvanceToolTable.allBlocksReveal){
                                     header.button("?", Styles.flatBordert, () -> {
                                         ui.content.show(displayBlock);
                                         Events.fire(new BlockInfoEvent());
@@ -368,7 +410,7 @@ public class PlacementFragment{
                                     req.table(line -> {
                                         line.left();
                                         line.image(stack.item.uiIcon).size(8 * 2);
-                                        line.add(stack.item.localizedName).maxWidth(140f).fillX().color(Color.lightGray).padLeft(2).left().get().setEllipsis(true);
+                                        line.add((Core.settings.getBool("colorizedContent") ? "": "[lightgray]") + stack.item.localizedName).maxWidth(140f).fillX().padLeft(2).left().get().setEllipsis(true);
                                         line.labelWrap(() -> {
                                             Building core = player.core();
                                             int stackamount = Math.round(stack.amount * state.rules.buildCostMultiplier);
@@ -396,7 +438,26 @@ public class PlacementFragment{
                         }else if(hovered != null){
                             //show hovered item, whatever that may be
                             hovered.display(topTable);
+                            if(hovered2 != hovered && hovered2 != null){
+                                topTable.row();
+                                hovered2.display(topTable);
+                            }}
+
+                        //只要可行便绘制地板|建筑，移除了其他重复绘制
+                        if (Core.settings.getBool("hoveredTileInfo") && hoveredTile != null) {
+                            topTable.row();
+                            topTable.row();
+                            topTable.table(t -> {
+                                t.left();
+                                t.add(new Image(hoverTile.floor().uiIcon)).size(20f).left();
+                                t.add(" " + hoverTile.floor().localizedName).left();
+                                if (hoverTile.block() != Blocks.air)
+                                    t.add(" | " + hoverTile.block().emoji() + (hoverTile.build != null ? "[#" + hoverTile.build.team.color + "]" : "") + hoverTile.block().localizedName).left();
+                                if (hoverTile.overlay() != Blocks.air)
+                                    t.add(" | " + hoverTile.overlay().emoji() + hoverTile.overlay().localizedName).left();
+                            }).growX().left();
                         }
+
                     });
                 }).colspan(3).fillX().visible(this::hasInfoBox).touchable(Touchable.enabled).row();
 
@@ -432,7 +493,7 @@ public class PlacementFragment{
                 }).colspan(3).fillX().row();
 
                 //commandTable: commanded units
-                {
+                if (Core.settings.getBool("arcCommandTable")){
                     commandTable.touchable = Touchable.enabled;
                     commandTable.add(Core.bundle.get("commandmode.name")).fill().center().labelAlign(Align.center).row();
                     commandTable.image().color(Pal.accent).growX().pad(20f).padTop(0f).padBottom(4f).row();
@@ -497,6 +558,7 @@ public class PlacementFragment{
                                     u.row();
 
                                     u.table(coms -> {
+                                        coms.add(Blocks.worldProcessor.emoji()).width(20f).padRight(20f);
                                         for(var command : commands){
                                             coms.button(Icon.icons.get(command.icon, Icon.cancel), Styles.clearNoneTogglei, () -> {
                                                 IntSeq ids = new IntSeq();
@@ -509,9 +571,62 @@ public class PlacementFragment{
                                         }
                                     }).fillX().padTop(4f).left();
                                 }
+                                if(control.input.selectedUnits.size > 0){
+                                    u.row();
+                                    u.table(sp -> {
+                                        float wound = (float) Core.settings.getInt("rtsWoundUnit") / 100f;
+                                        if (control.input.selectedUnits.contains(unit -> unit.health >= unit.maxHealth * wound) && control.input.selectedUnits.contains(unit -> unit.health < unit.maxHealth * wound)){
+                                            sp.table(spp->{
+                                                arcSelectUnits(spp,"[green]\uE813","高血量单位", unit -> unit.health >= unit.maxHealth * wound);
+                                                arcSelectUnits(spp,"[red]\uE80F","低血量单位", unit -> unit.health < unit.maxHealth * wound);
+                                            });
+                                        }
+
+                                        if (control.input.selectedUnits.contains(unit -> unit.type.commands.length > 1) && control.input.selectedUnits.contains(unit -> unit.type.commands.length <= 1)){
+                                            sp.table(spp->{
+                                                arcSelectUnits(spp,"\uE86E","进攻性单位", unit -> unit.type.commands.length <= 1);
+                                                arcSelectUnits(spp,"\uE86B","辅助性单位", unit -> unit.type.commands.length > 1);
+                                            });
+                                        }
+
+                                        int hasFlyer = control.input.selectedUnits.contains(unit -> unit.isFlying()) ? 1 : 0;
+                                        int hasLand = control.input.selectedUnits.contains(unit -> !unit.isFlying() && !unit.type.naval) ? 1 : 0;
+                                        int hasNaval = control.input.selectedUnits.contains(unit -> unit.type.naval) ? 1 : 0;
+                                        if (hasFlyer + hasLand + hasNaval >=2 ){
+                                            sp.table(spp->{
+                                                if (hasFlyer == 1) arcSelectUnits(spp,UnitTypes.flare.emoji(),"飞行单位", unit -> unit.isFlying());
+                                                if (hasLand == 1) arcSelectUnits(spp,UnitTypes.crawler.emoji(),"陆军单位", unit -> !unit.isFlying() && !unit.type.naval);
+                                                if (hasNaval == 1) arcSelectUnits(spp,UnitTypes.retusa.emoji(),"海军单位", unit -> unit.type.naval);
+                                            });
+                                        }
+                                    }).fillX().padTop(4f).left();
+                                }
                             }else{
                                 u.add(Core.bundle.get("commandmode.nounits")).color(Color.lightGray).growX().center().labelAlign(Align.center).pad(6);
                             }
+                            if (mobile) {
+                                u.row();
+                                u.table(sp->{
+                                    sp.button("\uE86D", Styles.cleart, () -> {
+                                        control.input.selectedUnits.clear();
+                                        control.input.commandBuildings.clear();
+                                        for(var unit : player.team().data().units){
+                                            if(unit.isCommandable()){
+                                                control.input.selectedUnits.add(unit);
+                                            }
+                                        }
+                                    }).size(40f);
+                                    sp.button(Blocks.additiveReconstructor.emoji(), Styles.cleart, () -> {
+                                        control.input.selectedUnits.clear();
+                                        control.input.commandBuildings.clear();
+                                        for(var build : player.team().data().buildings){
+                                            if(build.block.commandable){
+                                                control.input.commandBuildings.add(build);
+                                            }
+                                        }
+                                    }).size(40f);
+                                }).fillX().padTop(4f).left().row();
+                            }
                         };
 
                         u.update(() -> {
@@ -551,13 +666,121 @@ public class PlacementFragment{
                         });
                         rebuildCommand.run();
                     }).grow();
+
+                } else{//commandTable: commanded units
+                        commandTable.touchable = Touchable.enabled;
+                        commandTable.add("[accent]指挥模式").fill().center().labelAlign(Align.center).row();
+                        commandTable.image().color(Pal.accent).growX().pad(20f).padTop(0f).padBottom(4f).row();
+                        commandTable.table(u -> {
+                            u.left();
+                            int[] curCount = {0};
+                            UnitCommand[] currentCommand = {null};
+                            var commands = new Seq<UnitCommand>();
+
+                            rebuildCommand = () -> {
+                                u.clearChildren();
+                                var units = control.input.selectedUnits;
+                                if(units.size > 0){
+                                    int[] counts = new int[content.units().size];
+                                    for(var unit : units){
+                                        counts[unit.type.id] ++;
+                                    }
+                                    commands.clear();
+                                    boolean firstCommand = false;
+                                    Table unitlist = u.table().growX().left().get();
+                                    unitlist.left();
+
+                                    int col = 0;
+                                    for(int i = 0; i < counts.length; i++){
+                                        if(counts[i] > 0){
+                                            var type = content.unit(i);
+                                            unitlist.add(new ItemImage(type.uiIcon, counts[i])).tooltip(type.localizedName).pad(4).with(b -> {
+                                                var listener = new ClickListener();
+
+                                                //left click -> select
+                                                b.clicked(KeyCode.mouseLeft, () -> control.input.selectedUnits.removeAll(unit -> unit.type != type));
+                                                //right click -> remove
+                                                b.clicked(KeyCode.mouseRight, () -> control.input.selectedUnits.removeAll(unit -> unit.type == type));
+
+                                                b.addListener(listener);
+                                                b.addListener(new HandCursorListener());
+                                                //gray on hover
+                                                b.update(() -> ((Group)b.getChildren().first()).getChildren().first().setColor(listener.isOver() ? Color.lightGray : Color.white));
+                                            });
+
+                                            if(++col % 7 == 0){
+                                                unitlist.row();
+                                            }
+
+                                            if(!firstCommand){
+                                                commands.add(type.commands);
+                                                firstCommand = true;
+                                            }else{
+                                                //remove commands that this next unit type doesn't have
+                                                commands.removeAll(com -> !Structs.contains(type.commands, com));
+                                            }
+                                        }
+                                    }
+
+                                    if(commands.size > 1){
+                                        u.row();
+
+                                        u.table(coms -> {
+                                            for(var command : commands){
+                                                coms.button(Icon.icons.get(command.icon, Icon.cancel), Styles.clearNoneTogglei, () -> {
+                                                    IntSeq ids = new IntSeq();
+                                                    for(var unit : units){
+                                                        ids.add(unit.id);
+                                                    }
+
+                                                    Call.setUnitCommand(player, ids.toArray(), command);
+                                                }).checked(i -> currentCommand[0] == command).size(50f).tooltip(command.localized());
+                                            }
+                                        }).fillX().padTop(4f).left();
+                                    }
+                                }else{
+                                    u.add("[未选择单位]").color(Pal.accent).growX().center().labelAlign(Align.center).pad(6);
+                                }
+                            };
+
+                            u.update(() -> {
+                                boolean hadCommand = false;
+                                UnitCommand shareCommand = null;
+
+                                //find the command that all units have, or null if they do not share one
+                                for(var unit : control.input.selectedUnits){
+                                    if(unit.isCommandable()){
+                                        var nextCommand = unit.command().currentCommand();
+
+                                        if(hadCommand){
+                                            if(shareCommand != nextCommand){
+                                                shareCommand = null;
+                                            }
+                                        }else{
+                                            shareCommand = nextCommand;
+                                            hadCommand = true;
+                                        }
+                                    }
+                                }
+
+                                currentCommand[0] = shareCommand;
+
+                                int size = control.input.selectedUnits.size;
+                                if(curCount[0] != size){
+                                    curCount[0] = size;
+                                    rebuildCommand.run();
+                                }
+                            });
+                            rebuildCommand.run();
+                        }).grow();
+
                 }
 
                 //blockCatTable: all blocks | all categories
                 {
                     blockCatTable.table(Tex.pane2, blocksSelect -> {
                         blocksSelect.margin(4).marginTop(0);
-                        blockPane = blocksSelect.pane(blocks -> blockTable = blocks).height(194f).update(pane -> {
+                        blockPane = blocksSelect.pane(blocks -> blockTable = blocks).height(maxRow * 46f + 10f).update(pane -> {
                             if(pane.hasScroll()){
                                 Element result = Core.scene.hit(Core.input.mouseX(), Core.input.mouseY(), true);
                                 if(result == null || !result.isDescendantOf(pane)){
@@ -591,6 +814,17 @@ public class PlacementFragment{
                         boolean needsAssign = categoryEmpty[currentCategory.ordinal()];
 
                         int f = 0;
+                        if (maxRow > 5){
+                            categories.button(Icon.zoom, Styles.clearTogglei, () -> {
+                                new BlockSelectDialog(block -> block.replaceable, block -> {
+                                    control.input.block = block;
+                                    currentCategory = block.category;
+                                    rebuildCategory.run();
+                                    }, block -> control.input.block == block).show();
+                            }).group(group);
+                            categories.image(Styles.black6);
+                            categories.row();
+                        }
                         for(Category cat : getCategories()){
                             if(f++ % 2 == 0) categories.row();
 
@@ -636,7 +870,7 @@ public class PlacementFragment{
     }
 
     Seq<Block> getUnlockedByCategory(Category cat){
-        return returnArray2.selectFrom(content.blocks(), block -> block.category == cat && block.isVisible() && unlocked(block)).sort((b1, b2) -> Boolean.compare(!b1.isPlaceable(), !b2.isPlaceable()));
+        return returnArray2.selectFrom(content.blocks(), block -> block.category == cat &&(AdvanceToolTable.allBlocksReveal||block.isVisible() && unlocked(block)) ).sort((b1, b2) -> Boolean.compare(!b1.isPlaceable(), !b2.isPlaceable()));
     }
 
     Block getSelectedBlock(Category cat){
@@ -650,7 +884,9 @@ public class PlacementFragment{
 
     boolean hasInfoBox(){
         hover = hovered();
-        return control.input.block != null || menuHoverBlock != null || hover != null;
+        hover2 = hoveredblock();
+        hoverTile = hoveredTile();
+        return control.input.block != null || menuHoverBlock != null || hover != null || hoverTile != null;
     }
 
     /** Returns the thing being hovered over. */
@@ -662,24 +898,75 @@ public class PlacementFragment{
         if(Core.scene.hasMouse() || topTable.hit(v.x, v.y, false) != null) return null;
 
         //check for a unit
-        Unit unit = Units.closestOverlap(player.team(), Core.input.mouseWorldX(), Core.input.mouseWorldY(), 5f, u -> !u.isLocal() && u.displayable());
+        Unit unit = Units.closestOverlap(player.team(), Core.input.mouseWorldX(), Core.input.mouseWorldY(), 5f, u -> true);
         //if cursor has a unit, display it
         if(unit != null) return unit;
-
+        unit = Units.closestEnemy(player.team(), Core.input.mouseWorldX(), Core.input.mouseWorldY(), 5f, u -> true);
+        if(unit != null) return unit;
         //check tile being hovered over
         Tile hoverTile = world.tileWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
         if(hoverTile != null){
             //if the tile has a building, display it
-            if(hoverTile.build != null && hoverTile.build.displayable() && !hoverTile.build.inFogTo(player.team())){
+            if(hoverTile.build != null && hoverTile.build.displayable()  && !hoverTile.build.inFogTo(player.team())){
                 return nextFlowBuild = hoverTile.build;
             }
+        }
 
-            //if the tile has a drop, display the drop
-            if((hoverTile.drop() != null && hoverTile.block() == Blocks.air) || hoverTile.wallDrop() != null || hoverTile.floor().liquidDrop != null){
-                return hoverTile;
+        return null;
+
+
+    }
+    @Nullable
+    Displayable hoveredblock(){
+        Vec2 v = topTable.stageToLocalCoordinates(Core.input.mouse());
+
+        //if the mouse intersects the table or the UI has the mouse, no hovering can occur
+        if(Core.scene.hasMouse() || topTable.hit(v.x, v.y, false) != null) return null;
+
+        //check tile being hovered over
+        Tile hoverTile = world.tileWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
+        if(hoverTile != null){
+            //if the tile has a building, display it
+            if(hoverTile.build != null && hoverTile.build.displayable() && !hoverTile.build.inFogTo(player.team())){
+                return nextFlowBuild = hoverTile.build;
             }
         }
 
         return null;
     }
+
+    @Nullable
+    Tile hoveredTile(){
+        Vec2 v = topTable.stageToLocalCoordinates(Core.input.mouse());
+
+        //if the mouse intersects the table or the UI has the mouse, no hovering can occur
+        if(Core.scene.hasMouse() || topTable.hit(v.x, v.y, false) != null) return null;
+
+        //check tile being hovered over
+        Tile hoverTile = world.tileWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
+        if(hoverTile != null && !(hoverTile.build!=null && hoverTile.build.inFogTo(player.team()))) return hoverTile;
+        return null;
+    }
+
+    void arcSelectUnits(Table table, String icon, String info, Boolf<Unit> cons){
+        float size = 40f;
+
+        table.button(icon, Styles.cleart, () -> {}).tooltip(info).size(size).with(b->{
+            var listener = new ClickListener();
+            b.clicked(KeyCode.mouseLeft, () -> {
+                control.input.selectedUnits = control.input.selectedUnits.select(cons::get);
+                Events.fire(Trigger.unitCommandChange);
+                arcui.arcInfo("[cyan]arc控制器\n[acid]选择" + info + "！");
+            });
+            //right click -> remove
+            b.clicked(KeyCode.mouseRight, () -> {
+                control.input.selectedUnits.removeAll(cons::get);
+                Events.fire(Trigger.unitCommandChange);
+                arcui.arcInfo("[cyan]arc控制器\n[orange]移除" + info + "！");
+            });
+
+            b.addListener(listener);
+            b.addListener(new HandCursorListener());
+        });
+    }
 }
diff --git a/core/src/mindustry/ui/fragments/PlayerListFragment.java b/core/src/mindustry/ui/fragments/PlayerListFragment.java
index 9286aab19502b5cf40556311572157b20c60fef4..4a0150c92531cf85f32aa90e026f6859386b105c 100644
--- a/core/src/mindustry/ui/fragments/PlayerListFragment.java
+++ b/core/src/mindustry/ui/fragments/PlayerListFragment.java
@@ -10,23 +10,30 @@ import arc.scene.ui.ImageButton.*;
 import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
-import mindustry.game.*;
+import mindustry.game.Team;
+import mindustry.input.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
-import mindustry.input.*;
 import mindustry.net.*;
 import mindustry.net.Packets.*;
 import mindustry.ui.*;
 import mindustry.ui.dialogs.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.arcModule.RFuncs.getPrefix;
+import static mindustry.input.InputHandler.follow;
 
 public class PlayerListFragment{
     public Table content = new Table().marginRight(13f).marginLeft(13f);
     private boolean visible = false;
     private Interval timer = new Interval();
     private TextField search;
-    private Seq<Player> players = new Seq<>();
+    public Seq<Player> players = new Seq<>();
+
+    private float buttonSize = 30f;
+    private boolean teamMode = false;
 
     public void build(Group parent){
         content.name = "players";
@@ -63,23 +70,23 @@ public class PlayerListFragment{
                     menu.defaults().growX().height(50f).fillY();
                     menu.name = "menu";
 
+                    if (Core.settings.getBool("arcPlayerList") && Core.settings.getBool("easyJS")) menu.button("js换队",() -> teamMode = !teamMode).checked(t->teamMode);
                     menu.button("@server.bans", ui.bans::show).disabled(b -> net.client());
                     menu.button("@server.admins", ui.admins::show).disabled(b -> net.client());
                     menu.button("@close", this::toggle);
                 }).margin(0f).pad(10f).growX();
 
-            }).touchable(Touchable.enabled).margin(14f).minWidth(360f);
+            }).touchable(Touchable.enabled).margin(14f).minWidth(720f);
         });
 
         rebuild();
     }
 
     public void rebuild(){
-        boolean allowTeamSwitch = !state.isCampaign() && (state.rules.pvp || state.rules.infiniteResources);
-
         content.clear();
 
-        float h = 50f;
+        float h = 40f;
+        float bs = (h) - 2f;
         boolean found = false;
 
         players.clear();
@@ -95,6 +102,7 @@ public class PlayerListFragment{
             NetConnection connection = user.con;
 
             if(connection == null && net.server() && !user.isLocal()) return;
+            if(search.getText().length() > 0 && !user.name().toLowerCase().contains(search.getText().toLowerCase()) && !Strings.stripColors(user.name().toLowerCase()).contains(search.getText().toLowerCase())) return;
 
             Table button = new Table();
             button.left();
@@ -121,7 +129,6 @@ public class PlayerListFragment{
                 iconTable.addListener(new HandCursorListener());
             }
             iconTable.margin(8);
-            iconTable.add(new Image(user.icon()).setScaling(Scaling.bounded)).grow();
             iconTable.name = user.name();
             iconTable.touchable = Touchable.enabled;
 
@@ -135,14 +142,6 @@ public class PlayerListFragment{
                 }
             });
 
-            button.add(iconTable).size(h);
-            button.labelWrap("[#" + user.color().toString().toUpperCase() + "]" + user.name()).style(Styles.outlineLabel).width(170f).pad(10);
-            button.add().grow();
-
-            button.background(Tex.underline);
-
-            button.image(Icon.admin).visible(() -> user.admin && !(!user.isLocal() && net.server())).padRight(5).get().updateVisibility();
-
             var ustyle = new ImageButtonStyle(){{
                 down = Styles.none;
                 up = Styles.none;
@@ -151,10 +150,106 @@ public class PlayerListFragment{
                 imageOverColor = Color.lightGray;
             }};
 
-            if(net.server() || (player.admin && (!user.admin || user == player))){
-                button.add().growY();
+            iconTable.margin(4);
+            iconTable.add(new Image(user.icon()).setScaling(Scaling.bounded)).grow();
+            iconTable.name = user.name();
+
+            if (Core.settings.getBool("arcPlayerList")){
+                button.add(iconTable).size(h);
+                button.image(Icon.admin).visible(() -> user.admin && !(!user.isLocal() && net.server())).size(bs).get().updateVisibility();
+                button.table(
+                    t -> {
+                        t.labelWrap("[#" + user.color().toString().toUpperCase() + "]" + user.name()).minWidth(380f);
+                        t.touchable = Touchable.enabled;
+                        t.tapped(()->{
+                            Core.app.setClipboardText(user.name);
+                            arcui.arcInfo("复制昵称：" + user.name);
+                        });
+                    }
+                ).width(400f).pad(10f).left();
+
+                button.add().grow();
+
+                button.button("♐", Styles.cleart, () -> {
+                    String message = arcAtPlayer(user.name);
+                    Call.sendChatMessage(message);
+                }).color(Pal.accent).size(buttonSize);
+
+                button.button(String.valueOf(Iconc.lock), Styles.cleart, () -> {
+                    if(follow != user){
+                        follow = user;
+                    }else {
+                        follow = null;
+                    }
+                    if(control.input instanceof DesktopInput){
+                        ((DesktopInput) control.input).panning = follow == user;
+                        arcui.arcInfo("追踪玩家：" + user.name);
+                    }
+                }).checked(b -> {
+                    boolean checked = follow == user;
+                    b.setText(checked ? String.valueOf(Iconc.lock) : String.valueOf(Iconc.lockOpen));
+                    return checked;
+                }).size(buttonSize);
+
+                button.button("[coral]" + Iconc.planeOutline, Styles.cleart,
+                () -> {
+                    ui.showConfirm("@confirm", Core.bundle.format("confirmvotekick",  user.name()), () -> {
+                        Call.sendChatMessage("/votekick " + user.name());
+                    });
+                }).size(buttonSize);
+
+                if((net.server() || player.admin) && !user.isLocal() && (!user.admin || net.server())){
+                    button.button("[gold]" + Iconc.zoom, Styles.cleart, () -> Call.adminRequest(user, AdminAction.trace, null)).size(buttonSize);
+                    button.button("[gold]" + Iconc.cancel, Styles.cleart,
+                            () -> ui.showConfirm("@confirm", Core.bundle.format("confirmkick",  user.name()), () -> Call.adminRequest(user, AdminAction.kick, null))).size(buttonSize);
+                    button.button("[gold]" + Iconc.hammer, Styles.cleart,
+                            () -> ui.showConfirm("@confirm", Core.bundle.format("confirmban",  user.name()), () -> Call.adminRequest(user, AdminAction.ban, null))).size(buttonSize);
+                }
+                if (teamMode) {
+                    if (state.teams.getActive().size <= 5){
+                        state.teams.getActive().each(teamData -> button.button("[#" + teamData.team.color + "]" + teamData.team.localized(), Styles.cleart,
+                                () -> Call.sendChatMessage("/js Groups.player.find(e=>e.name== \"" + user.name + "\").team(Team.get(" + teamData.team.id + "))")).size(buttonSize));
+                    }
+                    button.button("[violet]+", Styles.cleart, () -> UIExt.teamSelect.pickOne(team ->
+                    Call.sendChatMessage("/js Groups.player.find(e=>e.name== \"" + user.name + "\").team(Team.get(" + team.id + "))"), user.team())).size(buttonSize);
+                } else if (net.server() || (player.admin && (!user.admin || user == player))) {
+                    if (state.teams.getActive().size <= 5){
+                        state.teams.getActive().each(teamData -> button.button("[#" + teamData.team.color + "]" + teamData.team.localized(), Styles.cleart,
+                                () -> Call.adminRequest(user, AdminAction.switchTeam, teamData.team)).size(buttonSize));
+                    }
+                    button.button("[violet]+",Styles.cleart,()-> UIExt.teamSelect.pickOne(team -> Call.adminRequest(user, AdminAction.switchTeam, team), user.team())).size(buttonSize);
+                }
+                if((net.server() || (player.admin && (!user.admin || user == player))) && !net.client() && !user.isLocal()){
+                    button.button("" + Iconc.admin,Styles.cleart, () -> {
+                        String id = user.uuid();
+
+                        if(user.admin){
+                            ui.showConfirm("@confirm", Core.bundle.format("confirmunadmin",  user.name()), () -> {
+                                netServer.admins.unAdminPlayer(id);
+                                user.admin = false;
+                            });
+                        }else{
+                            ui.showConfirm("@confirm", Core.bundle.format("confirmadmin",  user.name()), () -> {
+                                netServer.admins.adminPlayer(id, user.usid());
+                                user.admin = true;
+                            });
+                        }
+                    }).checked(b -> user.admin).row();
+                }
+            }
+            //原版模式
+            else {
+                button.add(iconTable).size(h);
+                button.labelWrap("[#" + user.color().toString().toUpperCase() + "]" + user.name()).style(Styles.outlineLabel).width(170f).pad(10);
+                button.add().grow();
+
+                button.background(Tex.underline);
+
+                button.image(Icon.admin).visible(() -> user.admin && !(!user.isLocal() && net.server())).padRight(5).get().updateVisibility();
+
+                if(net.server() || (player.admin && (!user.admin || user == player))){
+                    button.add().growY();
 
-                if(allowTeamSwitch || user != player){
                     button.button(Icon.menu, ustyle, () -> {
                         var dialog = new BaseDialog(user.coloredName());
 
@@ -181,43 +276,42 @@ public class PlayerListFragment{
                                     ui.showConfirm("@confirm", Core.bundle.format("confirmkick",  user.name()), () -> Call.adminRequest(user, AdminAction.kick, null));
                                     dialog.hide();
                                 }).row();
+                            }
 
+                            if(!user.isLocal()){
                                 t.button("@player.trace", Icon.zoom, bstyle, () -> {
                                     Call.adminRequest(user, AdminAction.trace, null);
                                     dialog.hide();
                                 }).row();
                             }
 
-                            //there's generally no reason to team switch outside PvP or sandbox, and it's basically an easy way to cheat
-                            if(allowTeamSwitch){
-                                t.button("@player.team", Icon.redo, bstyle, () -> {
-                                    var teamSelect = new BaseDialog(Core.bundle.get("player.team") + ": " + user.name);
-                                    teamSelect.setFillParent(false);
+                            t.button("@player.team", Icon.redo, bstyle, () -> {
+                                var teamSelect = new BaseDialog(Core.bundle.get("player.team") + ": " + user.name);
+                                teamSelect.setFillParent(false);
 
-                                    var group = new ButtonGroup<>();
+                                var group = new ButtonGroup<>();
 
-                                    int i = 0;
+                                int i = 0;
 
-                                    for(Team team : Team.baseTeams){
-                                        var b = new ImageButton(Tex.whiteui, Styles.clearNoneTogglei);
-                                        b.margin(4f);
-                                        b.getImageCell().grow();
-                                        b.getStyle().imageUpColor = team.color;
-                                        b.clicked(() -> {
-                                            Call.adminRequest(user, AdminAction.switchTeam, team);
-                                            teamSelect.hide();
-                                        });
-                                        teamSelect.cont.add(b).size(50f).checked(a -> user.team() == team).group(group);
+                                for(Team team : Team.baseTeams){
+                                    var b = new ImageButton(Tex.whiteui, Styles.clearNoneTogglei);
+                                    b.margin(4f);
+                                    b.getImageCell().grow();
+                                    b.getStyle().imageUpColor = team.color;
+                                    b.clicked(() -> {
+                                        Call.adminRequest(user, AdminAction.switchTeam, team);
+                                        teamSelect.hide();
+                                    });
+                                    teamSelect.cont.add(b).size(50f).checked(a -> user.team() == team).group(group);
 
-                                        if(i++ % 3 == 2) teamSelect.cont.row();
-                                    }
+                                    if(i++ % 3 == 2) teamSelect.cont.row();
+                                }
 
-                                    teamSelect.addCloseButton();
-                                    teamSelect.show();
+                                teamSelect.addCloseButton();
+                                teamSelect.show();
 
-                                    dialog.hide();
-                                }).row();
-                            }
+                                dialog.hide();
+                            }).row();
 
                             if(!net.client() && !user.isLocal()){
                                 t.button("@player.admin", Icon.admin, Styles.togglet, () -> {
@@ -242,20 +336,21 @@ public class PlayerListFragment{
                         dialog.cont.button("@back", Icon.left, dialog::hide).padTop(-1f).size(220f, 55f);
 
                         dialog.show();
+                    }).size(h);
 
+                }else if(!user.isLocal() && !user.admin && net.client() && Groups.player.size() >= 3 && player.team() == user.team()){ //votekick
+                    button.add().growY();
 
-                    }).size(h);
+                    button.button(Icon.hammer, ustyle,
+                        () -> ui.showTextInput("@votekick.reason", Core.bundle.format("votekick.reason.message", user.name()), "",
+                        reason -> Call.sendChatMessage("/votekick #" + user.id + " " + reason)))
+                    .size(h);
                 }
-            }else if(!user.isLocal() && !user.admin && net.client() && Groups.player.size() >= 3 && player.team() == user.team()){ //votekick
-                button.add().growY();
 
-                button.button(Icon.hammer, ustyle,
-                    () -> ui.showTextInput("@votekick.reason", Core.bundle.format("votekick.reason.message", user.name()), "",
-                    reason -> Call.sendChatMessage("/votekick #" + user.id + " " + reason)))
-                .size(h);
             }
-
-            content.add(button).width(350f).height(h + 14);
+            content.add(button).padBottom(-6).width(700f).maxHeight(h + 14);
+            content.row();
+            content.image().height(4f).color(state.rules.pvp|| Core.settings.getBool("arcAlwaysTeamColor") ? user.team().color : Pal.gray).growX();
             content.row();
         }
 
@@ -276,4 +371,9 @@ public class PlayerListFragment{
         }
     }
 
+    private String arcAtPlayer(String name){
+        StringBuilder builder = new StringBuilder(getPrefix("coral","AT"));
+        builder.append("戳了").append(name).append("[white]一下，并提醒你留意对话框");
+        return builder.toString();
+    }
 }
diff --git a/core/src/mindustry/world/Block.java b/core/src/mindustry/world/Block.java
index 966ad9bd89a5c8c1886a375543684bfe84ff8af8..fde1d9d6d2085a81adb7886448f28d3dfff4dccf 100644
--- a/core/src/mindustry/world/Block.java
+++ b/core/src/mindustry/world/Block.java
@@ -14,6 +14,7 @@ import arc.struct.*;
 import arc.util.*;
 import arc.util.pooling.*;
 import mindustry.annotations.Annotations.*;
+import mindustry.arcModule.draw.ARCBuilds;
 import mindustry.content.*;
 import mindustry.core.*;
 import mindustry.ctype.*;
@@ -28,6 +29,7 @@ import mindustry.logic.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.blocks.*;
+import mindustry.world.blocks.defense.turrets.BaseTurret;
 import mindustry.world.blocks.environment.*;
 import mindustry.world.blocks.power.*;
 import mindustry.world.consumers.*;
@@ -356,7 +358,7 @@ public class Block extends UnlockableContent implements Senseable{
     /** Map of bars by name. */
     protected OrderedMap<String, Func<Building, Bar>> barMap = new OrderedMap<>();
     /** List for building up consumption before init(). */
-    protected Seq<Consume> consumeBuilder = new Seq<>();
+    public Seq<Consume> consumeBuilder = new Seq<>();
 
     protected TextureRegion[] generatedIcons;
     protected TextureRegion[] editorVariantRegions;
@@ -386,6 +388,7 @@ public class Block extends UnlockableContent implements Senseable{
         //delegates to entity unless it is null
         if(tile.build != null){
             tile.build.draw();
+            if (tile.block instanceof BaseTurret t) ARCBuilds.arcTurret((BaseTurret.BaseTurretBuild) tile.build);
         }else{
             Draw.rect(
                 variants == 0 ? region :
@@ -466,10 +469,66 @@ public class Block extends UnlockableContent implements Senseable{
         return width;
     }
 
+    public float drawPurePlaceText(String text, int x, int y, boolean valid){
+        if(renderer.pixelator.enabled()) return 0;
+
+        Color color = valid ? Pal.accent : Pal.remove;
+        Font font = Fonts.outline;
+        GlyphLayout layout = Pools.obtain(GlyphLayout.class, GlyphLayout::new);
+        boolean ints = font.usesIntegerPositions();
+        font.setUseIntegerPositions(false);
+        font.getData().setScale(1f / 4f / Scl.scl(1f));
+        layout.setText(font, text);
+
+        float width = layout.width;
+
+        float dx = x * tilesize + offset, dy = y * tilesize + offset + size * tilesize / 2f + 3;
+        font.draw(text, dx, dy + layout.height + 1, Align.center);
+        dy -= 1f;
+        Lines.stroke(2f, Color.darkGray);
+        Lines.line(dx - layout.width / 2f - 2f, dy, dx + layout.width / 2f + 1.5f, dy);
+        Lines.stroke(1f, color);
+        Lines.line(dx - layout.width / 2f - 2f, dy, dx + layout.width / 2f + 1.5f, dy);
+
+        font.setUseIntegerPositions(ints);
+        font.setColor(Color.white);
+        font.getData().setScale(1f);
+        Draw.reset();
+        Pools.free(layout);
+
+        return width;
+    }
     /** Drawn when placing and when hovering over. */
     public void drawOverlay(float x, float y, int rotation){
     }
 
+    public float drawText(String text, float x, float y, boolean valid, float scl){
+        if(renderer.pixelator.enabled()) return 0;
+
+        Color color = valid ? Pal.accent : Pal.remove;
+        Font font = Fonts.outline;
+        GlyphLayout layout = Pools.obtain(GlyphLayout.class, GlyphLayout::new);
+        boolean ints = font.usesIntegerPositions();
+        font.setUseIntegerPositions(false);
+        font.getData().setScale(1f / 4f / Scl.scl(1f) * scl);
+        layout.setText(font, text);
+
+        float width = layout.width;
+
+        font.setColor(color);
+        float dx = x, dy = y;
+        font.draw(text, dx, dy + layout.height + 1, Align.center);
+        dy -= 1f;
+
+        font.setUseIntegerPositions(ints);
+        font.setColor(Color.white);
+        font.getData().setScale(1f);
+        Draw.reset();
+        Pools.free(layout);
+
+        return width;
+    }
+
     public float sumAttribute(@Nullable Attribute attr, int x, int y){
         if(attr == null) return 0;
         Tile tile = world.tile(x, y);
@@ -478,6 +537,11 @@ public class Block extends UnlockableContent implements Senseable{
             .sumf(other -> !floating && other.floor().isDeep() ? 0 : other.floor().attributes.get(attr));
     }
 
+    public float sumAttribute(@Nullable Attribute attr, Tile tile){
+        if(attr == null) return 0;
+        return tile.getLinkedTilesAs(this, tempTiles)
+                .sumf(other -> !floating && other.floor().isDeep() ? 0 : other.floor().attributes.get(attr));
+    }
     public TextureRegion getDisplayIcon(Tile tile){
         return tile.build == null ? uiIcon : tile.build.getDisplayIcon();
     }
@@ -530,7 +594,7 @@ public class Block extends UnlockableContent implements Senseable{
             }
         }
 
-        if(requirements.length > 0){
+        if(canBeBuilt() && requirements.length > 0){
             stats.add(Stat.buildTime, buildCost / 60, StatUnit.seconds);
             stats.add(Stat.buildCost, StatValues.items(false, requirements));
         }
@@ -704,7 +768,12 @@ public class Block extends UnlockableContent implements Senseable{
 
     public void drawPlan(BuildPlan plan, Eachable<BuildPlan> list, boolean valid, float alpha){
         Draw.reset();
-        Draw.mixcol(!valid ? Pal.breakInvalid : Color.white, (!valid ? 0.4f : 0.24f) + Mathf.absin(Time.globalTime, 6f, 0.28f));
+        if (!valid)  Draw.mixcol(Pal.breakInvalid, 0.4f + Mathf.absin(Time.globalTime, 6f, 0.28f));
+        else {
+            if (player.unit().within(plan.x * tilesize,plan.y * tilesize,player.unit().type.buildRange))
+                Draw.mixcol(Color.white, 0.24f + Mathf.absin(Time.globalTime, 6f, 0.28f));
+            else Draw.mixcol(Color.valueOf("#FFE4B5"), 0.33f + Mathf.absin(Time.globalTime, 6f, 0.28f));
+        }
         Draw.alpha(alpha);
         float prevScale = Draw.scl;
         Draw.scl *= plan.animScale;
@@ -891,7 +960,7 @@ public class Block extends UnlockableContent implements Senseable{
     }
 
     public boolean isPlaceable(){
-        return isVisible() && (!state.rules.isBanned(this) || state.rules.editor) && supportsEnv(state.rules.env);
+        return AdvanceToolTable.allBlocksReveal || isVisible() && (!state.rules.isBanned(this) || state.rules.editor) && supportsEnv(state.rules.env);
     }
 
     /** @return whether this block supports a specific environment. */
diff --git a/core/src/mindustry/world/Build.java b/core/src/mindustry/world/Build.java
index e5a9064930f35b01c57e2f4e84ee3c08b49e3838..b00f72dca8eec41f16ef19fc09b1a9036e8de769 100644
--- a/core/src/mindustry/world/Build.java
+++ b/core/src/mindustry/world/Build.java
@@ -14,7 +14,10 @@ import mindustry.game.Teams.*;
 import mindustry.gen.*;
 import mindustry.world.blocks.*;
 import mindustry.world.blocks.ConstructBlock.*;
+import mindustry.world.blocks.environment.Floor;
+import mindustry.world.blocks.environment.OverlayFloor;
 import mindustry.world.blocks.storage.CoreBlock.*;
+import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
 
@@ -69,6 +72,36 @@ public class Build{
             return;
         }
 
+        if(AdvanceToolTable.worldCreator){
+            Tile tile = world.tile(x, y);
+            if(tile == null) return;
+            if(result == Blocks.cliff) {
+                int rotationb = 0;
+                for(int i = 0; i < 8; i++){
+                    Tile other = world.tiles.get(tile.x + Geometry.d8[i].x, tile.y + Geometry.d8[i].y);
+                    if(other != null && !other.floor().hasSurface()){
+                        rotationb |= (1 << i);
+                    }
+                }
+
+                if(rotationb != 0){
+                    tile.setBlock(Blocks.cliff);
+                }
+
+                tile.data = (byte)rotationb;
+                return;
+            };
+            if(result instanceof OverlayFloor){
+                tile.setOverlay(result);
+                return;
+            }
+            if(result instanceof Floor floor){
+                tile.setFloor(floor);
+                pathfinder.updateTile(tile);
+                return;
+            }
+        }
+
         Tile tile = world.tile(x, y);
 
         //just in case
@@ -128,6 +161,22 @@ public class Build{
     /** Returns whether a tile can be placed at this location by this team. */
     public static boolean validPlace(Block type, Team team, int x, int y, int rotation, boolean checkVisible){
         //the wave team can build whatever they want as long as it's visible - banned blocks are not applicable
+
+        if(AdvanceToolTable.forcePlacement){
+            Tile tile = world.tile(x, y);
+            return tile != null;
+        }
+
+        if (AdvanceToolTable.worldCreator) {
+            Tile tile = world.tile(x, y);
+            if (tile == null) return false;
+            if (type instanceof OverlayFloor of) {
+                return !(tile.overlay == of);
+            }
+            if (type instanceof Floor f) {
+                return !(tile.floor == f);
+            }
+        }
         if(type == null || (checkVisible && (!type.environmentBuildable() || (!type.isPlaceable() && !(state.rules.waves && team == state.rules.waveTeam && type.isVisible()))))){
             return false;
         }
@@ -256,6 +305,7 @@ public class Build{
     /** Returns whether the tile at this position is breakable by this team */
     public static boolean validBreak(Team team, int x, int y){
         Tile tile = world.tile(x, y);
+        if(AdvanceToolTable.worldCreator && tile.block() != Blocks.air) return true;
         return tile != null && tile.block().canBreak(tile) && tile.breakable() && tile.interactable(team);
     }
 }
diff --git a/core/src/mindustry/world/blocks/ConstructBlock.java b/core/src/mindustry/world/blocks/ConstructBlock.java
index df459ae6d896889fc724b20288dde13bda8adf2f..75147484ca8953117017f07568ab8adb2cdd7e40 100644
--- a/core/src/mindustry/world/blocks/ConstructBlock.java
+++ b/core/src/mindustry/world/blocks/ConstructBlock.java
@@ -5,12 +5,15 @@ import arc.Graphics.*;
 import arc.Graphics.Cursor.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
+import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
 import arc.util.io.*;
 import mindustry.*;
 import mindustry.annotations.Annotations.*;
+import mindustry.arcModule.*;
 import mindustry.content.*;
+import mindustry.core.*;
 import mindustry.entities.*;
 import mindustry.entities.units.*;
 import mindustry.game.EventType.*;
@@ -127,7 +130,7 @@ public class ConstructBlock extends Block{
     static float calcPitch(boolean up){
         if(Time.timeSinceMillis(lastTime) < 16 * 30){
             lastTime = Time.millis();
-            pitchSeq ++;
+            pitchSeq++;
             if(pitchSeq > 30){
                 pitchSeq = 0;
             }
@@ -169,6 +172,43 @@ public class ConstructBlock extends Block{
         private float[] accumulator;
         private float[] totalAccumulator;
 
+        @Override
+        public void drawSelect(){
+            if(team.core() == null){
+                return;
+            }
+
+            // BlockUnit之上
+            Draw.z(Layer.flyingUnit + 0.1f);
+
+            float scl = block.size / 8f / 2f / Scl.scl(1f);
+            float buildHitSize = hitSize();
+
+            // 显示建造进度
+            DrawUtilities.drawText(String.format("%.2f", progress * 100) + "%", scl, x, y + buildHitSize / 2f, Pal.accent, Align.bottom);
+
+            // 显示物品需求
+            float textOffset = 0f;
+            for(int i = 0; i < current.requirements.length; i++){
+                ItemStack stack = current.requirements[i];
+
+                float dx = x - buildHitSize / 2f, dy = y - buildHitSize / 2f + textOffset;
+
+                float consumeAmount = state.rules.buildCostMultiplier * stack.amount;
+                int coreAmount = team.core().items.get(stack.item);
+
+                int investItem = (int)(progress * consumeAmount);
+                int needItem = (int)(consumeAmount) - investItem;
+                boolean hasItem = coreAmount >= needItem;
+
+                textOffset += DrawUtilities.drawText(
+                stack.item.emoji() + (hasItem ? "[#ffd37f]" : "[#e55454]") + investItem + "/" +
+                needItem + "/" +
+                UI.formatAmount(coreAmount),
+                scl, dx, dy, Align.bottomLeft) + 1;
+            }
+        }
+
         @Override
         public String getDisplayName(){
             return Core.bundle.format("block.constructing", current.localizedName);
@@ -247,7 +287,7 @@ public class ConstructBlock extends Block{
 
                     Draw.rect(region, x, y, current.rotate && (noOverrides || current.regionRotated2 == i || current.regionRotated1 == i) ? rotdeg() : 0);
                     Draw.flush();
-                    i ++;
+                    i++;
                 }
 
                 Draw.color();
diff --git a/core/src/mindustry/world/blocks/ItemSelection.java b/core/src/mindustry/world/blocks/ItemSelection.java
index 483ba2813465888e23bbc60bd5bada94d237897c..930cc3cd4585ccaf969f57a59607be5372278e3a 100644
--- a/core/src/mindustry/world/blocks/ItemSelection.java
+++ b/core/src/mindustry/world/blocks/ItemSelection.java
@@ -12,6 +12,7 @@ import mindustry.gen.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.*;
+import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
 
@@ -65,7 +66,7 @@ public class ItemSelection{
 
             Seq<T> list = items.select(u -> (text.isEmpty() || u.localizedName.toLowerCase().contains(text.toLowerCase())));
             for(T item : list){
-                if(!item.unlockedNow() || (item instanceof Item checkVisible && state.rules.hiddenBuildItems.contains(checkVisible)) || item.isHidden()) continue;
+                if(!AdvanceToolTable.allBlocksReveal && (!item.unlockedNow() || (item instanceof Item checkVisible && state.rules.hiddenBuildItems.contains(checkVisible)) || item.isHidden())) continue;
 
                 ImageButton button = cont.button(Tex.whiteui, Styles.clearNoneTogglei, Mathf.clamp(item.selectionSize, 0f, 40f), () -> {
                     if(closeSelect) control.input.config.hideConfig();
diff --git a/core/src/mindustry/world/blocks/defense/ForceProjector.java b/core/src/mindustry/world/blocks/defense/ForceProjector.java
index 5cc4088121fd85ccb4971465494b2f00ee59a878..bd4b0586de82d01df161282c0ae13f889aa90a33 100644
--- a/core/src/mindustry/world/blocks/defense/ForceProjector.java
+++ b/core/src/mindustry/world/blocks/defense/ForceProjector.java
@@ -1,6 +1,7 @@
 package mindustry.world.blocks.defense;
 
 import arc.*;
+import arc.Core;
 import arc.func.*;
 import arc.graphics.*;
 import arc.graphics.g2d.*;
@@ -124,6 +125,9 @@ public class ForceProjector extends Block{
         Draw.color(player.team().color);
         Lines.stroke(1f);
         Lines.poly(x * tilesize + offset, y * tilesize + offset, sides, radius, shieldRotation);
+        Draw.color(player.team().color);
+        Lines.stroke(1f);
+        Lines.poly(x * tilesize + offset, y * tilesize + offset, sides, radius+phaseRadiusBoost, shieldRotation);
         Draw.color();
     }
 
@@ -274,6 +278,22 @@ public class ForceProjector extends Block{
             Draw.reset();
         }
 
+        @Override
+        public void drawBars() {
+            super.drawBars();
+            if (Core.settings.getBool("blockBars_mend") && buildup > 0) {
+                Draw.color(Color.black, 0.3f);
+                Lines.stroke(4f);
+                Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+                        x + block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f);
+                Draw.color(broken ? Pal.remove : Pal.stat, 1f);
+                Lines.stroke(2f);
+                Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+                        x + 0.6f * (0.5f - buildup / (shieldHealth + phaseShieldBoost * phaseHeat)) * block.size * tilesize, y + block.size * tilesize / 2.5f);
+                Draw.color();
+            }
+        }
+
         @Override
         public void write(Writes write){
             super.write(write);
diff --git a/core/src/mindustry/world/blocks/defense/MendProjector.java b/core/src/mindustry/world/blocks/defense/MendProjector.java
index f52a5307bdd8c79fbccb82b7ff74dc856d615edb..0cc77922f40c0886defdb4ee3d6001897f44adad 100644
--- a/core/src/mindustry/world/blocks/defense/MendProjector.java
+++ b/core/src/mindustry/world/blocks/defense/MendProjector.java
@@ -1,5 +1,6 @@
 package mindustry.world.blocks.defense;
 
+import arc.*;
 import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
@@ -21,7 +22,7 @@ import static mindustry.Vars.*;
 public class MendProjector extends Block{
     public final int timerUse = timers++;
     public Color baseColor = Color.valueOf("84f491");
-    public Color phaseColor = baseColor;
+    public Color phaseColor = Color.valueOf("ffd59e");
     public @Load("@-top") TextureRegion topRegion;
     public float reload = 250f;
     public float range = 60f;
@@ -80,6 +81,10 @@ public class MendProjector extends Block{
         
         Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range, baseColor);
 
+        indexer.eachBlock(player.team(), x * tilesize + offset, y * tilesize + offset, range + phaseRangeBoost, other -> true, other -> Drawf.selected(other, Tmp.c1.set(phaseColor).a(Mathf.absin(4f, 1f))));
+
+        Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range + phaseRangeBoost, phaseColor);
+
         indexer.eachBlock(player.team(), x * tilesize + offset, y * tilesize + offset, range, other -> true, other -> Drawf.selected(other, Tmp.c1.set(baseColor).a(Mathf.absin(4f, 1f))));
     }
 
@@ -136,6 +141,15 @@ public class MendProjector extends Block{
         public void draw(){
             super.draw();
 
+            float realRange = range + phaseHeat * phaseRangeBoost;
+            if(status() == BlockStatus.active && (float)Core.settings.getInt("mend_zone") > 2f){
+                if (phaseHeat>0.2){Draw.color(Color.valueOf("00ff55"), (float)Core.settings.getInt("mend_zone") / 100f);}
+                else {Draw.color(Color.valueOf("66ff99"),(float)Core.settings.getInt("mend_zone") / 100f);}
+
+                Lines.dashCircle(x, y, realRange);
+            }
+
+
             float f = 1f - (Time.time / 100f) % 1f;
 
             Draw.color(baseColor, phaseColor, phaseHeat);
@@ -148,6 +162,22 @@ public class MendProjector extends Block{
             Draw.reset();
         }
 
+        @Override
+        public void drawBars() {
+            super.drawBars();
+            if (Core.settings.getBool("blockBars_mend")) {
+                Draw.color(Color.black, 0.3f);
+                Lines.stroke(4f);
+                Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+                        x + block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f);
+                Draw.color(Pal.heal, 1f);
+                Lines.stroke(2f);
+                Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+                        x + 0.6f * (charge / reload - 0.5f) * block.size * tilesize, y + block.size * tilesize / 2.5f);
+                Draw.color();
+            }
+        }
+
         @Override
         public void drawLight(){
             Drawf.light(x, y, lightRadius * smoothEfficiency, baseColor, 0.7f * smoothEfficiency);
diff --git a/core/src/mindustry/world/blocks/defense/OverdriveProjector.java b/core/src/mindustry/world/blocks/defense/OverdriveProjector.java
index 11cd57fb65dcac2eb118cd7d584dd83be20b7c0f..f47ac3f5ecb8f64caf2d1a50910a60fa7cf8c98a 100644
--- a/core/src/mindustry/world/blocks/defense/OverdriveProjector.java
+++ b/core/src/mindustry/world/blocks/defense/OverdriveProjector.java
@@ -1,6 +1,5 @@
 package mindustry.world.blocks.defense;
 
-import arc.*;
 import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
@@ -57,6 +56,12 @@ public class OverdriveProjector extends Block{
         super.drawPlace(x, y, rotation, valid);
 
         Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range, baseColor);
+        if (hasBoost){
+            Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range + phaseRangeBoost, phaseColor);
+
+            indexer.eachBlock(player.team(), x * tilesize + offset, y * tilesize + offset, range + phaseRangeBoost, other -> other.block.canOverdrive, other -> Drawf.selected(other, Tmp.c1.set(phaseColor).a(Mathf.absin(4f, 1f))));
+        }
+
 
         indexer.eachBlock(player.team(), x * tilesize + offset, y * tilesize + offset, range, other -> other.block.canOverdrive, other -> Drawf.selected(other, Tmp.c1.set(baseColor).a(Mathf.absin(4f, 1f))));
     }
diff --git a/core/src/mindustry/world/blocks/defense/turrets/ContinuousLiquidTurret.java b/core/src/mindustry/world/blocks/defense/turrets/ContinuousLiquidTurret.java
index a843a3e98514c9b14d34cdfc72232b84c8b37d45..9cca6b16c4a331e23068e29b5a5b253924947c87 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/ContinuousLiquidTurret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/ContinuousLiquidTurret.java
@@ -1,13 +1,21 @@
 package mindustry.world.blocks.defense.turrets;
 
+import arc.Core;
+import arc.graphics.g2d.Draw;
+import arc.math.Mathf;
 import arc.struct.*;
+import arc.util.Time;
 import mindustry.content.*;
 import mindustry.entities.bullet.*;
 import mindustry.gen.*;
+import mindustry.graphics.Drawf;
+import mindustry.graphics.Pal;
 import mindustry.type.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
 
+import static mindustry.Vars.tilesize;
+
 public class ContinuousLiquidTurret extends ContinuousTurret{
     public ObjectMap<Liquid, BulletType> ammoTypes = new ObjectMap<>();
     public float liquidConsumed = 1f / 60f;
@@ -40,6 +48,32 @@ public class ContinuousLiquidTurret extends ContinuousTurret{
         stats.add(Stat.ammo, StatValues.ammo(ammoTypes));
     }
 
+    @Override
+    public void drawPlace(int x, int y, int rotation, boolean valid){
+        super.drawPlace(x, y, rotation, valid);
+
+        ammoTypes.each((Item, BulletType)->{
+            if(BulletType.rangeChange>0 && Item.unlockedNow()) Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range + BulletType.rangeChange, Pal.placing);
+        });
+
+        if(Core.settings.getBool("arcTurretPlacementItem") && ammoTypes.size>=2) {
+            int sectors = ammoTypes.size;
+            drawIndex = 0;
+            float iconSize = 6f + 2f * size;
+            ammoTypes.each((Item, BulletType) -> {
+                drawIndex += 1;
+                if (!Item.unlockedNow()) return;
+                for (int i = 0; i < 4; i++) {
+                    float rot = (i + ((float)drawIndex) / sectors) / 4 * 360f + Time.time * 0.5f;
+                    Draw.rect(Item.uiIcon,
+                            x * tilesize + offset + (Mathf.sin((float) Math.toRadians(rot)) * (range + BulletType.rangeChange + iconSize + 1f)),
+                            y * tilesize + offset + (Mathf.cos((float) Math.toRadians(rot)) * (range + BulletType.rangeChange + iconSize + 1f)),
+                            iconSize, iconSize, -rot);
+                }
+            });
+        }
+    }
+
     @Override
     public void init(){
         //TODO display ammoMultiplier.
@@ -65,6 +99,39 @@ public class ContinuousLiquidTurret extends ContinuousTurret{
 
     public class ContinuousLiquidTurretBuild extends ContinuousTurretBuild{
 
+        @Override
+        public void drawSelect(){
+            super.drawSelect();
+            if(Core.settings.getBool("arcTurretPlacementItem")){
+                if(liquids.currentAmount()==0){
+                    int sectors = ammoTypes.size;
+                    drawIndex = 0;
+                    float iconSize = 6f + 2f * size;
+                    ammoTypes.each((Item, BulletType) -> {
+                        drawIndex += 1;
+                        if (!Item.unlockedNow()) return;
+                        for (int i = 0; i < 4; i++) {
+                            float rot = (i + ((float)drawIndex) / sectors) / 4 * 360f + Time.time * 0.5f;
+                            Draw.rect(Item.uiIcon,
+                                    x + offset + (Mathf.sin((float) Math.toRadians(rot)) * (range + BulletType.rangeChange + iconSize + 1f)),
+                                    y + offset + (Mathf.cos((float) Math.toRadians(rot)) * (range + BulletType.rangeChange + iconSize + 1f)),
+                                    iconSize, iconSize, -rot);
+                        }
+                    });
+                }
+                else{
+                    float iconSize = 6f + 2f * size;
+                    for (int i = 0; i < 4; i++) {
+                        float rot = i / 4f * 360f + Time.time * 0.5f;
+                        Draw.rect(liquids.current().uiIcon,
+                                x + offset + (Mathf.sin((float) Math.toRadians(rot)) * (range + ammoTypes.get(liquids.current()).rangeChange + iconSize + 1f)),
+                                y + offset + (Mathf.cos((float) Math.toRadians(rot)) * (range + ammoTypes.get(liquids.current()).rangeChange + iconSize + 1f)),
+                                iconSize, iconSize, -rot);
+                    }
+                }
+            }
+        }
+
         @Override
         public boolean shouldActiveSound(){
             return wasShooting && enabled;
diff --git a/core/src/mindustry/world/blocks/defense/turrets/ItemTurret.java b/core/src/mindustry/world/blocks/defense/turrets/ItemTurret.java
index 6afcc7e485654a97f73dc46d3fdc02a4a412c740..f059a2cc9aa80bdb2b7d73d12b8403d5b6db46c8 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/ItemTurret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/ItemTurret.java
@@ -1,9 +1,12 @@
 package mindustry.world.blocks.defense.turrets;
 
 import arc.*;
+import arc.graphics.g2d.Draw;
+import arc.math.Mathf;
 import arc.scene.ui.*;
 import arc.scene.ui.layout.*;
 import arc.struct.*;
+import arc.util.Time;
 import arc.util.io.*;
 import mindustry.*;
 import mindustry.content.*;
@@ -52,6 +55,35 @@ public class ItemTurret extends Turret{
         stats.add(Stat.ammo, StatValues.ammo(ammoTypes));
     }
 
+    @Override
+    public void drawPlace(int x, int y, int rotation, boolean valid) {
+        super.drawPlace(x, y, rotation, valid);
+
+        ammoTypes.each((Item, BulletType) -> {
+            if (!Item.unlockedNow()) return;
+            if (BulletType.rangeChange > 0)
+                Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range + BulletType.rangeChange, Pal.placing);
+
+        });
+
+        if (Core.settings.getBool("arcTurretPlacementItem")) {
+            int sectors = ammoTypes.size;
+            drawIndex = 0;
+            float iconSize = 6f + 2f * size;
+            ammoTypes.each((Item, BulletType) -> {
+                drawIndex += 1;
+                if (!Item.unlockedNow()) return;
+                for (int i = 0; i < 4; i++) {
+                    float rot = (i + ((float) drawIndex) / sectors) / 4 * 360f + Time.time * 0.5f;
+                    Draw.rect(Item.uiIcon,
+                            x * tilesize + offset + (Mathf.sin((float) Math.toRadians(rot)) * (range + BulletType.rangeChange + iconSize + 1f)),
+                            y * tilesize + offset + (Mathf.cos((float) Math.toRadians(rot)) * (range + BulletType.rangeChange + iconSize + 1f)),
+                            iconSize, iconSize, -rot);
+                }
+            });
+        }
+    }
+
     @Override
     public void setBars(){
         super.setBars();
@@ -96,6 +128,43 @@ public class ItemTurret extends Turret{
 
     public class ItemTurretBuild extends TurretBuild{
 
+        @Override
+        public void drawSelect(){
+
+            if(Core.settings.getBool("arcTurretPlacementItem")) {
+                if (ammo.isEmpty()) {
+                    int sectors = ammoTypes.size;
+                    drawIndex = 0;
+                    float iconSize = 6f + 2f * size;
+                    ammoTypes.each((Item, BulletType) -> {
+                        drawIndex += 1;
+                        if (!Item.unlockedNow()) return;
+                        for (int i = 0; i < 4; i++) {
+                            float rot = (i + ((float) drawIndex) / sectors) / 4 * 360f + Time.time * 0.5f;
+                            Draw.rect(Item.uiIcon,
+                                    x + offset + (Mathf.sin((float) Math.toRadians(rot)) * (range + BulletType.rangeChange + iconSize + 1f)),
+                                    y + offset + (Mathf.cos((float) Math.toRadians(rot)) * (range + BulletType.rangeChange + iconSize + 1f)),
+                                    iconSize, iconSize, -rot);
+                        }
+                    });
+                }
+                else{
+                    float iconSize = 6f + 2f * size;
+                    ItemTurret.ItemEntry entry = (ItemTurret.ItemEntry) ammo.peek();
+                    Item lastAmmo = entry.item;
+                    for (int i = 0; i < 4; i++) {
+                        float rot = i / 4f * 360f + Time.time * 0.5f;
+                        Draw.rect(lastAmmo.uiIcon,
+                                x + offset + (Mathf.sin((float) Math.toRadians(rot)) * (range + entry.type().rangeChange + iconSize + 1f)),
+                                y + offset + (Mathf.cos((float) Math.toRadians(rot)) * (range + entry.type().rangeChange + iconSize + 1f)),
+                                iconSize, iconSize, -rot);
+                    }
+                }
+            }
+
+            super.drawSelect();
+        }
+
         @Override
         public void onProximityAdded(){
             super.onProximityAdded();
diff --git a/core/src/mindustry/world/blocks/defense/turrets/LiquidTurret.java b/core/src/mindustry/world/blocks/defense/turrets/LiquidTurret.java
index c0087eee5ff9ece878fb9b7c6bfc88db7da1e92c..fe25f0be215e3b0a88d1a7ddabd1bb2f9eabb241 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/LiquidTurret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/LiquidTurret.java
@@ -1,6 +1,10 @@
 package mindustry.world.blocks.defense.turrets;
 
+import arc.Core;
+import arc.graphics.g2d.Draw;
+import arc.math.Mathf;
 import arc.struct.*;
+import arc.util.Time;
 import mindustry.content.*;
 import mindustry.core.*;
 import mindustry.entities.*;
@@ -58,6 +62,30 @@ public class LiquidTurret extends Turret{
         super.init();
     }
 
+
+    @Override
+    public void drawPlace(int x, int y, int rotation, boolean valid){
+        super.drawPlace(x, y, rotation, valid);
+
+
+        if(Core.settings.getBool("arcTurretPlacementItem") && ammoTypes.size>=2) {
+            int sectors = ammoTypes.size;
+            drawIndex = 0;
+            float iconSize = 6f + 2f * size;
+            ammoTypes.each((Liquid, BulletType) -> {
+                drawIndex += 1;
+                if (!Liquid.unlockedNow()) return;
+                for (int i = 0; i < 4; i++) {
+                    float rot = (i + ((float)drawIndex) / sectors) / 4 * 360f + Time.time * 0.5f;
+                    Draw.rect(Liquid.uiIcon,
+                            x * tilesize + offset + (Mathf.sin((float) Math.toRadians(rot)) * (range + BulletType.rangeChange + iconSize + 1f)),
+                            y * tilesize + offset + (Mathf.cos((float) Math.toRadians(rot)) * (range + BulletType.rangeChange + iconSize + 1f)),
+                            iconSize, iconSize, -rot);
+                }
+            });
+        }
+    }
+
     public class LiquidTurretBuild extends TurretBuild{
 
         @Override
diff --git a/core/src/mindustry/world/blocks/defense/turrets/PowerTurret.java b/core/src/mindustry/world/blocks/defense/turrets/PowerTurret.java
index d18db6208c5e63b525452c38a6038ddc42e60fa0..6c086ef8357442a865f593f4521838017ac4ed55 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/PowerTurret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/PowerTurret.java
@@ -1,10 +1,17 @@
 package mindustry.world.blocks.defense.turrets;
 
+import arc.Core;
+import arc.graphics.g2d.Draw;
+import arc.math.Mathf;
 import arc.struct.*;
+import arc.util.Time;
 import mindustry.entities.bullet.*;
+import mindustry.gen.Icon;
 import mindustry.logic.*;
 import mindustry.world.meta.*;
 
+import static mindustry.Vars.tilesize;
+
 public class PowerTurret extends Turret{
     public BulletType shootType;
 
@@ -19,6 +26,23 @@ public class PowerTurret extends Turret{
         stats.add(Stat.ammo, StatValues.ammo(ObjectMap.of(this, shootType)));
     }
 
+    @Override
+    public void drawPlace(int x, int y, int rotation, boolean valid){
+        super.drawPlace(x, y, rotation, valid);
+
+
+        if(Core.settings.getBool("arcTurretPlacementItem")) {
+            float iconSize = 6f + 2f * size;
+            for (int i = 0; i < 4; i++) {
+                float  rot = i / 4f * 360f + Time.time * 0.5f;
+                Draw.rect(Icon.power.getRegion(),
+                        x * tilesize + offset + (Mathf.sin((float) Math.toRadians(rot)) * (range + 4f)),
+                        y * tilesize + offset + (Mathf.cos((float) Math.toRadians(rot)) * (range + 4f)),
+                        iconSize, iconSize, -rot);
+            }
+        }
+    }
+
     public void limitRange(float margin){
         limitRange(shootType, margin);
     }
diff --git a/core/src/mindustry/world/blocks/defense/turrets/ReloadTurret.java b/core/src/mindustry/world/blocks/defense/turrets/ReloadTurret.java
index 5bf13c7c91cfdb7dbda1dc5ea321bc43e0d7ca00..13ea4c90ac08c1219c108bd6604f228267fc0de1 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/ReloadTurret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/ReloadTurret.java
@@ -1,6 +1,10 @@
 package mindustry.world.blocks.defense.turrets;
 
+import arc.Core;
 import arc.math.*;
+import arc.scene.ui.layout.Table;
+import mindustry.graphics.Pal;
+import mindustry.ui.Bar;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
 
@@ -42,5 +46,14 @@ public class ReloadTurret extends BaseTurret{
         protected float baseReloadSpeed(){
             return efficiency;
         }
+
+        @Override
+        public void displayBars(Table bars){
+            super.displayBars(bars);
+            //bar for shoot cd
+            bars.add(new Bar(() -> Core.bundle.format("stat.reloadDetail", (int)(reloadCounter * 100 / reload)), () -> Pal.ammo, () -> (float)(reloadCounter / reload)));
+            bars.row();
+        }
+
     }
 }
diff --git a/core/src/mindustry/world/blocks/defense/turrets/Turret.java b/core/src/mindustry/world/blocks/defense/turrets/Turret.java
index f6866128bc39fdbf40d8e1b853ecc533ab5b9880..463b9be3f582042951ad0b56f9a2e37c0c9e610c 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/Turret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/Turret.java
@@ -7,6 +7,7 @@ import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
 import arc.math.geom.*;
+import arc.scene.ui.layout.Table;
 import arc.struct.*;
 import arc.util.*;
 import arc.util.io.*;
@@ -129,6 +130,8 @@ public class Turret extends ReloadTurret{
     public float elevation = -1f;
     /** How much the screen shakes per shot. */
     public float shake = 0f;
+    /** arc绘图用 */
+    public int drawIndex = 0;
 
     /** Defines drawing behavior for this turret. */
     public DrawBlock drawer = new DrawTurret();
@@ -356,6 +359,18 @@ public class Turret extends ReloadTurret{
             drawer.draw(this);
         }
 
+        //show shoot target line
+        @Override
+        public void drawSelect(){
+            super.drawSelect();
+            if(targetPos.x != 0 && targetPos.y !=0 && Mathf.dst(targetPos.x,targetPos.y)<5e5){
+                Lines.stroke(1f);
+                Lines.dashLine(x, y, targetPos.x, targetPos.y, (int)(Mathf.len(targetPos.x - x, targetPos.y - y) / 8));
+                Lines.dashCircle(targetPos.x, targetPos.y, 8);
+                Draw.reset();
+            }
+        }
+
         @Override
         public void updateTile(){
             if(!validateTarget()) target = null;
@@ -652,6 +667,14 @@ public class Turret extends ReloadTurret{
         public byte version(){
             return 1;
         }
+
+        @Override
+        public void displayBars(Table bars) {
+            super.displayBars(bars);
+            if (minWarmup > 0f) {
+                bars.add(new Bar(() -> Core.bundle.format("stat.warmupDetail", (int)(shootWarmup * 100 / minWarmup)), () -> Pal.ammo, () -> shootWarmup / minWarmup)).row();
+            }
+        }
     }
 
     public static class BulletEntry{
diff --git a/core/src/mindustry/world/blocks/distribution/Conveyor.java b/core/src/mindustry/world/blocks/distribution/Conveyor.java
index bcbecc3f921245e1418caddabd66af699b10043e..ede7e1f2691bb508d9da8220fde42e0ff73eb9f3 100644
--- a/core/src/mindustry/world/blocks/distribution/Conveyor.java
+++ b/core/src/mindustry/world/blocks/distribution/Conveyor.java
@@ -92,7 +92,7 @@ public class Conveyor extends Block implements Autotiler{
     public void handlePlacementLine(Seq<BuildPlan> plans){
         if(bridgeReplacement == null) return;
 
-        Placement.calculateBridges(plans, (ItemBridge)bridgeReplacement);
+        Placement.calculateBridges(plans, (ItemBridge)bridgeReplacement, b -> b instanceof Conveyor);
     }
 
     @Override
diff --git a/core/src/mindustry/world/blocks/distribution/DirectionBridge.java b/core/src/mindustry/world/blocks/distribution/DirectionBridge.java
index 97e38584f76623663502861f13cc151c068a87e4..ddeb2bb58ac066ebaea37d03bc0b80ef2e32eb28 100644
--- a/core/src/mindustry/world/blocks/distribution/DirectionBridge.java
+++ b/core/src/mindustry/world/blocks/distribution/DirectionBridge.java
@@ -214,5 +214,13 @@ public class DirectionBridge extends Block{
             }
             return null;
         }
+
+        public boolean arcCheckAccept(Building source) {
+            //only accept if there's an output point.
+            if(findLink() == null) return false;
+
+            int rel = this.relativeToEdge(source.tile);
+            return rel != rotation && occupied[(rel + 2) % 4] == null;
+        }
     }
 }
diff --git a/core/src/mindustry/world/blocks/distribution/ItemBridge.java b/core/src/mindustry/world/blocks/distribution/ItemBridge.java
index 6a5b43c0bd6edf7ad162ae97f289dad6fc826dcc..e2af9155cd68a731517c954829e18bb52647297b 100644
--- a/core/src/mindustry/world/blocks/distribution/ItemBridge.java
+++ b/core/src/mindustry/world/blocks/distribution/ItemBridge.java
@@ -520,5 +520,17 @@ public class ItemBridge extends Block{
                 wasMoved = moved = read.bool();
             }
         }
+
+        public boolean arcLinkValid() {
+            return linkValid(this.tile, world.tile(link));
+        }
+
+        public boolean arcCheckDump(Building to){
+            return checkDump(to);
+        }
+
+        public boolean arcCheckAccept(Building source) {
+            return checkAccept(source, world.tile(link));
+        }
     }
 }
diff --git a/core/src/mindustry/world/blocks/distribution/MassDriver.java b/core/src/mindustry/world/blocks/distribution/MassDriver.java
index 636641924280a51603b22a7b5d777a3100d21b24..63bb7cb893d39237ad37486605280afe90f25989 100644
--- a/core/src/mindustry/world/blocks/distribution/MassDriver.java
+++ b/core/src/mindustry/world/blocks/distribution/MassDriver.java
@@ -1,6 +1,8 @@
 package mindustry.world.blocks.distribution;
 
+import arc.*;
 import arc.audio.*;
+import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
 import arc.math.geom.*;
@@ -225,6 +227,35 @@ public class MassDriver extends Block{
             Draw.rect(region,
             x + Angles.trnsx(rotation + 180f, reloadCounter * knockback),
             y + Angles.trnsy(rotation + 180f, reloadCounter * knockback), rotation - 90);
+
+            float sin = Mathf.absin(Time.time, 6f, 1f);
+            Draw.z(Layer.effect);
+            if (Core.settings.getInt("mass_driver_line_alpha")>=2f){
+                for(var shooter : waitingShooters){
+                    Lines.stroke(2f, Pal.placing);
+
+                    float alpha = Core.settings.getInt("mass_driver_line_alpha") / 100f;
+                    Draw.alpha(alpha);
+                    Drawf.dashLine(getmass_driver_line_color(),shooter.x, shooter.y, x, y);
+                    Draw.alpha(alpha);
+                    Drawf.arrow(shooter.x, shooter.y, x, y, size * tilesize + sin, 4f + sin, Pal.place);
+                    float shooter_length = Mathf.dst(shooter.x, shooter.y, x, y);
+                    float shooter_angle = (float) Math.acos((x-shooter.x)/shooter_length);
+                    float reverty = 1f;
+                    if (y<shooter.y) {reverty=-1;}
+                    float mass_driver_line_interval = (float)Core.settings.getInt("mass_driver_line_interval");
+                    float slice = shooter_length / mass_driver_line_interval -1f;
+                    if (slice>1){
+                        for (int slicer = 1; slicer < slice; slicer++) {
+                            Draw.alpha(alpha);
+                            Drawf.arrow(shooter.x + mass_driver_line_interval*Mathf.cos(shooter_angle)*slicer, shooter.y + mass_driver_line_interval*Mathf.sin(shooter_angle)*slicer*reverty, x, y, size * tilesize + sin, 4f + sin, Pal.place);
+                          }
+                    }
+
+            }
+
+            }
+
         }
 
         @Override
@@ -329,6 +360,10 @@ public class MassDriver extends Block{
             return other instanceof MassDriverBuild entity && other.isValid() && other.efficiency > 0 && entity.block == block && entity.link == pos() && within(other, range);
         }
 
+        public boolean arcLinkValid(){
+            return linkValid();
+        }
+
         protected boolean linkValid(){
             if(link == -1) return false;
             return world.build(this.link) instanceof MassDriverBuild other && other.block == block && other.team == team && within(other, range);
@@ -364,4 +399,17 @@ public class MassDriver extends Block{
 
         public static final DriverState[] all = values();
     }
+
+    public static Color getmass_driver_line_color(){
+        String color = Core.settings.getString("mass_driver_line_color");
+        if(color != null && color.length() == 6){
+            for (char c : color.toCharArray()) {
+                if (!Character.isDigit(c) && (!Character.isLetter(c) || (Character.toLowerCase(c) - 'a' > 'f' - 'a'))) {
+                    return Color.valueOf("ff8c66");
+                }
+            }
+            return Color.valueOf(color);
+        }
+        return Color.valueOf("ff8c66");
+    }
 }
diff --git a/core/src/mindustry/world/blocks/liquid/Conduit.java b/core/src/mindustry/world/blocks/liquid/Conduit.java
index 06b44c3ae41071195d9eb8404161ff55e31de1f9..64f1b02ac4e91f50ecb3e9a9219c5d9b35fcae87 100644
--- a/core/src/mindustry/world/blocks/liquid/Conduit.java
+++ b/core/src/mindustry/world/blocks/liquid/Conduit.java
@@ -140,7 +140,7 @@ public class Conduit extends LiquidBlock implements Autotiler{
         if(rotBridgeReplacement instanceof DirectionBridge duct){
             Placement.calculateBridges(plans, duct, true, b -> b instanceof Conduit);
         }else{
-            Placement.calculateBridges(plans, (ItemBridge)bridgeReplacement);
+            Placement.calculateBridges(plans, (ItemBridge)bridgeReplacement, b -> b instanceof Conduit);
         }
     }
 
diff --git a/core/src/mindustry/world/blocks/logic/LogicBlock.java b/core/src/mindustry/world/blocks/logic/LogicBlock.java
index 6f9a06a92dd76d03a2078d143d5a20d3223b478c..8ebac709f69d844e8e2d93b1eb0f37d08eccbabd 100644
--- a/core/src/mindustry/world/blocks/logic/LogicBlock.java
+++ b/core/src/mindustry/world/blocks/logic/LogicBlock.java
@@ -4,15 +4,19 @@ import arc.*;
 import arc.Graphics.*;
 import arc.Graphics.Cursor.*;
 import arc.func.*;
+import arc.graphics.Color;
 import arc.math.*;
 import arc.math.geom.*;
+import arc.scene.ui.Label;
 import arc.scene.ui.layout.*;
 import arc.struct.Bits;
 import arc.struct.*;
 import arc.util.*;
 import arc.util.io.*;
 import mindustry.ai.types.*;
+import mindustry.arcModule.ARCVars;
 import mindustry.core.*;
+import mindustry.game.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
 import mindustry.io.*;
@@ -31,6 +35,8 @@ import java.io.*;
 import java.util.zip.*;
 
 import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
+import static mindustry.logic.LogicDialog.*;
 
 public class LogicBlock extends Block{
     @MindustryXApi
@@ -97,7 +103,8 @@ public class LogicBlock extends Block{
     }
 
     public boolean accessible(){
-        return !privileged || state.rules.editor || state.playtestingMap != null;
+        //return !privileged || state.rules.editor|| state.playtestingMap != null;
+        return !privileged || state.rules.editor|| state.playtestingMap != null || ARCVars.arcInfoControl(Team.derelict);
     }
 
     @Override
@@ -240,6 +247,14 @@ public class LogicBlock extends Block{
         //dynamic only for privileged processors
         public int ipt = instructionsPerTick;
 
+        Table settingTable = new Table();
+        boolean showSettingTable = false;
+        boolean showContent = false;
+
+        float counter = 0f;
+
+        boolean linkSimplify = false;
+
         /** Block of code to run after load. */
         public @Nullable Runnable loadBlock;
 
@@ -563,10 +578,12 @@ public class LogicBlock extends Block{
             }
 
             //draw top text on separate layer
+            //draw link order
+            int i = 0;
             for(LogicLink l : links){
                 Building build = world.build(l.x, l.y);
                 if(l.active && validLink(build)){
-                    build.block.drawPlaceText(l.name, build.tileX(), build.tileY(), true);
+                    build.block.drawPlaceText(linkSimplify ? i++ + "" : l.name + "[" + i++ + "]", build.tileX(), build.tileY(), true);
                 }
             }
         }
@@ -582,6 +599,61 @@ public class LogicBlock extends Block{
             return other != null && other.isValid() && (privileged || (!other.block.privileged && other.team == team && other.within(this, range + other.block.size*tilesize/2f))) && !(other instanceof ConstructBuild);
         }
 
+        private void rebuildSettingTable() {
+            settingTable.clear();
+            if (!showSettingTable) return;
+            settingTable.setColor(Color.lightGray);
+            settingTable.update(() -> {
+                counter += Time.delta;
+                if (counter > period && refreshing) {
+                    counter = 0;
+                }
+            });
+            settingTable.table(t -> {
+                t.button(Icon.copy, Styles.cleari, () -> {
+                    Core.app.setClipboardText(code);
+                    arcui.arcInfo("已复制逻辑");
+                }).size(40);
+                t.button(Icon.download, Styles.cleari, () -> {
+                    updateCode(Core.app.getClipboardText().replace("\r\n", "\n"));
+                    arcui.arcInfo("已导入逻辑(仅单机生效)");
+                }).size(40);
+                t.button(Icon.trash, Styles.cleari, () -> {
+                    code = "";
+                    updateCode(code);
+                    arcui.arcInfo("已清除逻辑(仅单机生效)");
+                }).size(40);
+                t.button(Icon.chatSmall, Styles.cleari, () -> {
+                    linkSimplify = !linkSimplify;
+                    arcui.arcInfo(linkSimplify ? "仅显示linkindex" : "显示方块名和linkindex");
+                }).size(40);
+                t.button(Icon.info, Styles.cleari, () -> {
+                    showContent = !showContent;
+                    rebuildSettingTable();
+                }).size(40);
+            });
+            if (showContent && !code.isEmpty()) {
+                settingTable.row();
+                settingTable.pane(t -> {
+                    for (var s : executor.vars) {
+                        if(s.name.startsWith("___")) continue;
+                        String text = arcVarsText(s);
+                        t.table(tt -> {
+                            tt.labelWrap(s.name + "").color(arcVarsColor(s)).width(100f);
+                            Label label = tt.labelWrap(" : " + text).width(200f).get();
+                            tt.update(() -> {
+                                if (counter + Time.delta > period && refreshing) {
+                                    label.setText(arcVarsText(s));
+                                }
+                            });
+                        });
+                        t.row();
+                    }
+                }).maxHeight(400f);
+
+            }
+        }
+
         @Override
         public boolean shouldShowConfigure(Player player){
             return accessible();
@@ -589,9 +661,23 @@ public class LogicBlock extends Block{
 
         @Override
         public void buildConfiguration(Table table){
-            table.button(Icon.pencil, Styles.cleari, () -> {
-                ui.logic.show(code, executor, privileged, code -> configure(compress(code, relativeConnections())));
-            }).size(40);
+            if (Core.settings.getBool("logicSupport")){
+                table.table(t -> {
+                    t.button(Icon.pencil, Styles.cleari, () -> {
+                        ui.logic.show(code, executor, privileged, code -> configure(compress(code, relativeConnections())));
+                    }).size(40);
+                    t.button(Icon.settings, Styles.cleari, () -> {
+                        showSettingTable = !showSettingTable;
+                        rebuildSettingTable();
+                    }).size(40);
+                });
+            }else{
+                table.button(Icon.pencil, Styles.cleari, () -> {
+                    ui.logic.show(code, executor, privileged, code -> configure(compress(code, relativeConnections())));
+                }).size(40);
+            }
+            table.row();
+            table.add(settingTable);
         }
 
         @Override
diff --git a/core/src/mindustry/world/blocks/logic/MemoryBlock.java b/core/src/mindustry/world/blocks/logic/MemoryBlock.java
index 37a6c2af615665c5179c6df5d57e053a07ce4c72..daae7aabba8340291ad58178dd53af1a6bf1a873 100644
--- a/core/src/mindustry/world/blocks/logic/MemoryBlock.java
+++ b/core/src/mindustry/world/blocks/logic/MemoryBlock.java
@@ -1,15 +1,29 @@
 package mindustry.world.blocks.logic;
 
+import arc.Core;
+import arc.graphics.Color;
+import arc.scene.event.Touchable;
+import arc.scene.ui.Label;
+import arc.scene.ui.layout.Table;
+import arc.util.Time;
 import arc.util.io.*;
 import mindustry.gen.*;
+import mindustry.ui.Styles;
 import mindustry.world.*;
 import mindustry.world.meta.*;
 
 import static mindustry.Vars.*;
+import static mindustry.arcModule.ARCVars.arcui;
 
 public class MemoryBlock extends Block{
     public int memoryCapacity = 32;
 
+    boolean showInfo = false;
+    int numPerRow = 10;
+    int period = 15;
+
+    Table infoTable = new Table();
+
     public MemoryBlock(String name){
         super(name);
         destructible = true;
@@ -18,6 +32,7 @@ public class MemoryBlock extends Block{
         drawDisabled = false;
         envEnabled = Env.any;
         canOverdrive = false;
+        configurable = true;
     }
 
     @Override
@@ -38,6 +53,8 @@ public class MemoryBlock extends Block{
 
     public class MemoryBuild extends Building{
         public double[] memory = new double[memoryCapacity];
+        float counter = 0f;
+        int deci = -1;
 
         //massive byte size means picking up causes sync issues
         @Override
@@ -71,6 +88,96 @@ public class MemoryBlock extends Block{
             }
         }
 
+        @Override
+        public void buildConfiguration(Table table){
+            if(!Core.settings.getBool("showOtherTeamState") && !accessible()){
+                //go away
+                deselect();
+                return;
+            }
+
+            rebuildInfo();
+            table.add(infoTable);
+        }
+
+        private void rebuildInfo(){
+            infoTable.clear();
+            if(!showInfo){
+                infoTable.button(Icon.pencil, Styles.cleari, () -> {
+                    showInfo = !showInfo;
+                    rebuildInfo();
+                }).size(40);
+                return;
+            }
+            infoTable.update(()->{
+                counter+= Time.delta;
+                if(counter>period){
+                    counter=0;
+                }
+            });
+            infoTable.setColor(Color.lightGray);
+            infoTable.table(t->{
+                t.button(Icon.pencil, Styles.cleari, () -> {
+                    showInfo = !showInfo;
+                    rebuildInfo();
+                }).size(40);
+                t.button(Icon.refreshSmall,Styles.cleari,()->{
+                    rebuildInfo();
+                    arcui.arcInfo("已更新内存元！");
+                }).size(40);
+
+                Label rowNum = t.add("每行 "+numPerRow).get();
+                t.slider(2, 15,1, numPerRow, res -> {
+                    numPerRow = (int)res;
+                    rowNum.setText("每行 "+numPerRow);
+                });
+
+                Label deciL = t.add(deci==-1?"不约化":("约化 "+deci)).get();
+                t.slider(-1, 15,1, deci, res -> {
+                    deci = (int)res;
+                    deciL.setText(deci==-1?"不约化":("约化 "+deci));
+                });
+
+                Label refresh = t.add("刷新 "+period).get();
+                t.slider(1, 60,1, 20, res -> {
+                    period = (int)res;
+                    refresh.setText("刷新 "+period);
+                });
+            });
+            infoTable.row();
+            infoTable.pane(t->{
+                int index = 0;
+                for(double v : memory){
+                    Label textR = t.add(index + " ").get();
+                    int finalIndex = index;
+
+                    t.table(tt->{
+                        Label text = tt.add(showString(memory[finalIndex])).get();
+                        tt.update(()->{
+                            if(counter + Time.delta>period){
+                                textR.setText((memory[finalIndex]==0?"[gray]":"") + finalIndex + " ");
+                                text.setText(showString(memory[finalIndex]));
+                            }
+                        });
+                        tt.touchable = Touchable.enabled;
+                        tt.tapped(()->{
+                            Core.app.setClipboardText(memory[finalIndex]+"");
+                            arcui.arcInfo("[cyan]复制内存[white]\n " + memory[finalIndex]);
+                        });
+                    });
+                    index+=1;
+                    if(index % numPerRow==0) t.row();
+                    else t.add(" " + ((index % numPerRow) % 2 == 0?"[cyan]":"[acid]") + "|[white] ");
+                }
+            }).maxWidth(1000f).maxHeight(500f);
+        }
+
+        public String showString(double number){
+            if(number == 0) return "[gray]-";
+            else if(deci == 0 || number == (int)number) return "[orange]" + (int)number + "";
+            if(deci == -1) return "[orange]" + number + "";
+            else return "[orange]" + String.format("%." + deci + "f", number) + "";
+        }
         @Override
         public void read(Reads read, byte revision){
             super.read(read, revision);
diff --git a/core/src/mindustry/world/blocks/power/PowerGraph.java b/core/src/mindustry/world/blocks/power/PowerGraph.java
index 563af123453c8f3c11a3aacabfe77a6460d14fbd..4818ab977c238ae1568555c620aa3797f526f4c5 100644
--- a/core/src/mindustry/world/blocks/power/PowerGraph.java
+++ b/core/src/mindustry/world/blocks/power/PowerGraph.java
@@ -5,6 +5,7 @@ import arc.struct.*;
 import arc.util.*;
 import mindustry.gen.*;
 import mindustry.world.consumers.*;
+import mindustry.game.Team;
 
 public class PowerGraph{
     private static final Queue<Building> queue = new Queue<>();
@@ -22,6 +23,7 @@ public class PowerGraph{
     private final WindowedMean powerBalance = new WindowedMean(60);
     private float lastPowerProduced, lastPowerNeeded, lastPowerStored;
     private float lastScaledPowerIn, lastScaledPowerOut, lastCapacity;
+    public Team team;
     //diodes workaround for correct energy production info
     private float energyDelta = 0f;
 
@@ -215,6 +217,7 @@ public class PowerGraph{
     }
 
     public void update(){
+        team = all.size == 0 ? null : all.first().team;
         if(!consumers.isEmpty() && consumers.first().cheating()){
             //when cheating, just set status to 1
             for(Building tile : consumers){
diff --git a/core/src/mindustry/world/blocks/production/Drill.java b/core/src/mindustry/world/blocks/production/Drill.java
index 48fc9ec8be0701be3babcc14943383b7afd6f8f7..018bed4506df50ebecc2f158c4aec84deaf0abc3 100644
--- a/core/src/mindustry/world/blocks/production/Drill.java
+++ b/core/src/mindustry/world/blocks/production/Drill.java
@@ -18,7 +18,6 @@ import mindustry.logic.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.*;
-import mindustry.world.blocks.environment.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
 import mindustryX.features.*;
@@ -146,12 +145,22 @@ public class Drill extends Block{
         countOre(tile);
 
         if(returnItem != null){
-            float width = drawPlaceText(Core.bundle.formatFloat("bar.drillspeed", 60f / getDrillTime(returnItem) * returnCount, 2), x, y, valid);
+            float speed = 60f / getDrillTime(returnItem) * returnCount;
+            float width;
+            if (liquidBoostIntensity > 1) {
+                width = drawPurePlaceText(Iconc.production + " []" + returnItem.emoji()+ returnItem.localizedName + " [stat]" +
+                                        Strings.autoFixed(speed, 2) + "[white]([cyan]" +
+                                        Strings.autoFixed(speed * liquidBoostIntensity * liquidBoostIntensity, 2) + "[white])", x, y, valid);
+            }
+            else {
+                width = drawPurePlaceText(Iconc.production + " " + returnItem.emoji() + "[stat]"+ returnItem.localizedName + " " + Strings.autoFixed(speed, 2), x, y, valid);
+            }
             float dx = x * tilesize + offset - width/2f - 4f, dy = y * tilesize + offset + size * tilesize / 2f + 5, s = iconSmall / 4f;
+            /*
             Draw.mixcol(Color.darkGray, 1f);
             Draw.rect(returnItem.fullIcon, dx, dy - 1, s, s);
             Draw.reset();
-            Draw.rect(returnItem.fullIcon, dx, dy, s, s);
+            Draw.rect(returnItem.fullIcon, dx, dy, s, s);*/
 
             if(drawMineItem){
                 Draw.color(returnItem.color);
@@ -162,7 +171,10 @@ public class Drill extends Block{
             Tile to = tile.getLinkedTilesAs(this, tempTiles).find(t -> t.drop() != null && (t.drop().hardness > tier || t.drop() == blockedItem));
             Item item = to == null ? null : to.drop();
             if(item != null){
-                drawPlaceText(Core.bundle.get("bar.drilltierreq"), x, y, valid);
+                if (item == blockedItem) {
+                    drawPlaceText(Core.bundle.format("bar.drillcantmine"), x, y, valid);
+                }
+                else drawPlaceText(Core.bundle.format("bar.drilltierreq", item.hardness, tier), x, y, valid);
             }
         }
     }
@@ -192,6 +204,11 @@ public class Drill extends Block{
         return new TextureRegion[]{region, rotatorRegion, topRegion};
     }
 
+    public int countOreArc(Tile tile){
+        countOre(tile);
+        return returnCount;
+    }
+
     protected void countOre(Tile tile){
         returnItem = null;
         returnCount = 0;
@@ -257,7 +274,7 @@ public class Drill extends Block{
 
         @Override
         public void drawSelect(){
-            if(dominantItem != null){
+            if(!Core.settings.getBool("arcdrillmode") && dominantItem != null){
                 float dx = x - size * tilesize/2f, dy = y + size * tilesize/2f, s = iconSmall / 4f;
                 Draw.mixcol(Color.darkGray, 1f);
                 Draw.rect(dominantItem.fullIcon, dx, dy - 1, s, s);
@@ -374,6 +391,21 @@ public class Drill extends Block{
                 Draw.rect(itemRegion, x, y);
                 Draw.color();
             }
+            if(Core.settings.getBool("arcdrillmode") && dominantItem != null){
+                float dx = x - size * tilesize/2f + 5, dy = y - size * tilesize/2f + 5;
+                float iconSize = 5f;
+                Draw.rect(dominantItem.fullIcon, dx, dy, iconSize, iconSize);
+                Draw.reset();
+
+                float eff = Mathf.lerp(0,1,Math.min(1f, (float)dominantItems/(size * size)));
+                if (eff<0.9f){
+                    Draw.alpha(0.5f);
+                    Draw.color(dominantItem.color);
+                    Lines.stroke(1f);
+                    Lines.arc(dx, dy, iconSize * 0.75f, eff);
+                }
+
+            }
         }
 
         @Override
diff --git a/core/src/mindustry/world/blocks/production/GenericCrafter.java b/core/src/mindustry/world/blocks/production/GenericCrafter.java
index 7e3645814d96cd2497332bbfcb2c9d286bbed5b0..d9929146c4f121301e2e5dd48c4360357c788c31 100644
--- a/core/src/mindustry/world/blocks/production/GenericCrafter.java
+++ b/core/src/mindustry/world/blocks/production/GenericCrafter.java
@@ -1,5 +1,8 @@
 package mindustry.world.blocks.production;
 
+
+import arc.*;
+import arc.scene.ui.layout.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
 import arc.math.geom.*;
@@ -12,6 +15,8 @@ import mindustry.entities.units.*;
 import mindustry.gen.*;
 import mindustry.logic.*;
 import mindustry.type.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
 import mindustry.world.*;
 import mindustry.world.draw.*;
 import mindustry.world.meta.*;
@@ -348,5 +353,29 @@ public class GenericCrafter extends Block{
             warmup = read.f();
             if(legacyReadWarmup) read.f();
         }
+
+        @Override
+        public void displayBars(Table bars){
+            super.displayBars(bars);
+            //bar for shoot cd
+            bars.add(new Bar(() -> Iconc.crafting + " " + Strings.fixed(progress * 100f, 0)  + " %" + Calwavetimeremain(progress,getProgressIncrease(craftTime)*timeScale*60 / Time.delta),
+                    () -> Pal.ammo, () -> progress));
+            bars.row();
+        }
+    }
+    private String Calwavetimeremain(float progress,float ProgressIncrease){
+        if(ProgressIncrease == 0f || 1 / ProgressIncrease < 240f){
+            return "";
+        }
+        float time = (1-progress)/ProgressIncrease;
+
+        String wavetimeremain = " [orange]~";
+        int m = ((int)time) / 60;
+        if (m==0){
+            return "";
+        }
+        wavetimeremain += String.valueOf(m) ;
+        wavetimeremain += "min";
+        return wavetimeremain;
     }
 }
diff --git a/core/src/mindustry/world/blocks/storage/CoreBlock.java b/core/src/mindustry/world/blocks/storage/CoreBlock.java
index a7199929351d4ec311ba34d81b3b0e2601ad04fe..22a95dcbb5642659b98096de45f33ac09067d16c 100644
--- a/core/src/mindustry/world/blocks/storage/CoreBlock.java
+++ b/core/src/mindustry/world/blocks/storage/CoreBlock.java
@@ -76,6 +76,7 @@ public class CoreBlock extends StorageBlock{
         player.set(core);
 
         if(!net.client()){
+            player.team(tile.team());
             Unit unit = spawnType.create(tile.team());
             unit.set(core);
             unit.rotation(90f);
@@ -566,6 +567,14 @@ public class CoreBlock extends StorageBlock{
                 outline.get(core);
                 core.proximity.each(storage -> storage.items == items, outline);
             });
+            if(state.isCampaign()){
+                Draw.z(Layer.blockOver);
+                float t = turnDuration - Universe.turnCounter;
+                String min = Strings.fixed(Mathf.floor(t / 60f / 60f), 0);
+                float s = Mathf.floor(t / 60f % 60f);
+                String sec = (s < 10f ? "0" : "") + Strings.fixed(s, 0);
+                drawPlaceText(("资源接收  "+ min+":"+sec), tileX(), tileY(), true);
+            }
             Draw.reset();
         }
 
diff --git a/core/src/mindustry/world/blocks/units/Reconstructor.java b/core/src/mindustry/world/blocks/units/Reconstructor.java
index 9d93309425be6b6d00cfd8a1b042596053b86c94..68d1d0ff03464099b5b9ec60ece40ec197226e8e 100644
--- a/core/src/mindustry/world/blocks/units/Reconstructor.java
+++ b/core/src/mindustry/world/blocks/units/Reconstructor.java
@@ -1,6 +1,7 @@
 package mindustry.world.blocks.units;
 
 import arc.*;
+import arc.graphics.*;
 import arc.Graphics.*;
 import arc.Graphics.Cursor.*;
 import arc.graphics.g2d.*;
@@ -292,6 +293,21 @@ public class Reconstructor extends UnitBlock{
             return super.senseObject(sensor);
         }
 
+        @Override
+        public void drawBars(){
+            super.drawBars();
+            Draw.color(Color.black, 0.3f);
+            Lines.stroke(4f);
+            Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+                x + block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f);
+            Draw.color(Pal.accent, 1f);
+            Lines.stroke(2f);
+            Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+                x + 0.6f * (Mathf.clamp(fraction(), 0f, 1f) - 0.5f) * block.size * tilesize, y + block.size * tilesize / 2.5f);
+            Draw.color();
+            block.drawText((int)(Mathf.clamp(fraction(), 0f, 1f) * 100) + "% | " + Strings.fixed((constructTime - progress) / (60f * Vars.state.rules.unitBuildSpeed(team) * timeScale), 0), x, y + block.size * tilesize / 2.5f - 5f, true, 0.9f);
+        }
+
         @Override
         public void updateTile(){
             boolean valid = false;
diff --git a/core/src/mindustry/world/blocks/units/UnitAssembler.java b/core/src/mindustry/world/blocks/units/UnitAssembler.java
index 351979d9765286df62c0fded42b8d5c242ebafba..e2a773bb9dab071f78f74399e976c04ea0b28051 100644
--- a/core/src/mindustry/world/blocks/units/UnitAssembler.java
+++ b/core/src/mindustry/world/blocks/units/UnitAssembler.java
@@ -461,6 +461,22 @@ public class UnitAssembler extends PayloadBlock{
             blocks.clear();
         }
 
+        @Override
+        public void drawBars(){
+            super.drawBars();
+            Draw.color(Color.black, 0.3f);
+            Lines.stroke(4f);
+            Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+                    x + block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f);
+            Draw.color(Pal.accent, 1f);
+            Lines.stroke(2f);
+            Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+                    x + 0.6f * (Mathf.clamp(progress, 0f, 1f) - 0.5f) * block.size * tilesize, y + block.size * tilesize / 2.5f);
+            Draw.color();
+
+            block.drawText((int)(progress * 100) + "%" + " | " +Strings.fixed((plan().time * (1-progress))/(60f * Vars.state.rules.unitBuildSpeed(team) * timeScale()),0) +  " s", x, y + block.size * tilesize / 2.5f - 5f, true, 0.9f);
+        }
+
         @Override
         public void draw(){
             Draw.rect(region, x, y);
diff --git a/core/src/mindustry/world/blocks/units/UnitFactory.java b/core/src/mindustry/world/blocks/units/UnitFactory.java
index 4a506b9b82f59ba7e34c6136b4cb07e40761448f..4fa3f721dc4613c5d6f9e857b085d51d8ec04fc5 100644
--- a/core/src/mindustry/world/blocks/units/UnitFactory.java
+++ b/core/src/mindustry/world/blocks/units/UnitFactory.java
@@ -249,7 +249,7 @@ public class UnitFactory extends UnitBlock{
                     i.setScaling(Scaling.fit);
                     i.setColor(currentPlan == -1 ? Color.lightGray : Color.white);
                 }).size(32).padBottom(-4).padRight(2);
-                t.label(() -> currentPlan == -1 ? "@none" : plans.get(currentPlan).unit.localizedName).wrap().width(230f).color(Color.lightGray);
+                t.label(() -> currentPlan == -1 ? (Iconc.cancel + "") : plans.get(currentPlan).unit.localizedName).wrap().width(230f).color(Color.lightGray);
             }).left();
         }
 
@@ -258,6 +258,22 @@ public class UnitFactory extends UnitBlock{
             return currentPlan;
         }
 
+        @Override
+        public void drawBars(){
+            super.drawBars();
+            Draw.color(Color.black, 0.3f);
+            Lines.stroke(4f);
+            Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+                x + block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f);
+            Draw.color(Pal.accent, 1f);
+            Lines.stroke(2f);
+            Lines.line(x - block.size * tilesize / 2f * 0.6f, y + block.size * tilesize / 2.5f,
+                x + 0.6f * (Mathf.clamp(fraction(), 0f, 1f) - 0.5f) * block.size * tilesize, y + block.size * tilesize / 2.5f);
+            Draw.color();
+            block.drawText((int)(Mathf.clamp(fraction(), 0f, 1f) * 100) + "% | " + (currentPlan == -1 ? Iconc.cancel : Strings.fixed((plans.get(currentPlan).time - progress) / (60f * Vars.state.rules.unitBuildSpeed(team) * timeScale), 0)), x, y + block.size * tilesize / 2.5f - 5f, true, 0.9f);
+        }
+
+
         @Override
         public void draw(){
             Draw.rect(region, x, y);
diff --git a/core/src/mindustry/world/meta/StatValues.java b/core/src/mindustry/world/meta/StatValues.java
index 909069a1a413e92ad3df0939c4f06911ae02955d..4b4d36fcdce22572f99d9ce7ceec79771b032f38 100644
--- a/core/src/mindustry/world/meta/StatValues.java
+++ b/core/src/mindustry/world/meta/StatValues.java
@@ -413,22 +413,21 @@ public class StatValues{
     public static StatValue abilities(UnitType unit, Seq<Ability> abilities){
         return table -> {
             table.row();
-            table.table(t -> {
-                t.background(Styles.grayPanel);
-                for(Ability a : abilities){
-                    if(!a.display) continue;
-                    String description = StatExt.description(a, unit);
-                    if(description != null){
-                        t.table(tt -> {
-                            tt.add(a.localized()).width(100f);
-                            tt.add(description).minWidth(350f).padRight(12f).padBottom(5f);
-                        });
-                    }else{
-                        t.add(a.localized()).minWidth(350f).padRight(12f).padBottom(5f);
-                    }
+            table.table(t -> abilities.each(ability -> {
+                if(ability.display){
                     t.row();
+                    t.table(Styles.grayPanel, a -> {
+                        a.left().top().defaults().left();
+                        a.add("[accent]" + ability.localized()).minWidth(100).padBottom(4);
+                        var customDescription = StatExt.description(ability, unit);
+                        if(customDescription != null){
+                            a.add(customDescription).row();
+                        }
+                        a.defaults().colspan(2);
+                        ability.addStats(a);
+                    }).pad(5).margin(10).growX();
                 }
-            }).padLeft(12f);
+            }));
         };
     }
 
diff --git a/core/src/mindustryX/Hooks.java b/core/src/mindustryX/Hooks.java
index 44a2d221648c1bbfb7938bf965d5a985db85ce79..aa6cf7a5cc3551e39064ea205c47ee3f2f1dcaaa 100644
--- a/core/src/mindustryX/Hooks.java
+++ b/core/src/mindustryX/Hooks.java
@@ -3,6 +3,7 @@ package mindustryX;
 import arc.*;
 import arc.util.*;
 import mindustry.*;
+import mindustry.arcModule.*;
 import mindustry.gen.*;
 import mindustry.input.*;
 import mindustryX.features.Settings;
@@ -55,6 +56,14 @@ public class Hooks implements ApplicationListener{
         if(message == null) return null;
         if(Vars.ui != null){
             if(MarkerType.resolveMessage(message)) return message;
+            try{
+                ARCVars.arcui.MessageDialog.resolveMsg(message, sender);
+                if(sender != null){
+                    message = (sender.unit().isNull() ? Iconc.alphaaaa : sender.unit().type.emoji()) + " " + message;
+                }
+            }catch(Exception e){
+                Log.err(e);
+            }
         }
         return message;
     }
diff --git a/core/src/mindustryX/features/StatExt.java b/core/src/mindustryX/features/StatExt.java
index 148c59f53c63cda27ac843b3466bd1f34364f214..60188fbb5b585d05ee0b93d1f70fba61683b5761 100644
--- a/core/src/mindustryX/features/StatExt.java
+++ b/core/src/mindustryX/features/StatExt.java
@@ -43,7 +43,7 @@ public class StatExt{
     ammoType = new Stat("ammo_type", StatCat.combat),
     ammoCapacity = new Stat("ammo_capacity", StatCat.combat);
 
-    public static String abilityFormat(String format, Object... values){
+    private static String abilityFormat(String format, Object... values){
         for(int i = 0; i < values.length; i++){
             if(values[i] instanceof Number n)
                 values[i] = "[stat]" + Strings.autoFixed(n.floatValue(), 1) + "[]";
