From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Wed, 20 Mar 2024 23:51:15 +0800
Subject: [PATCH] C: ReplayController
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

兼容ARC的mrep格式
way-zer <himc.wicp@gmail.com> on 2024/4/22 at 18:10

实现功能按钮
way-zer <himc.wicp@gmail.com> on 2024/4/22 at 20:15
---
 core/src/mindustry/core/NetClient.java        |   3 +
 core/src/mindustry/net/Net.java               |   2 +
 core/src/mindustryX/Hooks.java                |   1 +
 .../mindustryX/features/ReplayController.java | 239 ++++++++++++++++++
 4 files changed, 245 insertions(+)
 create mode 100644 core/src/mindustryX/features/ReplayController.java

diff --git a/core/src/mindustry/core/NetClient.java b/core/src/mindustry/core/NetClient.java
index dcca3b910e100d508955cf96681a793f6055f114..f370490430116780a4481cadbb17e0bdd51f078f 100644
--- a/core/src/mindustry/core/NetClient.java
+++ b/core/src/mindustry/core/NetClient.java
@@ -24,6 +24,7 @@ import mindustry.net.*;
 import mindustry.net.Packets.*;
 import mindustry.world.*;
 import mindustry.world.modules.*;
+import mindustryX.features.*;
 
 import java.io.*;
 import java.util.*;
@@ -104,12 +105,14 @@ public class NetClient implements ApplicationListener{
                 return;
             }
 
+            ReplayController.onConnect(packet.addressTCP);
             net.send(c, true);
         });
 
         net.handleClient(Disconnect.class, packet -> {
             if(quietReset) return;
 
+            ReplayController.stop();
             connecting = false;
             logic.reset();
             platform.updateRPC();
diff --git a/core/src/mindustry/net/Net.java b/core/src/mindustry/net/Net.java
index 6f9b8f9b50079b42f7762c8ee2b1101394b54e33..22b66b83cde27a73415b9154ed813cdfeb3d3b36 100644
--- a/core/src/mindustry/net/Net.java
+++ b/core/src/mindustry/net/Net.java
@@ -10,6 +10,7 @@ import mindustry.gen.*;
 import mindustry.net.Packets.*;
 import mindustry.net.Streamable.*;
 import mindustryX.events.*;
+import mindustryX.features.*;
 import net.jpountz.lz4.*;
 
 import java.io.*;
@@ -267,6 +268,7 @@ public class Net{
      */
     public void handleClientReceived(Packet object){
         object.handled();
+        ReplayController.onClientPacket(object);
 
         if(object instanceof StreamBegin b){
             streams.put(b.id, currentStream = new StreamBuilder(b));
diff --git a/core/src/mindustryX/Hooks.java b/core/src/mindustryX/Hooks.java
index e073bd101614f55da9e496aa6e60fe062475079b..01d7b62ec79aaef21c2bd0bd7dfcc1dc072b057c 100644
--- a/core/src/mindustryX/Hooks.java
+++ b/core/src/mindustryX/Hooks.java
@@ -25,6 +25,7 @@ public class Hooks implements ApplicationListener{
             RenderExt.init();
             TimeControl.init();
             UIExt.init();
+            ReplayController.init();
         }
     }
 
diff --git a/core/src/mindustryX/features/ReplayController.java b/core/src/mindustryX/features/ReplayController.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f3ba9615f3e53aa83c970d0c593f14e53fe3750
--- /dev/null
+++ b/core/src/mindustryX/features/ReplayController.java
@@ -0,0 +1,239 @@
+package mindustryX.features;
+
+import arc.*;
+import arc.files.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import arc.util.io.*;
+import mindustry.*;
+import mindustry.core.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.net.*;
+import mindustry.net.Packets.*;
+import mindustry.ui.dialogs.*;
+
+import java.io.*;
+import java.nio.*;
+import java.util.*;
+import java.util.zip.*;
+
+import static mindustry.Vars.*;
+
+/**
+ * 回放录制
+ * 原作者 cong0707, 原文件路径 mindustry.arcModule.ReplayController
+ * WayZer修改优化
+ */
+public class ReplayController{
+    public static boolean recording, replaying;
+
+    private static Writes writes;
+    private static float startTime;
+    private static final ByteBuffer tmpBuf = ByteBuffer.allocate(32768);
+    private static final Writes tmpWr = new Writes(new ByteBufferOutput(tmpBuf));
+    private static ReplayData now = null;
+
+    public static void init(){
+        Events.run(EventType.Trigger.update, () -> {
+            if(replaying && state.isMenu() && !netClient.isConnecting()){
+                stopPlay();
+            }
+        });
+        {
+            Table buttons = Vars.ui.join.buttons;
+            buttons.button("加载回放文件", Icon.file, () -> {
+                FileChooser.setLastDirectory(saveDirectory);
+                platform.showFileChooser(true, "打开回放文件", "mrep", f -> Core.app.post(() -> ReplayController.startPlay(f)));
+            });
+        }
+        {
+            var pausedDialog = Vars.ui.paused;
+            pausedDialog.shown(() -> {
+                if(!replaying) return;
+                pausedDialog.cont.row()
+                .button("查看录制信息", Icon.fileImage, ReplayController::showInfo).name("ReplayInfo")
+                .size(0, 60).colspan(pausedDialog.cont.getColumns()).fill();
+            });
+        }
+    }
+
+    private static class ReplayData{
+        int version;
+        Date time;
+        String ip;
+        String name;
+        float length;
+        private final IntIntMap packetCount = new IntIntMap();
+
+        ReplayData(int version, Date time, String ip, String name){
+            this.version = version;
+            this.time = time;
+            this.ip = ip;
+            this.name = name;
+        }
+    }
+
+    public static void onConnect(String ip){
+        if(!Core.settings.getBool("replayRecord")) return;
+        if(replaying) return;
+        var file = saveDirectory.child(new Date().getTime() + ".mrep");
+        try{
+            writes = new Writes(new DataOutputStream(new DeflaterOutputStream(file.write(false, 8192))));
+        }catch(Exception e){
+            Log.err("创建回放出错!", e);
+            return;
+        }
+        boolean anonymous = Core.settings.getBool("anonymous", false);
+        writes.i(Version.build);
+        writes.l(new Date().getTime());
+        writes.str(anonymous ? "anonymous" : ip);
+        writes.str(anonymous ? "anonymous" : Vars.player.name.trim());
+        startTime = Time.time;
+        recording = true;
+        Log.info("录制中: @", file.absolutePath());
+    }
+
+    public static void stop(){
+        recording = false;
+        try{
+            writes.close();
+        }catch(Exception ignored){
+        }
+        writes = null;
+    }
+
+    private static Net fakeServer = new Net(null){
+        @Override
+        public boolean server(){
+            return true;
+        }
+    };
+    public static void onClientPacket(Packet p){
+        if(!recording || p instanceof Streamable) return;
+        if(p instanceof Disconnect){
+            stop();
+            Log.info("录制结束");
+            return;
+        }
+        try{
+            byte id = Net.getPacketId(p);
+            try{
+                writes.f(Time.time - startTime);
+                writes.b(id);
+                tmpBuf.position(0);
+                var bak = net;
+                net = fakeServer;
+                p.write(tmpWr);
+                net = bak;
+                int l = tmpBuf.position();
+                writes.s(l);
+                writes.b(tmpBuf.array(), 0, l);
+            }catch(Exception e){
+                net.disconnect();
+                Core.app.post(() -> ui.showException("录制出错!", e));
+            }
+        }catch(Exception e){
+            Log.err(e);
+        }
+    }
+
+    //replay
+
+    public static Reads createReads(Fi input){
+        try{
+            return new Reads(new DataInputStream(new InflaterInputStream(input.read(32768))));
+        }catch(Exception e){
+            Core.app.post(() -> ui.showException("读取回放失败!", e));
+        }
+        return null;
+    }
+
+    public static void startPlay(Fi input){
+        try(Reads r = createReads(input)){
+            int version = r.i();
+            Date time = new Date(r.l());
+            String ip = r.str();
+            String name = r.str();
+            Log.infoTag("Replay", Strings.format("version: @, time: @, ip: @, name: @", version, time, ip, name));
+            now = new ReplayData(version, time, ip, name);
+            while(true){
+                float l = version > 10 ? r.f() :
+                (r.l() * Time.toSeconds / Time.nanosPerMilli / 1000);
+                byte id = r.b();
+                r.skip(r.us());
+                now.packetCount.put(id, now.packetCount.get(id, 0) + 1);
+                now.length = l;
+            }
+        }catch(Exception e){
+            if(!(e.getCause() instanceof EOFException)){
+                Log.err(e);
+                return;
+            }
+        }
+
+        Reads reads = createReads(input);
+        reads.skip(12);
+        reads.str();
+        reads.str();
+        replaying = true;
+
+        ui.loadfrag.show("@connecting");
+        ui.loadfrag.setButton(() -> {
+            replaying = false;
+            ui.loadfrag.hide();
+            netClient.disconnectQuietly();
+        });
+
+        logic.reset();
+        net.reset();
+        netClient.beginConnecting();
+        Reflect.set(net, "active", true);
+
+        startTime = Time.time;
+        Threads.daemon("Replay Controller", () -> {
+            try{
+                while(replaying){
+                    float nextTime = now.version > 10 ? reads.f() :
+                    (reads.l() * Time.toSeconds / Time.nanosPerMilli / 1000);
+                    Packet p = Net.newPacket(reads.b());
+                    p.read(reads, reads.us());
+                    while(Time.time - startTime < nextTime)
+                        Thread.sleep(1);
+                    Core.app.post(() -> net.handleClientReceived(p));
+                }
+            }catch(Exception e){
+                replaying = false;
+                reads.close();
+                net.disconnect();
+                Core.app.post(() -> logic.reset());
+            }
+        });
+    }
+
+    public static void stopPlay(){
+        replaying = false;
+        Log.infoTag("Replay", "stop");
+    }
+
+
+    public static void showInfo(){
+        BaseDialog dialog = new BaseDialog("回放统计");
+        var replay = now;
+        if(replay == null){
+            dialog.cont.add("未加载回放!");
+            return;
+        }
+        dialog.cont.add("回放版本:" + replay.version).row();
+        dialog.cont.add("回放创建时间:" + replay.time).row();
+        dialog.cont.add("服务器ip:" + replay.ip).row();
+        dialog.cont.add("玩家名:" + replay.name).row();
+        int secs = (int)(replay.length / 60);
+        dialog.cont.add("回放长度:" + (secs / 3600) + ":" + (secs / 60 % 60) + ":" + (secs % 60)).row();
+        dialog.cont.pane(t -> replay.packetCount.keys().toArray().each(b ->
+        t.add(Net.newPacket((byte)b).getClass().getSimpleName() + " " + replay.packetCount.get(b)).row())).growX().row();
+        dialog.addCloseButton();
+        dialog.show();
+    }
+}
