From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Sun, 18 Feb 2024 03:08:37 +0800
Subject: [PATCH] C: StatExt

---
 core/assets/bundles/bundle-mdtx.properties    |  35 +++
 core/src/mindustry/type/Item.java             |   5 +
 core/src/mindustry/type/Liquid.java           |   2 +
 core/src/mindustry/type/StatusEffect.java     |   2 +
 core/src/mindustry/type/UnitType.java         |  31 ++-
 core/src/mindustry/type/Weapon.java           |  22 +-
 core/src/mindustry/ui/ItemImage.java          |  22 ++
 core/src/mindustry/world/Block.java           |   4 +-
 .../world/blocks/defense/ForceProjector.java  |   7 +-
 .../world/blocks/defense/MendProjector.java   |   7 +-
 .../world/blocks/defense/RegenProjector.java  |   5 +-
 .../world/blocks/defense/ShieldWall.java      |   4 +
 .../defense/turrets/PointDefenseTurret.java   |   1 +
 .../world/blocks/defense/turrets/Turret.java  |   4 +-
 .../distribution/BufferedItemBridge.java      |   9 +
 .../world/blocks/distribution/Junction.java   |  10 +
 .../world/blocks/power/ImpactReactor.java     |  17 ++
 .../world/blocks/production/Drill.java        |   5 +-
 .../world/blocks/production/Separator.java    |   3 +-
 .../world/blocks/sandbox/PowerSource.java     |   6 +
 .../world/blocks/sandbox/PowerVoid.java       |   1 -
 .../world/consumers/ConsumeItemDynamic.java   |   2 +-
 .../world/consumers/ConsumeItems.java         |   2 +-
 .../consumers/ConsumePayloadDynamic.java      |   2 +-
 .../world/consumers/ConsumePayloads.java      |   2 +-
 core/src/mindustry/world/meta/Stat.java       |  21 +-
 core/src/mindustry/world/meta/StatCat.java    |   5 +-
 core/src/mindustry/world/meta/StatValues.java | 254 ++++++++++++++----
 core/src/mindustryX/features/StatExt.java     |  96 +++++++
 29 files changed, 495 insertions(+), 91 deletions(-)
 create mode 100644 core/src/mindustryX/features/StatExt.java

diff --git a/core/assets/bundles/bundle-mdtx.properties b/core/assets/bundles/bundle-mdtx.properties
index 87ca026cadc01f80b5e927ed210bc78f7c7fc13b..82aa7382ecbb65b88d7c39ea467c5fb8ab0fadc9 100644
--- a/core/assets/bundles/bundle-mdtx.properties
+++ b/core/assets/bundles/bundle-mdtx.properties
@@ -5,3 +5,38 @@ status.disarmed.name = 缴械
 status.invincible.name = 无敌
 status.fast.name = 迅捷
 
+#StatExt
+stat.unit_range = 雷达范围
+stat.can_overdrive = 能否超速
+stat.cost = 建造时间花费
+stat.health_scaling = 建筑血量系数
+stat.hardness = 硬度
+stat.buildable = 是否用于建造
+stat.boil_point = 沸点
+stat.drag_multiplier = 移动阻力倍率
+
+stat.buffer_capacity = 缓存容量
+stat.sep_output = 比例输出
+stat.regen_speed = 回复速度
+stat.regen_speed_broken = 过热时回复速度
+stat.mend = 修复量
+stat.mend_reload = 修复间隔
+stat.mend_speed = 修复速度
+stat.warmup_partial = 启动时间
+stat.warmup_time = 完全启动时间
+stat.warmup_power = 启动总耗电
+
+stat.rotate_speed = 转向速度
+stat.boost_multiplier = 助推速度倍率
+stat.drownTime_multiplier = 淹没时间倍率
+stat.mine_level = 采矿等级
+stat.unitItem_capacity = 物品容量
+
+stat.crush_damage = 碾压伤害(每格)
+stat.estimate_dps = 预估dps
+stat.ai_controller = 默认AI
+stat.targets = 目标
+stat.ammo_type = 子弹类型
+stat.ammo_capacity = 子弹容量
+
+#end StatExt
diff --git a/core/src/mindustry/type/Item.java b/core/src/mindustry/type/Item.java
index f451b5f1a39830b9e4fabd61fc30fa000204fa52..66f6d14161fc159305b0deed555a9baf98e408cb 100644
--- a/core/src/mindustry/type/Item.java
+++ b/core/src/mindustry/type/Item.java
@@ -12,6 +12,7 @@ import mindustry.graphics.MultiPacker.*;
 import mindustry.logic.*;
 import mindustry.world.blocks.environment.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -115,6 +116,10 @@ public class Item extends UnlockableContent implements Senseable{
         stats.addPercent(Stat.flammability, flammability);
         stats.addPercent(Stat.radioactivity, radioactivity);
         stats.addPercent(Stat.charge, charge);
+        stats.add(StatExt.cost, cost);
+        stats.add(StatExt.hardness, hardness);
+        stats.add(StatExt.healthScaling,healthScaling);
+        stats.add(StatExt.buildable,buildable);
     }
 
     @Override
diff --git a/core/src/mindustry/type/Liquid.java b/core/src/mindustry/type/Liquid.java
index a524970fcdeb4f24a84e72524f5d9372ddfa8e89..e99bcb9589a2a65274ab1f8dada9e24a24b22527 100644
--- a/core/src/mindustry/type/Liquid.java
+++ b/core/src/mindustry/type/Liquid.java
@@ -13,6 +13,7 @@ import mindustry.graphics.*;
 import mindustry.logic.*;
 import mindustry.world.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.entities.Puddles.*;
 
@@ -167,6 +168,7 @@ public class Liquid extends UnlockableContent implements Senseable{
         stats.addPercent(Stat.temperature, temperature);
         stats.addPercent(Stat.heatCapacity, heatCapacity);
         stats.addPercent(Stat.viscosity, viscosity);
+        stats.add(StatExt.boilPoint,boilPoint);
     }
 
     @Override
diff --git a/core/src/mindustry/type/StatusEffect.java b/core/src/mindustry/type/StatusEffect.java
index 4ffb7a61831a323b64200da77bf2c6da6d142cbf..054e2975ec0b052b0cea07ec5a2dd7f9ae6f1e0e 100644
--- a/core/src/mindustry/type/StatusEffect.java
+++ b/core/src/mindustry/type/StatusEffect.java
@@ -13,6 +13,7 @@ import mindustry.gen.*;
 import mindustry.graphics.*;
 import mindustry.graphics.MultiPacker.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 public class StatusEffect extends UnlockableContent{
     /** Damage dealt by the unit with the effect. */
@@ -93,6 +94,7 @@ public class StatusEffect extends UnlockableContent{
         if(speedMultiplier != 1) stats.addPercent(Stat.speedMultiplier, speedMultiplier);
         if(reloadMultiplier != 1) stats.addPercent(Stat.reloadMultiplier, reloadMultiplier);
         if(buildSpeedMultiplier != 1) stats.addPercent(Stat.buildSpeedMultiplier, buildSpeedMultiplier);
+        if(dragMultiplier != 1) stats.addPercent(StatExt.dragMultiplier, dragMultiplier);
         if(damage > 0) stats.add(Stat.damage, damage * 60f, StatUnit.perSecond);
         if(damage < 0) stats.add(Stat.healing, -damage * 60f, StatUnit.perSecond);
 
diff --git a/core/src/mindustry/type/UnitType.java b/core/src/mindustry/type/UnitType.java
index a96bdfec868be2fea8c1f76beeab78c8a717b9ce..2e92d78a290327c53dbf40479df20a7b8296d0de 100644
--- a/core/src/mindustry/type/UnitType.java
+++ b/core/src/mindustry/type/UnitType.java
@@ -37,6 +37,8 @@ import mindustry.world.blocks.payloads.*;
 import mindustry.world.blocks.units.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
+import mindustryX.features.*;
 
 import static arc.graphics.g2d.Draw.*;
 import static mindustry.Vars.*;
@@ -598,23 +600,44 @@ public class UnitType extends UnlockableContent implements Senseable{
         stats.add(Stat.health, health);
         stats.add(Stat.armor, armor);
         stats.add(Stat.speed, speed * 60f / tilesize, StatUnit.tilesSecond);
+        stats.add(StatExt.rotateSpeed,rotateSpeed);
         stats.add(Stat.size, StatValues.squared(hitSize / tilesize, StatUnit.blocks));
         stats.add(Stat.itemCapacity, itemCapacity);
         stats.add(Stat.range, (int)(maxRange / tilesize), StatUnit.blocks);
         stats.add(Stat.targetsAir, targetAir);
         stats.add(Stat.targetsGround, targetGround);
+        stats.add(StatExt.unitItemCapacity, itemCapacity);
+        stats.add(StatExt.aiController,aiController.get().getClass().getSimpleName());
 
         if(abilities.any()){
-            stats.add(Stat.abilities, StatValues.abilities(abilities));
+            stats.add(Stat.abilities, StatValues.abilities(this, abilities));
+        }
+
+        stats.add(StatExt.unitrange, (int)(maxRange / tilesize), StatUnit.blocks);
+        if(weapons.any()){
+            stats.add(Stat.weapons, StatValues.weapons(this, weapons));
+        }
+        stats.add(StatExt.estimateDPS,estimateDps());
+        stats.add(StatExt.ammoType, ammoType.icon());
+        stats.add(StatExt.ammoCapacity, ammoCapacity);
+        if (crushDamage > 0) {
+            stats.add(StatExt.crushDamage, crushDamage * 60f, StatUnit.perSecond);
         }
 
         stats.add(Stat.flying, flying);
 
         if(!flying){
             stats.add(Stat.canBoost, canBoost);
+            if(canBoost){
+                stats.add(StatExt.boostMultiplier, boostMultiplier);
+            }
+        }
+        if(drownTimeMultiplier != 1){
+            stats.add(StatExt.drownTimeMultiplier, drownTimeMultiplier);
         }
 
         if(mineTier >= 1){
+            stats.add(StatExt.mineLevel, "@级", mineTier);
             stats.addPercent(Stat.mineSpeed, mineSpeed);
             stats.add(Stat.mineTier, StatValues.drillables(mineSpeed, 1f, 1, null, b ->
                 b.itemDrop != null &&
@@ -639,6 +662,10 @@ public class UnitType extends UnlockableContent implements Senseable{
             stats.add(Stat.weapons, StatValues.weapons(this, weapons));
         }
 
+        if(targetFlags.length > 0 && targetFlags[0] != null){
+            stats.add(StatExt.targets, StatValues.targets(this, targetFlags));
+        }
+
         if(immunities.size > 0){
             var imm = immunities.toSeq().sort();
             //it's redundant to list wet for naval units
@@ -668,6 +695,8 @@ public class UnitType extends UnlockableContent implements Senseable{
 
         allowLegStep = example instanceof Legsc;
 
+        stats.useCategories = true;
+
         //water preset
         if(example instanceof WaterMovec){
             naval = true;
diff --git a/core/src/mindustry/type/Weapon.java b/core/src/mindustry/type/Weapon.java
index 55554c5400641cb87cb4dd1eac4ce4cd45511727..7e56b3b8ef56179a8521c3bd1c083c53b09eaa02 100644
--- a/core/src/mindustry/type/Weapon.java
+++ b/core/src/mindustry/type/Weapon.java
@@ -22,6 +22,7 @@ import mindustry.entities.units.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -162,13 +163,26 @@ public class Weapon implements Cloneable{
     }
 
     public void addStats(UnitType u, Table t){
-        if(inaccuracy > 0){
+        if(reload > 0) {
             t.row();
-            t.add("[lightgray]" + Stat.inaccuracy.localized() + ": [white]" + (int)inaccuracy + " " + StatUnit.degrees.localized());
+            int shoots = StatExt.totalShots(shoot);
+            t.add("[lightgray]" + Stat.reload.localized() + ": " + (mirror ? "[stat]2 [lightgray]x " : "") + (shoots == 1 ? "" : "[stat]" + shoots + " [lightgray]x ") + "[stat]" +  Strings.autoFixed(60f / reload, 2) + " []" + StatUnit.perSecond.localized());
         }
-        if(!alwaysContinuous && reload > 0){
+        t.row();
+        t.add("[lightgray]武器范围: [stat]" + String.format("%.1f", bullet.range/8f) + " []格");
+
+        if (rotate) {
+            t.row();
+            t.add("[lightgray]旋转速度: [stat]" + String.format("%.0f", rotateSpeed * 60f) + " []°/s");
+            if (rotationLimit < 361f) {
+                t.row();
+                t.add("[lightgray]旋转范围: [stat]" + String.format("%.0f", rotationLimit) + " []" + StatUnit.degrees.localized());
+            }
+        }
+
+        if(inaccuracy > 0){
             t.row();
-            t.add("[lightgray]" + Stat.reload.localized() + ": " + (mirror ? "2x " : "") + "[white]" + Strings.autoFixed(60f / reload * shoot.shots, 2) + " " + StatUnit.perSecond.localized());
+            t.add("[lightgray]" + Stat.inaccuracy.localized() + ": [stat]" + (int)inaccuracy + " []" + StatUnit.degrees.localized());
         }
 
         StatValues.ammo(ObjectMap.of(u, bullet)).display(t);
diff --git a/core/src/mindustry/ui/ItemImage.java b/core/src/mindustry/ui/ItemImage.java
index 874fa6ceff4c1ea412db02eb2adfb4e491771b19..6f20b9cd229a15a67d629e56762d86df3ec97012 100644
--- a/core/src/mindustry/ui/ItemImage.java
+++ b/core/src/mindustry/ui/ItemImage.java
@@ -1,11 +1,15 @@
 package mindustry.ui;
 
+import arc.func.Intp;
+import arc.func.Prov;
 import arc.graphics.g2d.*;
+import arc.scene.Element;
 import arc.scene.ui.*;
 import arc.scene.ui.layout.*;
 import arc.util.*;
 import mindustry.core.*;
 import mindustry.type.*;
+import static mindustry.Vars.*;
 
 public class ItemImage extends Stack{
 
@@ -25,6 +29,24 @@ public class ItemImage extends Stack{
         }
     }
 
+    public ItemImage(TextureRegion region, int reqAmount, Intp curAmount){
+        add(new Table(o -> {
+            o.left();
+            o.add(new Image(region)).size(32f).scaling(Scaling.fit);
+        }));
+
+        add(new Table(t -> {
+            t.left().bottom();
+            t.add(String.valueOf(reqAmount)).get().setFontScale(1f);
+            t.pack();
+        }));
+        add(new Table(t -> {
+            t.left().top();
+            t.label(() -> String.valueOf(curAmount.get())).get().setFontScale(0.6f);
+            t.pack();
+        }));
+    }
+
     public ItemImage(ItemStack stack){
         this(stack.item.uiIcon, stack.amount);
     }
diff --git a/core/src/mindustry/world/Block.java b/core/src/mindustry/world/Block.java
index 325f37c7b184445dfc4d75ac5e82581894dd34d9..0cd4d52bf61ce00ab59e0d6dff993d85221b0868 100644
--- a/core/src/mindustry/world/Block.java
+++ b/core/src/mindustry/world/Block.java
@@ -32,6 +32,7 @@ import mindustry.world.blocks.environment.*;
 import mindustry.world.blocks.power.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import java.lang.reflect.*;
 import java.util.*;
@@ -528,7 +529,7 @@ public class Block extends UnlockableContent implements Senseable{
             }
         }
 
-        if(canBeBuilt() && requirements.length > 0){
+        if(requirements.length > 0){
             stats.add(Stat.buildTime, buildCost / 60, StatUnit.seconds);
             stats.add(Stat.buildCost, StatValues.items(false, requirements));
         }
@@ -540,6 +541,7 @@ public class Block extends UnlockableContent implements Senseable{
         for(var c : consumers){
             c.display(stats);
         }
+        stats.add(StatExt.canOverdrive, canOverdrive);
 
         //Note: Power stats are added by the consumers.
         if(hasLiquids) stats.add(Stat.liquidCapacity, liquidCapacity, StatUnit.liquidUnits);
diff --git a/core/src/mindustry/world/blocks/defense/ForceProjector.java b/core/src/mindustry/world/blocks/defense/ForceProjector.java
index 74f0fd4860644903c3ce81318681596f0a60d317..4b7d6968838780299971c9a827752e516d74ea0c 100644
--- a/core/src/mindustry/world/blocks/defense/ForceProjector.java
+++ b/core/src/mindustry/world/blocks/defense/ForceProjector.java
@@ -20,6 +20,7 @@ import mindustry.ui.*;
 import mindustry.world.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -96,13 +97,15 @@ public class ForceProjector extends Block{
 
         if(consItems) stats.timePeriod = phaseUseTime;
         super.setStats();
+        stats.add(Stat.range, radius / tilesize, StatUnit.blocks);
         stats.add(Stat.shieldHealth, shieldHealth, StatUnit.none);
         stats.add(Stat.cooldownTime, (int) (shieldHealth / cooldownBrokenBase / 60f), StatUnit.seconds);
-
+        stats.add(StatExt.regenSpeed, cooldownNormal * Time.toSeconds, StatUnit.perSecond);
+        stats.add(StatExt.regenSpeedBroken, cooldownBrokenBase * Time.toSeconds, StatUnit.perSecond);
         if(consItems && itemConsumer instanceof ConsumeItems coni){
             stats.remove(Stat.booster);
             stats.add(Stat.booster, StatValues.itemBoosters("+{0} " + StatUnit.shieldHealth.localized(), stats.timePeriod, phaseShieldBoost, phaseRadiusBoost, coni.items, this::consumesItem));
-            stats.add(Stat.booster, StatValues.speedBoosters("", coolantConsumption, Float.MAX_VALUE, true, this::consumesLiquid));
+            stats.add(Stat.booster, StatValues.speedBoosters(Core.bundle.get("shield.regenspeed"), coolantConsumption, cooldownLiquid, true, this::consumesLiquid, true));
         }
     }
 
diff --git a/core/src/mindustry/world/blocks/defense/MendProjector.java b/core/src/mindustry/world/blocks/defense/MendProjector.java
index 369d0eecea48320fb8559acdf6de9cf2c74447c9..5c9f7369c72dbd5b6b4345008e7dc896e48b02b4 100644
--- a/core/src/mindustry/world/blocks/defense/MendProjector.java
+++ b/core/src/mindustry/world/blocks/defense/MendProjector.java
@@ -13,6 +13,7 @@ import mindustry.logic.*;
 import mindustry.world.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -51,13 +52,15 @@ public class MendProjector extends Block{
         stats.timePeriod = useTime;
         super.setStats();
 
-        stats.add(Stat.repairTime, (int)(100f / healPercent * reload / 60f), StatUnit.seconds);
         stats.add(Stat.range, range / tilesize, StatUnit.blocks);
+        stats.add(StatExt.mend, healPercent, StatUnit.percent);
+        stats.add(StatExt.mendReload, reload / 60f, StatUnit.seconds);
+        stats.add(StatExt.mendSpeed, "@%/s", Strings.autoFixed(healPercent / (reload / 60f), 1));
 
         if(findConsumer(c -> c instanceof ConsumeItems) instanceof ConsumeItems cons){
             stats.remove(Stat.booster);
             stats.add(Stat.booster, StatValues.itemBoosters(
-                "{0}" + StatUnit.timesSpeed.localized(),
+                "{0}x修复量",
                 stats.timePeriod, (phaseBoost + healPercent) / healPercent, phaseRangeBoost,
                 cons.items, this::consumesItem)
             );
diff --git a/core/src/mindustry/world/blocks/defense/RegenProjector.java b/core/src/mindustry/world/blocks/defense/RegenProjector.java
index 69bbb61116ad4a09306c05f056020305c15ea2e2..4e446b3c30cf663542fd4d3256691a88a7cc66c7 100644
--- a/core/src/mindustry/world/blocks/defense/RegenProjector.java
+++ b/core/src/mindustry/world/blocks/defense/RegenProjector.java
@@ -14,6 +14,7 @@ import mindustry.world.*;
 import mindustry.world.consumers.*;
 import mindustry.world.draw.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -89,13 +90,13 @@ public class RegenProjector extends Block{
         stats.timePeriod = optionalUseTime;
         super.setStats();
 
-        stats.add(Stat.repairTime, (int)(1f / (healPercent / 100f) / 60f), StatUnit.seconds);
         stats.add(Stat.range, range, StatUnit.blocks);
+        stats.add(StatExt.mendSpeed, "@%/s", Strings.autoFixed(healPercent * 60f, 1));
 
         if(findConsumer(c -> c instanceof ConsumeItems) instanceof ConsumeItems cons){
             stats.remove(Stat.booster);
             stats.add(Stat.booster, StatValues.itemBoosters(
-                "{0}" + StatUnit.timesSpeed.localized(),
+                "{0}x修复速度",
                 stats.timePeriod, optionalMultiplier, 0f,
                 cons.items, this::consumesItem)
             );
diff --git a/core/src/mindustry/world/blocks/defense/ShieldWall.java b/core/src/mindustry/world/blocks/defense/ShieldWall.java
index 8f7a1135a1c2b46b7b83b8ca58cdbb12ccc90784..53c0889446bda2891a6417c435ff255953447b92 100644
--- a/core/src/mindustry/world/blocks/defense/ShieldWall.java
+++ b/core/src/mindustry/world/blocks/defense/ShieldWall.java
@@ -8,6 +8,7 @@ import arc.util.io.*;
 import mindustry.annotations.Annotations.*;
 import mindustry.graphics.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -32,6 +33,9 @@ public class ShieldWall extends Wall{
         super.setStats();
 
         stats.add(Stat.shieldHealth, shieldHealth);
+        stats.add(Stat.cooldownTime, breakCooldown / Time.toSeconds, StatUnit.seconds);
+        stats.add(StatExt.regenSpeed, regenSpeed * Time.toSeconds, StatUnit.perSecond);
+
     }
 
     public class ShieldWallBuild extends WallBuild{
diff --git a/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java b/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java
index 97aedf43b5595bcfb63ea9ecce91dc6e57967e92..cd30d93b35b0547658c39c0b0f6e5ef0f8300973 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/PointDefenseTurret.java
@@ -52,6 +52,7 @@ public class PointDefenseTurret extends ReloadTurret{
         super.setStats();
 
         stats.add(Stat.reload, 60f / reload, StatUnit.perSecond);
+        stats.add(Stat.damage, bulletDamage);
     }
 
     public class PointDefenseBuild extends ReloadTurretBuild{
diff --git a/core/src/mindustry/world/blocks/defense/turrets/Turret.java b/core/src/mindustry/world/blocks/defense/turrets/Turret.java
index 9003d6e4c6afa463aec395590b7473a28d842a17..f6866128bc39fdbf40d8e1b853ecc533ab5b9880 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/Turret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/Turret.java
@@ -26,6 +26,7 @@ import mindustry.ui.*;
 import mindustry.world.blocks.*;
 import mindustry.world.draw.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -149,7 +150,8 @@ public class Turret extends ReloadTurret{
         super.setStats();
 
         stats.add(Stat.inaccuracy, (int)inaccuracy, StatUnit.degrees);
-        stats.add(Stat.reload, 60f / (reload) * shoot.shots, StatUnit.perSecond);
+        int shoots = StatExt.totalShots(shoot);
+        stats.add(Stat.reload, "@@/s", shoots == 1 ? "" : shoots + " x ", Strings.autoFixed(60f / reload, 2));
         stats.add(Stat.targetsAir, targetAir);
         stats.add(Stat.targetsGround, targetGround);
         if(ammoPerShot != 1) stats.add(Stat.ammoUse, ammoPerShot, StatUnit.perShot);
diff --git a/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java b/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java
index f7fc8ea5c754acded073ce062d6d0e9bce70943f..f25b90987d05f0e3851faaa238e14d0f3e5ccd88 100644
--- a/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java
+++ b/core/src/mindustry/world/blocks/distribution/BufferedItemBridge.java
@@ -8,6 +8,7 @@ import arc.util.io.*;
 import mindustry.gen.*;
 import mindustry.type.*;
 import mindustry.world.*;
+import mindustry.world.meta.*;
 import mindustryX.features.*;
 
 import static mindustry.Vars.*;
@@ -25,6 +26,14 @@ public class BufferedItemBridge extends ItemBridge{
         canOverdrive = true;
     }
 
+    @Override
+    public void setStats(){
+        super.setStats();
+
+        stats.add(StatExt.bufferCapacity, bufferCapacity);
+        stats.add(Stat.itemsMoved, Strings.autoFixed(bufferCapacity * 60f / speed ,2) , StatUnit.itemsSecond);
+    }
+
     public class BufferedItemBridgeBuild extends ItemBridgeBuild{
         ItemBuffer buffer = new ItemBuffer(bufferCapacity);
 
diff --git a/core/src/mindustry/world/blocks/distribution/Junction.java b/core/src/mindustry/world/blocks/distribution/Junction.java
index 48de8e94b971603c88b51cb5b101bee4d1a3c262..92d3f3af233ad6e18a3a9cb1e257d2c011b05d70 100644
--- a/core/src/mindustry/world/blocks/distribution/Junction.java
+++ b/core/src/mindustry/world/blocks/distribution/Junction.java
@@ -31,6 +31,16 @@ public class Junction extends Block{
         noUpdateDisabled = true;
     }
 
+    @Override
+    public void setStats(){
+        super.setStats();
+
+        //have to add a custom calculated speed, since the actual movement speed is apparently not linear
+        stats.add(Stat.itemCapacity, capacity);
+        stats.add(Stat.itemsMoved,Strings.autoFixed(60f / speed * capacity ,2) , StatUnit.itemsSecond);
+    }
+
+
     @Override
     public boolean outputsItems(){
         return true;
diff --git a/core/src/mindustry/world/blocks/power/ImpactReactor.java b/core/src/mindustry/world/blocks/power/ImpactReactor.java
index 136cf66b46876bb32783bab353f1da20726410d8..528b2960a70af587b6b6fbbaf203646d0bd6a594 100644
--- a/core/src/mindustry/world/blocks/power/ImpactReactor.java
+++ b/core/src/mindustry/world/blocks/power/ImpactReactor.java
@@ -13,6 +13,7 @@ import mindustry.logic.*;
 import mindustry.ui.*;
 import mindustry.world.draw.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 public class ImpactReactor extends PowerGenerator{
     public final int timerUse = timers++;
@@ -41,6 +42,14 @@ public class ImpactReactor extends PowerGenerator{
         explodeSound = Sounds.explosionbig;
     }
 
+    private float warmupToTime(float warmup, float timeScale) {
+        return Mathf.log(1f - warmupSpeed * timeScale, 1f - warmup);
+    }
+
+    private float timeToWarmup(float time, float timeScale) {
+        return 1f - Mathf.pow(1 - warmupSpeed * timeScale, time);
+    }
+
     @Override
     public void setBars(){
         super.setBars();
@@ -59,6 +68,14 @@ public class ImpactReactor extends PowerGenerator{
         if(hasItems){
             stats.add(Stat.productionTime, itemDuration / 60f, StatUnit.seconds);
         }
+        float startTime = warmupToTime(Mathf.pow(consPower.usage / powerProduction, 1f / 5f), 1f);
+        stats.add(StatExt.warmupPartial, startTime / 60f, StatUnit.seconds);
+        stats.add(StatExt.warmupTime, warmupToTime(0.999f, 1f) / 60f, StatUnit.seconds);
+        float startConsPower = 0;
+        for (int tick = 1;tick < startTime;tick++) {
+            startConsPower += consPower.usage - Mathf.pow(timeToWarmup(tick, 1f), 5f) * powerProduction;
+        }
+        stats.add(StatExt.warmupPower, Mathf.ceil(startConsPower / 50f) * 50f, StatUnit.none);
     }
 
     public class ImpactReactorBuild extends GeneratorBuild{
diff --git a/core/src/mindustry/world/blocks/production/Drill.java b/core/src/mindustry/world/blocks/production/Drill.java
index 0068ed4d6549a70f801e8a95653fdad7317fb948..21babe1f3e89b0a33bbc93c8e79bc9d76505ad5f 100644
--- a/core/src/mindustry/world/blocks/production/Drill.java
+++ b/core/src/mindustry/world/blocks/production/Drill.java
@@ -171,10 +171,7 @@ public class Drill extends Block{
     public void setStats(){
         super.setStats();
 
-        stats.add(Stat.drillTier, StatValues.drillables(drillTime, hardnessDrillMultiplier, size * size, drillMultipliers, b -> b instanceof Floor f && !f.wallOre && f.itemDrop != null &&
-            f.itemDrop.hardness <= tier && f.itemDrop != blockedItem && (indexer.isBlockPresent(f) || state.isMenu())));
-
-        stats.add(Stat.drillSpeed, 60f / drillTime * size * size, StatUnit.itemsSecond);
+        stats.add(Stat.drillTier, StatValues.drillBlock(this));
 
         if(liquidBoostIntensity != 1 && findConsumer(f -> f instanceof ConsumeLiquidBase) instanceof ConsumeLiquidBase consBase){
             stats.remove(Stat.booster);
diff --git a/core/src/mindustry/world/blocks/production/Separator.java b/core/src/mindustry/world/blocks/production/Separator.java
index fd387d6960fc0b33278ea5925f18ac659cb66e1a..9c0b560e43d6d1abeb9396283f4a6a99447dc8a2 100644
--- a/core/src/mindustry/world/blocks/production/Separator.java
+++ b/core/src/mindustry/world/blocks/production/Separator.java
@@ -12,6 +12,7 @@ import mindustry.world.*;
 import mindustry.world.consumers.*;
 import mindustry.world.draw.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 /**
  * Extracts a random list of items from an input item and an input liquid.
@@ -38,7 +39,7 @@ public class Separator extends Block{
         stats.timePeriod = craftTime;
         super.setStats();
 
-        stats.add(Stat.output, StatValues.items(item -> Structs.contains(results, i -> i.item == item)));
+        stats.add(StatExt.sepOutput,StatValues.items(results));
         stats.add(Stat.productionTime, craftTime / 60f, StatUnit.seconds);
     }
 
diff --git a/core/src/mindustry/world/blocks/sandbox/PowerSource.java b/core/src/mindustry/world/blocks/sandbox/PowerSource.java
index 3a8685bb5e327b75b201e9d01f3fb08da5fe9643..a89894f000a95cd576a7236c000ef7db9da2b149 100644
--- a/core/src/mindustry/world/blocks/sandbox/PowerSource.java
+++ b/core/src/mindustry/world/blocks/sandbox/PowerSource.java
@@ -15,6 +15,12 @@ public class PowerSource extends PowerNode{
         envEnabled = Env.any;
     }
 
+    @Override
+    public void setStats() {
+        super.setStats();
+        stats.add(Stat.basePowerGeneration, powerProduction * 60f, StatUnit.powerSecond);
+    }
+
     public class PowerSourceBuild extends PowerNodeBuild{
         @Override
         public float getPowerProduction(){
diff --git a/core/src/mindustry/world/blocks/sandbox/PowerVoid.java b/core/src/mindustry/world/blocks/sandbox/PowerVoid.java
index d0a8acf4d7438f25f5a9ec275982f6564f4a4483..6943d06cf9438d757ccc61e582fac169c20683d9 100644
--- a/core/src/mindustry/world/blocks/sandbox/PowerVoid.java
+++ b/core/src/mindustry/world/blocks/sandbox/PowerVoid.java
@@ -15,6 +15,5 @@ public class PowerVoid extends PowerBlock{
     @Override
     public void setStats(){
         super.setStats();
-        stats.remove(Stat.powerUse);
     }
 }
diff --git a/core/src/mindustry/world/consumers/ConsumeItemDynamic.java b/core/src/mindustry/world/consumers/ConsumeItemDynamic.java
index 45325369cde396b510ff48ff19335fca5bfdffaa..cf58ad1987a98b584dbfaf43b2bc7930c055fcde 100644
--- a/core/src/mindustry/world/consumers/ConsumeItemDynamic.java
+++ b/core/src/mindustry/world/consumers/ConsumeItemDynamic.java
@@ -42,7 +42,7 @@ public class ConsumeItemDynamic extends Consume{
         int i = 0;
 
         for(ItemStack stack : items.get(build)){
-            table.add(new ReqImage(new ItemImage(stack.item.uiIcon, Math.round(stack.amount * multiplier.get(build))),
+            table.add(new ReqImage(new ItemImage(stack.item.uiIcon, Math.round(stack.amount * multiplier.get(build)), () -> build.items.get(stack.item)),
             () -> build.items != null && build.items.has(stack.item, Math.round(stack.amount * multiplier.get(build))))).padRight(8).left();
             if(++i % 4 == 0) table.row();
         }
diff --git a/core/src/mindustry/world/consumers/ConsumeItems.java b/core/src/mindustry/world/consumers/ConsumeItems.java
index 791db5a71dc02fb139d1369b0efdf115f1af5a4c..322c52cc3d6f4c233371b622c30de608bb06bde5 100644
--- a/core/src/mindustry/world/consumers/ConsumeItems.java
+++ b/core/src/mindustry/world/consumers/ConsumeItems.java
@@ -33,7 +33,7 @@ public class ConsumeItems extends Consume{
         table.table(c -> {
             int i = 0;
             for(var stack : items){
-                c.add(new ReqImage(new ItemImage(stack.item.uiIcon, Math.round(stack.amount * multiplier.get(build))),
+                c.add(new ReqImage(new ItemImage(stack.item.uiIcon, Math.round(stack.amount * multiplier.get(build)), () -> build.items.get(stack.item)),
                 () -> build.items.has(stack.item, Math.round(stack.amount * multiplier.get(build))))).padRight(8);
                 if(++i % 4 == 0) c.row();
             }
diff --git a/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java b/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java
index d12abb009d78f089b3a7131b4409ce57a16f1a43..29c3e689c2b23418c809c8916d3b4990b7e337c4 100644
--- a/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java
+++ b/core/src/mindustry/world/consumers/ConsumePayloadDynamic.java
@@ -63,7 +63,7 @@ public class ConsumePayloadDynamic extends Consume{
         table.table(c -> {
             int i = 0;
             for(var stack : pay){
-                c.add(new ReqImage(new ItemImage(stack.item.uiIcon, Math.round(stack.amount * multiplier.get(build))),
+                c.add(new ReqImage(new ItemImage(stack.item.uiIcon, Math.round(stack.amount * multiplier.get(build)), () -> build.getPayloads().get(stack.item)),
                 () -> inv.contains(stack.item, Math.round(stack.amount * multiplier.get(build))))).padRight(8);
                 if(++i % 4 == 0) c.row();
             }
diff --git a/core/src/mindustry/world/consumers/ConsumePayloads.java b/core/src/mindustry/world/consumers/ConsumePayloads.java
index ae905a4e8b5929ec4274bfe21d13fa9c4d1352f3..03dc185e0ea98f409aa21da9adc7e1ef7cc55ecb 100644
--- a/core/src/mindustry/world/consumers/ConsumePayloads.java
+++ b/core/src/mindustry/world/consumers/ConsumePayloads.java
@@ -51,7 +51,7 @@ public class ConsumePayloads extends Consume{
         table.table(c -> {
             int i = 0;
             for(var stack : payloads){
-                c.add(new ReqImage(new ItemImage(stack.item.uiIcon, Math.round(stack.amount * multiplier.get(build))),
+                c.add(new ReqImage(new ItemImage(stack.item.uiIcon, Math.round(stack.amount * multiplier.get(build)), () -> build.items.get((Item) stack.item)),
                 () -> inv.contains(stack.item, Math.round(stack.amount * multiplier.get(build))))).padRight(8);
                 if(++i % 4 == 0) c.row();
             }
diff --git a/core/src/mindustry/world/meta/Stat.java b/core/src/mindustry/world/meta/Stat.java
index 5248a70c80adf42a61a708cec4c215d123e9f50e..a67da3912a0d5c83aaa8878323d3c9e1652e63f4 100644
--- a/core/src/mindustry/world/meta/Stat.java
+++ b/core/src/mindustry/world/meta/Stat.java
@@ -25,17 +25,18 @@ public class Stat implements Comparable<Stat>{
     heatCapacity = new Stat("heatCapacity"),
     viscosity = new Stat("viscosity"),
     temperature = new Stat("temperature"),
-    flying = new Stat("flying"),
-    speed = new Stat("speed"),
-    buildSpeed = new Stat("buildSpeed"),
-    mineSpeed = new Stat("mineSpeed"),
-    mineTier = new Stat("mineTier"),
-    payloadCapacity = new Stat("payloadCapacity"),
+    flying = new Stat("flying", StatCat.movement),
+    speed = new Stat("speed", StatCat.movement),
+    buildSpeed = new Stat("buildSpeed", StatCat.support),
+    mineSpeed = new Stat("mineSpeed", StatCat.support),
+    mineTier = new Stat("mineTier", StatCat.support),
+    payloadCapacity = new Stat("payloadCapacity", StatCat.support),
+
     baseDeflectChance = new Stat("baseDeflectChance"),
     lightningChance = new Stat("lightningChance"),
     lightningDamage = new Stat("lightningDamage"),
-    abilities = new Stat("abilities"),
-    canBoost = new Stat("canBoost"),
+    abilities = new Stat("abilities", StatCat.combat),
+    canBoost = new Stat("canBoost", StatCat.movement),
     maxUnits = new Stat("maxUnits"),
 
     damageMultiplier = new Stat("damageMultiplier"),
@@ -71,8 +72,8 @@ public class Stat implements Comparable<Stat>{
     linkRange = new Stat("linkRange", StatCat.crafting),
     instructions = new Stat("instructions", StatCat.crafting),
 
-    weapons = new Stat("weapons", StatCat.function),
-    bullet = new Stat("bullet", StatCat.function),
+    weapons = new Stat("weapons", StatCat.combat),
+    bullet = new Stat("bullet", StatCat.combat),
 
     speedIncrease = new Stat("speedIncrease", StatCat.function),
     repairTime = new Stat("repairTime", StatCat.function),
diff --git a/core/src/mindustry/world/meta/StatCat.java b/core/src/mindustry/world/meta/StatCat.java
index 416df5a20af4767cdfdc2646bce19468ad11cd28..239311eea91980f2c3e0facd6613b2373cc11909 100644
--- a/core/src/mindustry/world/meta/StatCat.java
+++ b/core/src/mindustry/world/meta/StatCat.java
@@ -15,7 +15,10 @@ public class StatCat implements Comparable<StatCat>{
     items = new StatCat("items"),
     crafting = new StatCat("crafting"),
     function = new StatCat("function"),
-    optional = new StatCat("optional");
+    optional = new StatCat("optional"),
+    support =  new StatCat("support"),
+    combat =  new StatCat("combat"),
+    movement =  new StatCat("movement");
 
     public final String name;
     public final int id;
diff --git a/core/src/mindustry/world/meta/StatValues.java b/core/src/mindustry/world/meta/StatValues.java
index f7c32b3a2570b6db76f19b5f95e36f9f432141ab..909069a1a413e92ad3df0939c4f06911ae02955d 100644
--- a/core/src/mindustry/world/meta/StatValues.java
+++ b/core/src/mindustry/world/meta/StatValues.java
@@ -12,7 +12,7 @@ import arc.util.*;
 import mindustry.*;
 import mindustry.content.*;
 import mindustry.ctype.*;
-import mindustry.entities.abilities.*;
+import mindustry.entities.abilities.Ability;
 import mindustry.entities.bullet.*;
 import mindustry.gen.*;
 import mindustry.maps.*;
@@ -21,6 +21,8 @@ import mindustry.ui.*;
 import mindustry.world.*;
 import mindustry.world.blocks.defense.turrets.*;
 import mindustry.world.blocks.environment.*;
+import mindustry.world.blocks.production.Drill;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -164,7 +166,7 @@ public class StatValues{
 
                 if(state.isGame()){
                     var blocks = Vars.content.blocks()
-                    .select(block -> (!checkFloors || block instanceof Floor) && indexer.isBlockPresent(block) && block.attributes.get(attr) != 0 && !((block instanceof Floor f && f.isDeep()) && !floating))
+                    .select(block -> (!checkFloors || block instanceof Floor) && block.attributes.get(attr) != 0 && !((block instanceof Floor f && f.isDeep()) && !floating))
                     .with(s -> s.sort(f -> f.attributes.get(attr)));
 
                     if(blocks.any()){
@@ -237,6 +239,38 @@ public class StatValues{
         return content(list.as());
     }
 
+    public static StatValue drillBlock(Drill drill){
+        Seq<Block> list = content.blocks().select(b -> b instanceof Floor f && !f.wallOre && f.itemDrop != null && f.itemDrop.hardness <= drill.tier && f.itemDrop != drill.blockedItem);
+        list.sort(t -> drill.getDrillTime(t.itemDrop));
+        return table -> {
+            table.row();
+            table.table(at -> {
+                at.background(Styles.grayPanel);
+                at.add("[stat]" + drill.tier + "[lightgray]级[accent] ~ [stat]" +
+                Strings.autoFixed(60f / drill.drillTime * drill.size * drill.size, 2) + "[lightgray]物品/s");
+                at.row();
+                if(list.size == 0) return;
+                at.table(t -> {
+                    float[] eff = new float[list.size];
+                    for(int i = 0; i < list.size; i++){
+                        eff[i] = 60f / drill.getDrillTime(list.get(i).itemDrop) * drill.size * drill.size;
+                    }
+                    StringBuilder oreList = new StringBuilder();
+                    for(int i = 0; i < list.size; i++){
+                        Block block = list.get(i);
+                        oreList.append(block.emoji()).append(" ").append(block.localizedName);
+                        if(i == list.size - 1 || eff[i] != eff[i + 1]){
+                            t.labelWrap(oreList.toString()).width(250f).padLeft(20f).padTop(5f);
+                            t.add("[stat]" + Strings.fixed(eff[i], 2)).padLeft(20f);
+                            t.add("[cyan]" + Strings.fixed(eff[i] * drill.liquidBoostIntensity * drill.liquidBoostIntensity, 2)).padLeft(20f).padRight(20f);
+                            t.row();
+                            oreList = new StringBuilder();
+                        }else oreList.append("  ");
+                    }
+                });
+            });
+        };
+    }
     public static StatValue drillables(float drillTime, float drillMultiplier, float size, ObjectFloatMap<Item> multipliers, Boolf<Block> filter){
         return table -> {
             table.row();
@@ -293,6 +327,10 @@ public class StatValues{
     }
 
     public static StatValue speedBoosters(String unit, float amount, float speed, boolean strength, Boolf<Liquid> filter){
+        return speedBoosters(unit, amount, speed, strength, filter, false);
+    }
+
+    public static StatValue speedBoosters(String unit, float amount, float speed, boolean strength, Boolf<Liquid> filter, Boolean isForce){
         return table -> {
             table.row();
             table.table(c -> {
@@ -308,7 +346,8 @@ public class StatValues{
 
                         b.table(bt -> {
                             bt.right().defaults().padRight(3).left();
-                            if(speed != Float.MAX_VALUE) bt.add(unit.replace("{0}", "[stat]" + Strings.autoFixed(speed * (strength ? liquid.heatCapacity : 1f) + (strength ? 1f : 0f), 2) + "[lightgray]")).pad(5);
+                            if(isForce) bt.add(unit.replace("{0}", "[stat]" + Strings.autoFixed(speed * ((liquid.heatCapacity - 0.4f) * 0.9f + 1), 2) + "[lightgray]")).pad(5);
+                            else if(speed != Float.MAX_VALUE) bt.add(unit.replace("{0}", "[stat]" + Strings.autoFixed(speed * (strength ? liquid.heatCapacity : 1f) + (strength ? 1f : 0f), 2) + "[lightgray]")).pad(5);
                         }).right().grow().pad(10f).padRight(15f);
                     }).growX().pad(5).row();
                 }
@@ -371,20 +410,49 @@ public class StatValues{
         };
     }
 
-    public static StatValue abilities(Seq<Ability> abilities){
+    public static StatValue abilities(UnitType unit, Seq<Ability> abilities){
         return table -> {
             table.row();
-            table.table(t -> abilities.each(ability -> {
-                if(ability.display){
+            table.table(t -> {
+                t.background(Styles.grayPanel);
+                for(Ability a : abilities){
+                    if(!a.display) continue;
+                    String description = StatExt.description(a, unit);
+                    if(description != null){
+                        t.table(tt -> {
+                            tt.add(a.localized()).width(100f);
+                            tt.add(description).minWidth(350f).padRight(12f).padBottom(5f);
+                        });
+                    }else{
+                        t.add(a.localized()).minWidth(350f).padRight(12f).padBottom(5f);
+                    }
                     t.row();
-                    t.table(Styles.grayPanel, a -> {
-                        a.add("[accent]" + ability.localized()).padBottom(4);
-                        a.row();
-                        a.left().top().defaults().left();
-                        ability.addStats(a);
-                    }).pad(5).margin(10).growX();
                 }
-            }));
+            }).padLeft(12f);
+        };
+    }
+
+    public static StatValue targets(UnitType unit, BlockFlag[] targetFlags){
+        return table -> {
+            table.row();
+            table.table(t -> {
+                t.background(Styles.grayPanel);
+                for(BlockFlag flag : targetFlags){
+                    if(flag == null) continue;
+                    t.add(flag.name()).width(150f).padBottom(5f);
+                    int count = 0;
+                    for(Block block : content.blocks()){
+                        if(block.flags.contains(flag)){
+                            if(count >= 3){
+                                t.add("\uE813").width(30f);
+                                break;
+                            }else t.add(block.emoji()).width(30f);
+                            count += 1;
+                        }
+                    }
+                    t.row();
+                }
+            }).padLeft(12f);
         };
     }
 
@@ -425,7 +493,9 @@ public class StatValues{
                         bt.row();
                     }
 
-                    if(type.damage > 0 && (type.collides || type.splashDamage <= 0)){
+                    if(type instanceof LightningBulletType lb){
+                        lightning(0, lb.damage, lb.lightningLength, lb.lightningLengthRand).display(bt);
+                    }else if(type.damage > 0 && (type.collides || type.splashDamage <= 0)){
                         if(type.continuousDamage() > 0){
                             bt.add(Core.bundle.format("bullet.damage", type.continuousDamage()) + StatUnit.perSecond.localized());
                         }else{
@@ -434,12 +504,11 @@ public class StatValues{
                     }
 
                     if(type.buildingDamageMultiplier != 1){
-                        int val = (int)(type.buildingDamageMultiplier * 100 - 100);
-                        sep(bt, Core.bundle.format("bullet.buildingdamage", ammoStat(val)));
+                        sep(bt, colorize(type.buildingDamageMultiplier) + "[lightgray]x建筑伤害");
                     }
 
                     if(type.rangeChange != 0 && !compact){
-                        sep(bt, Core.bundle.format("bullet.range", ammoStat(type.rangeChange / tilesize)));
+                        sep(bt, "[lightgray]射程 + " + colorize(type.rangeChange / tilesize > 0) + Strings.autoFixed(type.rangeChange / tilesize, 1) + " [lightgray]格");
                     }
 
                     if(type.splashDamage > 0){
@@ -451,8 +520,7 @@ public class StatValues{
                     }
 
                     if(!compact && !Mathf.equal(type.reloadMultiplier, 1f)){
-                        int val = (int)(type.reloadMultiplier * 100 - 100);
-                        sep(bt, Core.bundle.format("bullet.reload", ammoStat(val)));
+                        sep(bt, colorize(type.reloadMultiplier) + "[lightgray]x射速");
                     }
 
                     if(type.knockback > 0){
@@ -467,8 +535,24 @@ public class StatValues{
                         sep(bt, Core.bundle.format("bullet.healamount", Strings.autoFixed(type.healAmount, 2)));
                     }
 
-                    if(type.pierce || type.pierceCap != -1){
-                        sep(bt, type.pierceCap == -1 ? "@bullet.infinitepierce" : Core.bundle.format("bullet.pierce", type.pierceCap));
+                    if((type.pierce || type.pierceCap != -1) && !(type instanceof PointLaserBulletType)){
+                        boolean laserPierce = type instanceof LaserBulletType || type instanceof ContinuousLaserBulletType || type instanceof ShrapnelBulletType;
+                        boolean pierceBuilding = laserPierce || type instanceof ContinuousFlameBulletType || type instanceof RailBulletType || type.pierceBuilding;
+                        boolean pierceUnit = type.pierce;
+                        StringBuilder str = new StringBuilder("[stat]");
+                        if(type instanceof RailBulletType rail){
+                            str.append(Strings.autoFixed(rail.pierceDamageFactor * 100f, 1) + "%衰减");
+                        }else{
+                            str.append(type.pierceCap == -1 ? "无限" : type.pierceCap + "x");
+                        }
+                        str.append("穿透[lightgray]");
+                        if(pierceBuilding && pierceUnit){
+                            str.append("建筑与单位");
+                        }else{
+                            str.append(pierceBuilding ? "建筑" : "单位");
+                        }
+                        if(laserPierce) str.append("[stat](电性)");
+                        sep(bt, str.toString());
                     }
 
                     if(type.incendAmount > 0){
@@ -476,59 +560,71 @@ public class StatValues{
                     }
 
                     if(type.homingPower > 0.01f){
-                        sep(bt, "@bullet.homing");
+                        sep(bt, "[stat]追踪[lightgray]~[]" + Strings.autoFixed(type.homingPower * 50 * Time.toSeconds, 1) + "°/s[lightgray]~[]" + Strings.fixed(type.homingRange / tilesize, 1) + "[lightgray]格");
                     }
 
-                    if(type.lightning > 0){
-                        sep(bt, Core.bundle.format("bullet.lightning", type.lightning, type.lightningDamage < 0 ? type.damage : type.lightningDamage));
+                    if(!(type instanceof LightningBulletType) && type.lightning > 0){
+                        lightning(type.lightning, type.lightningDamage < 0 ? type.damage : type.lightningDamage, type.lightningLength, type.lightningLengthRand).display(bt);
                     }
 
                     if(type.pierceArmor){
                         sep(bt, "@bullet.armorpierce");
                     }
 
-                    if(type.suppressionRange > 0){
-                        sep(bt, Core.bundle.format("bullet.suppression", Strings.autoFixed(type.suppressionDuration / 60f, 2), Strings.fixed(type.suppressionRange / tilesize, 1)));
-                    }
-
                     if(type.status != StatusEffects.none){
-                        sep(bt, (type.status.minfo.mod == null ? type.status.emoji() : "") + "[stat]" + type.status.localizedName + (type.status.reactive ? "" : "[lightgray] ~ [stat]" + ((int)(type.statusDuration / 60f)) + "[lightgray] " + Core.bundle.get("unit.seconds")));
+                        sep(bt, (type.status.minfo.mod == null ? type.status.emoji() : "") + "[stat]" + type.status.localizedName + (type.status.reactive ? "" : "[lightgray]~[]" + Strings.autoFixed(type.statusDuration / 60f, 2) + "[lightgray]s"));
                     }
 
-                    if(type.intervalBullet != null){
-                        bt.row();
-
-                        Table ic = new Table();
-                        ammo(ObjectMap.of(t, type.intervalBullet), indent + 1, false).display(ic);
-                        Collapser coll = new Collapser(ic, true);
-                        coll.setDuration(0.1f);
-
-                        bt.table(it -> {
-                            it.left().defaults().left();
+                    if(type.suppressionRange > 0){
+                        sep(bt, Core.bundle.format("bullet.suppression", Strings.autoFixed(type.suppressionDuration / 60f, 2), Strings.fixed(type.suppressionRange / tilesize, 1)));
+                    }
 
-                            it.add(Core.bundle.format("bullet.interval", Strings.autoFixed(type.intervalBullets / type.bulletInterval * 60, 2)));
-                            it.button(Icon.downOpen, Styles.emptyi, () -> coll.toggle(false)).update(i -> i.getStyle().imageUp = (!coll.isCollapsed() ? Icon.upOpen : Icon.downOpen)).size(8).padLeft(16f).expandX();
+                    if(type instanceof EmpBulletType eb){
+                        collapse(bt, Strings.format("[stat]EMP~@[lightgray]格[]~[white]\uE810[]@%/[white]\uE86D[]@%~[white]\uF899[][green]@%[]/[negstat]@%[]",
+                        Strings.autoFixed(eb.radius / tilesize, 0),
+                        Strings.autoFixed(eb.powerDamageScl * 100, 0),
+                        Strings.autoFixed(eb.unitDamageScl * 100, 0),
+                        Strings.autoFixed(eb.timeIncrease * 100, 0),
+                        Strings.autoFixed(eb.powerSclDecrease * 100, 0)
+                        ), ec -> {
+                            ec.defaults().padLeft(5f);
+                            sep(ec, Strings.format("[stat]对敌方电网建筑造成@%子弹伤害", Strings.autoFixed(eb.powerDamageScl * 100, 0)));
+                            sep(ec, Strings.format("[stat]对敌方单位造成@%子弹伤害", Strings.autoFixed(eb.unitDamageScl * 100, 0)));
+                            sep(ec, Strings.format("[stat]对我方耗电建筑超速至@%", Strings.autoFixed(eb.timeIncrease * 100, 0)));
+                            sep(ec, Strings.format("[stat]对敌方电网建筑减速至@%", Strings.autoFixed(eb.powerSclDecrease * 100, 0)));
                         });
-                        bt.row();
-                        bt.add(coll);
                     }
 
                     if(type.fragBullet != null){
-                        bt.row();
-
-                        Table fc = new Table();
-                        ammo(ObjectMap.of(t, type.fragBullet), indent + 1, false).display(fc);
-                        Collapser coll = new Collapser(fc, true);
-                        coll.setDuration(0.1f);
+                        collapse(bt, Core.bundle.format("bullet.frags", type.fragBullets), fc -> {
+                            ammo(ObjectMap.of(t, type.fragBullet), indent + 1, false).display(fc);
+                        });
+                    }
 
-                        bt.table(ft -> {
-                            ft.left().defaults().left();
+                    if(type.intervalBullet != null){
+                        collapse(bt, Core.bundle.format("bullet.interval", Strings.autoFixed(type.intervalBullets / type.bulletInterval * 60, 2)), ic -> {
+                            ammo(ObjectMap.of(t, type.intervalBullet), indent + 1, false).display(ic);
+                        });
+                    }
 
-                            ft.add(Core.bundle.format("bullet.frags", type.fragBullets));
-                            ft.button(Icon.downOpen, Styles.emptyi, () -> coll.toggle(false)).update(i -> i.getStyle().imageUp = (!coll.isCollapsed() ? Icon.upOpen : Icon.downOpen)).size(8).padLeft(16f).expandX();
+                    Seq<BulletType> spawn = type.spawnBullets.copy();
+                    if(spawn.any()){
+                        collapse(bt, Strings.format("[stat]@x[lightgray]生成子弹：", spawn.size), sc -> {
+                            while(spawn.any()){
+                                BulletType bullet = spawn.first();
+                                Boolf<BulletType> pred = b -> bullet.damage == b.damage && bullet.splashDamage == b.splashDamage;
+                                //通过pred的的子弹被认为和当前子弹是一样的，合并显示
+                                int count = spawn.count(pred);
+                                if(count == type.spawnBullets.size){
+                                    ammo(ObjectMap.of(t, bullet), indent + 1, false).display(sc);
+                                }else{
+                                    sep(sc, Strings.format(" [stat]@x[lightgray]子弹：", count)).padLeft(0f);//不知道为什么padLeft0刚刚好，就这样了
+                                    ammo(ObjectMap.of(t, bullet), indent + 2, false).display(sc);
+                                }
+                                bt.row();
+                                spawn.removeAll(pred);
+                            }
                         });
-                        bt.row();
-                        bt.add(coll);
                     }
                 }).padLeft(indent * 5).padTop(5).padBottom(compact ? 0 : 5).growX().margin(compact ? 0 : 10);
                 table.row();
@@ -536,10 +632,46 @@ public class StatValues{
         };
     }
 
+    public static StatValue lightning(int shots, float damage, int length, int lengthRand){
+        return table -> {
+            String str = "[lightgray]";
+            if(shots > 0){
+                str += String.format("[stat]%d[]x", shots);
+            }
+            str += String.format("闪电~[stat]%s[]伤害~", Strings.autoFixed(damage, 1));
+            if(lengthRand > 0){
+                str += String.format("[stat]%d~%d[]长度", length, length + lengthRand);
+            }else{
+                str += String.format("[stat]%d[]长度", length);
+            }
+            sep(table, str);
+        };
+    }
+
     //for AmmoListValue
-    private static void sep(Table table, String text){
+    private static Cell<Label> sep(Table table, String text){
+        table.row();
+        return table.add(text);
+    }
+
+    private static void collapse(Table table, String text, Cons<Table> cons){
+        table.row();
+
+        Table collt = new Table();
+        collt.left().defaults().left();
+        cons.get(collt);
+
+        Collapser coll = new Collapser(collt, true);
+        coll.setDuration(0.1f);
+
+        table.table(tt -> {
+            tt.add(text);
+            tt.button(Icon.downOpen, Styles.emptyi, () -> coll.toggle(false))
+            .update(i -> i.getStyle().imageUp = (!coll.isCollapsed() ? Icon.upOpen : Icon.downOpen))
+            .size(8).padLeft(16f).expandX();
+        });
         table.row();
-        table.add(text);
+        table.add(coll);
     }
 
     //for AmmoListValue
@@ -547,6 +679,14 @@ public class StatValues{
         return (val > 0 ? "[stat]+" : "[negstat]") + Strings.autoFixed(val, 1);
     }
 
+    private static String colorize(float val){
+        return (val > 1 ? "[stat]" : "[negstat]") + Strings.autoFixed(val, 2);
+    }
+
+    private static String colorize(boolean val){
+        return val ? "[stat]" : "[negstat]";
+    }
+
     private static TextureRegion icon(UnlockableContent t){
         return t.uiIcon;
     }
diff --git a/core/src/mindustryX/features/StatExt.java b/core/src/mindustryX/features/StatExt.java
new file mode 100644
index 0000000000000000000000000000000000000000..148c59f53c63cda27ac843b3466bd1f34364f214
--- /dev/null
+++ b/core/src/mindustryX/features/StatExt.java
@@ -0,0 +1,96 @@
+package mindustryX.features;
+
+import arc.util.*;
+import mindustry.entities.abilities.*;
+import mindustry.entities.pattern.*;
+import mindustry.type.*;
+import mindustry.world.meta.*;
+
+import static mindustry.Vars.tilesize;
+
+public class StatExt{
+    public static Stat
+    unitrange = new Stat("unit_range"),
+    canOverdrive = new Stat("can_overdrive"),
+    cost = new Stat("cost"),
+    healthScaling = new Stat("health_scaling"),
+    hardness = new Stat("hardness"),
+    buildable = new Stat("buildable"),
+    boilPoint = new Stat("boil_point"),
+    dragMultiplier = new Stat("drag_multiplier"),//移动阻力倍率
+
+    bufferCapacity = new Stat("buffer_capacity", StatCat.items),
+    sepOutput = new Stat("sep_output", StatCat.crafting),
+    regenSpeed = new Stat("regen_speed", StatCat.function),//力墙 回复速度
+    regenSpeedBroken = new Stat("regen_speed_broken", StatCat.function),//力墙 过热时回复速度
+    mend = new Stat("mend", StatCat.function),//治疗 修复量
+    mendReload = new Stat("mend_reload", StatCat.function),//治疗 修复间隔
+    mendSpeed = new Stat("mend_speed", StatCat.function),//治疗 修复速度
+    warmupPartial = new Stat("warmup_partial", StatCat.power),//冲击 启动时间
+    warmupTime = new Stat("warmup_time", StatCat.power),//冲击 完全启动时间
+    warmupPower = new Stat("warmup_power", StatCat.power),//冲击 启动总耗电
+
+    rotateSpeed = new Stat("rotate_speed", StatCat.movement),
+    boostMultiplier = new Stat("boost_multiplier", StatCat.movement),
+    drownTimeMultiplier = new Stat("drownTime_multiplier", StatCat.movement),
+    mineLevel = new Stat("mine_level", StatCat.support),
+    unitItemCapacity = new Stat("unitItem_capacity", StatCat.support),
+
+    crushDamage = new Stat("crush_damage", StatCat.combat),//碾压伤害(每格)
+    estimateDPS = new Stat("estimate_dps", StatCat.combat),
+    aiController = new Stat("ai_controller", StatCat.combat),
+    targets = new Stat("targets", StatCat.combat),
+    ammoType = new Stat("ammo_type", StatCat.combat),
+    ammoCapacity = new Stat("ammo_capacity", StatCat.combat);
+
+    public static String abilityFormat(String format, Object... values){
+        for(int i = 0; i < values.length; i++){
+            if(values[i] instanceof Number n)
+                values[i] = "[stat]" + Strings.autoFixed(n.floatValue(), 1) + "[]";
+            else
+                values[i] = "[white]" + values[i] + "[]";
+        }
+        return Strings.format("[lightgray]" + format.replace("~", "[accent]~[]"), values);
+    }
+
+    public static @Nullable String description(Ability ability, UnitType unit){
+        if(ability instanceof ForceFieldAbility a){
+            return abilityFormat("@盾容~@格~@恢复~@s冷却",
+            a.max, a.radius / tilesize, a.regen * 60f, a.cooldown / 60f
+            );
+        }else if(ability instanceof LiquidExplodeAbility a){
+            float rad = Math.max(unit.hitSize / tilesize * a.radScale, 1);
+            return abilityFormat("总计@@@~@格半径",
+            1f / 3f * Math.PI * rad * rad * a.amount * a.radAmountScale,// 1/3πr²h
+            a.liquid.localizedName, a.liquid.emoji(), rad
+            );
+        }else if(ability instanceof LiquidRegenAbility a){
+            return abilityFormat("每格吸收@/s@@~@/s回血~最大@/s",
+            a.slurpSpeed, a.liquid.localizedName, a.liquid.emoji(), a.slurpSpeed * a.regenPerSlurp,
+            Math.PI * Math.pow(Math.max(unit.hitSize / tilesize * 0.6f, 1), 2) * a.slurpSpeed * a.regenPerSlurp
+            );
+        }else if(ability instanceof MoveLightningAbility a){
+            return abilityFormat("闪电@概率~@伤害~@长度 @x速度",
+            a.chance * 100, a.damage, a.length, a.maxSpeed
+            );
+        }else if(ability instanceof SuppressionFieldAbility a){
+            return abilityFormat("@s~@格",
+            a.reload / 60f, a.range / tilesize
+            );
+        }
+        return null;
+    }
+
+    public static int totalShots(ShootPattern pattern){
+        if(pattern instanceof ShootHelix){
+            return pattern.shots * 2;
+        }else if(pattern instanceof ShootMulti s){
+            int total = 0;
+            for(var p : s.dest){
+                total += totalShots(p);
+            }
+            return pattern.shots * total;
+        }
+        return pattern.shots;
+    }
+}
