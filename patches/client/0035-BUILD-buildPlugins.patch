From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Tue, 9 Apr 2024 17:57:46 +0800
Subject: [PATCH] BUILD buildPlugins
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

patchArc改写成transform
way-zer <himc.wicp@gmail.com> on 2024/4/27 at 18:57
---
 .gitignore                                    |   6 +-
 buildPlugins/build.gradle.kts                 |  23 +++
 .../plugins/mindustryX/buildExt.gradle.kts    |  31 ++++
 .../plugins/mindustryX/loaderMod.gradle.kts   | 141 ++++++++++++++++++
 .../plugins/mindustryX/patchArc.gradle.kts    |  99 ++++++++++++
 core/build.gradle.kts                         |   1 +
 settings.gradle                               |   2 +
 7 files changed, 299 insertions(+), 4 deletions(-)
 create mode 100644 buildPlugins/build.gradle.kts
 create mode 100644 buildPlugins/plugins/mindustryX/buildExt.gradle.kts
 create mode 100644 buildPlugins/plugins/mindustryX/loaderMod.gradle.kts
 create mode 100644 buildPlugins/plugins/mindustryX/patchArc.gradle.kts

diff --git a/.gitignore b/.gitignore
index ba271e6bd0dd06971fff6fa2314254149cc90087..abe35e41df5f7e47c81d3ad059c735a079170711 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,6 @@
+build/
 logs/
+
 /fastlane/metadata/android/en-US/changelogs/
 /core/assets/mindustry-saves/
 /core/assets/mindustry-maps/
@@ -20,10 +22,6 @@ ios/libs/
 /core/assets-raw/sprites_out/
 /annotations/build/
 /annotations/out/
-/net/build/
-/tools/build/
-/tests/build/
-/server/build/
 changelog
 saves/
 /core/assets-raw/fontgen/out/
diff --git a/buildPlugins/build.gradle.kts b/buildPlugins/build.gradle.kts
new file mode 100644
index 0000000000000000000000000000000000000000..5fc57097a1240fc6b2912492fa4470c4ffc4ed4b
--- /dev/null
+++ b/buildPlugins/build.gradle.kts
@@ -0,0 +1,23 @@
+plugins{
+    `kotlin-dsl-base`
+    `kotlin-dsl`.apply(false)
+}
+
+repositories{
+    mavenCentral()
+    gradlePluginPortal()
+    google()
+}
+
+dependencies{
+    implementation("org.javassist:javassist:3.30.2-GA")
+    implementation("com.android.tools.smali:smali-dexlib2:3.0.5")
+    implementation("de.undercouch:gradle-download-task:5.6.0")
+}
+
+sourceSets.main{
+    kotlin.srcDir("plugins")
+}
+
+//later apply to use srcDir
+apply(plugin = "org.gradle.kotlin.kotlin-dsl")
\ No newline at end of file
diff --git a/buildPlugins/plugins/mindustryX/buildExt.gradle.kts b/buildPlugins/plugins/mindustryX/buildExt.gradle.kts
new file mode 100644
index 0000000000000000000000000000000000000000..f6cd338cc79a0382e8a23ca590ac034f2ebf3a09
--- /dev/null
+++ b/buildPlugins/plugins/mindustryX/buildExt.gradle.kts
@@ -0,0 +1,31 @@
+package mindustryX
+
+plugins {
+    id("mindustryX.patchArc")
+    id("mindustryX.loaderMod")
+}
+
+tasks{
+    val writeMindustryX by registering {
+        outputs.cacheIf { true }
+        val outFile = projectDir.resolve("assets/MindustryX.hjson")
+        outputs.file(outFile)
+        val version = (project.properties["buildversion"] ?: "1.0-dev") as String
+        val upstreamBuild = (project.properties["upstreamBuild"] ?: "custom") as String
+        inputs.property("buildVersion", version)
+        inputs.property("upstreamBuild", upstreamBuild)
+        doLast {
+            outFile.writeText("""
+            displayName: MindustryX Loader
+            name: MindustryX
+            author: WayZer
+            main: mindustryX.loader.Main
+            version: "$version"
+            minGameVersion: "$upstreamBuild"
+            hidden: true
+            dependencies: []
+        """.trimIndent())
+        }
+    }
+    processResources.configure { dependsOn(writeMindustryX) }
+}
\ No newline at end of file
diff --git a/buildPlugins/plugins/mindustryX/loaderMod.gradle.kts b/buildPlugins/plugins/mindustryX/loaderMod.gradle.kts
new file mode 100644
index 0000000000000000000000000000000000000000..4921f01e9e12246f561df4c50c16911e81785a20
--- /dev/null
+++ b/buildPlugins/plugins/mindustryX/loaderMod.gradle.kts
@@ -0,0 +1,141 @@
+package mindustryX
+
+import com.android.tools.smali.dexlib2.DexFileFactory
+import com.android.tools.smali.dexlib2.Opcodes
+import com.android.tools.smali.dexlib2.rewriter.DexRewriter
+import com.android.tools.smali.dexlib2.rewriter.Rewriter
+import com.android.tools.smali.dexlib2.rewriter.RewriterModule
+import com.android.tools.smali.dexlib2.rewriter.Rewriters
+import org.gradle.api.GradleException
+import org.gradle.api.tasks.bundling.Zip
+import org.gradle.kotlin.dsl.getValue
+import org.gradle.kotlin.dsl.provideDelegate
+import org.gradle.kotlin.dsl.registering
+import java.io.File
+import java.util.zip.ZipEntry
+import java.util.zip.ZipFile
+import java.util.zip.ZipOutputStream
+
+plugins {
+    id("de.undercouch.download")
+}
+
+tasks {
+    val downloadOriginJar by registering(de.undercouch.gradle.tasks.download.Download::class) {
+        outputs.cacheIf { true }
+        val upstreamBuild = project.properties["upstreamBuild"] as String?
+        val output = temporaryDir.resolve("v$upstreamBuild.jar")
+        inputs.property("upstreamBuild", upstreamBuild)
+
+        src("https://github.com/Anuken/Mindustry/releases/download/v$upstreamBuild/Mindustry.jar")
+        dest(output)
+        overwrite(false)
+    }
+    val distTask = provider { getByPath("::desktop:dist") }
+    val genLoaderMod by registering {
+        outputs.cacheIf { true }
+        val androidTask = findByPath("::android:compileReleaseJavaWithJavac")
+        dependsOn(downloadOriginJar, distTask)
+        if (androidTask != null)
+            dependsOn(androidTask)
+        val outputF = layout.buildDirectory.file("libs/Mindustry.loader.jar")
+        inputs.files(distTask)
+        outputs.file(outputF)
+        doLast {
+            val input = ZipFile(distTask.get().outputs.files.singleFile)
+            val base = ZipFile(downloadOriginJar.get().outputFiles.single())
+            val output = ZipOutputStream(outputF.get().asFile.outputStream())
+            val baseMap = base.entries().asSequence().associateBy { it.name }
+
+            for (entry in input.entries()) {
+                if (entry.name.startsWith("sprites") || entry.name == "version.properties") continue
+                val baseEntry = baseMap[entry.name]
+                if (baseEntry != null) {
+                    val a = input.getInputStream(entry).use { it.readAllBytes() }
+                    val b = base.getInputStream(baseEntry).use { it.readAllBytes() }
+                    val ext = entry.name.substringAfterLast('.', "")
+                    val eq = when (ext) {
+                        "", "frag", "vert", "js", "properties" -> a.filter { it != 10.toByte() && it != 13.toByte() } == b.filter { it != 10.toByte() && it != 13.toByte() }
+                        else -> a.contentEquals(b)
+                    }
+                    if (eq) continue
+                }
+                var outputEntry = entry
+                //rename to mod.hjson
+                if (entry.name == "MindustryX.hjson") {
+                    outputEntry = ZipEntry("mod.hjson")
+                }
+                output.putNextEntry(outputEntry)
+                output.write(input.getInputStream(entry).use { it.readAllBytes() })
+                output.closeEntry()
+                //copy icon
+                if(entry.name == "icons/icon_64.png"){
+                    output.putNextEntry(ZipEntry("icon.png"))
+                    output.write(input.getInputStream(entry).use { it.readAllBytes() })
+                    output.closeEntry()
+                }
+            }
+            if (androidTask != null) {
+                val root = androidTask.outputs.files.first()
+                root.resolve("mindustryX").walkTopDown().forEach {
+                    if (it.isDirectory) return@forEach
+                    val path = it.toRelativeString(root)
+                    output.putNextEntry(ZipEntry(path))
+                    output.write(it.readBytes())
+                    output.closeEntry()
+                }
+            }
+            output.close()
+        }
+    }
+
+    val genLoaderModDex by registering {
+        outputs.cacheIf { true }
+        dependsOn(genLoaderMod, distTask)
+        inputs.files(files(genLoaderMod))
+        val outFile = temporaryDir.resolve("classes.dex")
+        outputs.file(outFile)
+        doLast {
+            val library = distTask.get().outputs.files.singleFile
+            val inFile = genLoaderMod.get().outputs.files.singleFile
+            val sdkRoot = System.getenv("ANDROID_HOME") ?: System.getenv("ANDROID_SDK_ROOT")
+            if (sdkRoot == null || !File(sdkRoot).exists()) throw GradleException("No valid Android SDK found. Ensure that ANDROID_HOME is set to your Android SDK directory.")
+
+            val d8Tool = File("$sdkRoot/build-tools/").listFiles()?.sortedDescending()
+                ?.flatMap { dir -> (dir.listFiles().orEmpty()).filter { it.name.startsWith("d8") } }?.firstOrNull()
+                ?: throw GradleException("No d8 found. Ensure that you have an Android platform installed.")
+            val platformRoot = File("$sdkRoot/platforms/").listFiles()?.sortedDescending()?.firstOrNull { it.resolve("android.jar").exists() }
+                ?: throw GradleException("No android.jar found. Ensure that you have an Android platform installed.")
+
+            exec {
+                commandLine("$d8Tool --lib ${platformRoot.resolve("android.jar")} --classpath $library --min-api 14 --output $temporaryDir $inFile".split(" "))
+                workingDir(inFile.parentFile)
+                standardOutput = System.out
+                errorOutput = System.err
+            }.assertNormalExitValue()
+        }
+
+        //fix ExternalSyntheticLambda
+        doLast {
+            val file = DexFileFactory.loadDexFile(outFile, Opcodes.forApi(14))
+            val rewriter = DexRewriter(object : RewriterModule() {
+                override fun getTypeRewriter(rewriters: Rewriters): Rewriter<String> = Rewriter {
+                    if (it.length > 20 && it.contains("ExternalSyntheticLambda")) {
+                        return@Rewriter it.replace("ExternalSyntheticLambda", "Lambda")
+                    }
+                    it
+                }
+            })
+            rewriter.dexFileRewriter.rewrite(file).let {
+                DexFileFactory.writeDexFile(outFile.path, it)
+            }
+        }
+    }
+
+    val genLoaderModAll by registering(Zip::class) {
+        dependsOn(genLoaderMod, genLoaderModDex)
+        archiveFileName.set("MindustryX.loader.dex.jar")
+        from(zipTree(genLoaderMod.get().outputs.files.singleFile))
+        from(genLoaderModDex)
+    }
+}
\ No newline at end of file
diff --git a/buildPlugins/plugins/mindustryX/patchArc.gradle.kts b/buildPlugins/plugins/mindustryX/patchArc.gradle.kts
new file mode 100644
index 0000000000000000000000000000000000000000..4715953ea1db8e20fe922911ba8054b8a8231fea
--- /dev/null
+++ b/buildPlugins/plugins/mindustryX/patchArc.gradle.kts
@@ -0,0 +1,99 @@
+package mindustryX
+
+import javassist.ClassPool
+import javassist.CtClass
+import javassist.bytecode.Bytecode
+import javassist.bytecode.Descriptor
+import java.util.zip.ZipFile
+import java.util.zip.ZipOutputStream
+
+plugins {
+    java
+}
+
+@CacheableTransform
+abstract class PatchArc : TransformAction<TransformParameters.None> {
+    @get:InputArtifact
+    @get:PathSensitive(PathSensitivity.NONE)
+    abstract val inputArtifact: Provider<FileSystemLocation>
+
+    private val genDir = File("build/gen/patchedArc")
+    private val transform = mapOf<String, CtClass.() -> Unit>(
+        "arc.util.Http\$HttpRequest" to clz@{
+            getDeclaredMethod("block").apply {
+                val code = Bytecode(methodInfo.constPool)
+                val desc = Descriptor.ofMethod(CtClass.voidType, arrayOf(this@clz))
+                code.addAload(0)
+                code.addInvokestatic("mindustryX.Hooks", "onHttp", desc)
+                methodInfo.codeAttribute.iterator().insertEx(code.get())
+                methodInfo.rebuildStackMapIf6(classPool, classFile)
+            }
+        }
+    )
+
+    override fun transform(outputs: TransformOutputs) {
+        val input = inputArtifact.get().asFile
+        val output = outputs.file("${input.nameWithoutExtension}.patched.jar")
+        doTransform(input, output)
+    }
+
+    private fun doTransform(input: File, output: File) {
+        val pool = ClassPool()
+        pool.appendSystemPath()
+        pool.appendClassPath(input.path)
+
+        val tmp = output.resolveSibling("tmp")
+        if (tmp.exists()) tmp.deleteRecursively()
+        tmp.mkdirs()
+        transform.forEach { (clz, block) ->
+            pool.get(clz).also(block)
+                .writeFile(tmp.path)
+        }
+
+        val overwrite = tmp.walk().associateBy { it.toRelativeString(tmp).replace(File.separatorChar, '/') }
+        ZipOutputStream(output.outputStream()).use { out ->
+            ZipFile(input).use { zip ->
+                for (entry in zip.entries()) {
+                    out.putNextEntry(entry)
+                    (overwrite[entry.name]?.also {
+                        println("patchArc ${entry.name}")
+                    }?.inputStream() ?: zip.getInputStream(entry)).copyTo(out)
+                    out.closeEntry()
+                }
+            }
+        }
+        tmp.deleteRecursively()
+    }
+}
+
+val artifactType = Attribute.of("artifactType", String::class.java)
+val patched = Attribute.of("patched", Boolean::class.javaObjectType)
+dependencies {
+    attributesSchema {
+        attribute(patched)
+    }
+    artifactTypes.getByName("jar") {
+        attributes.attribute(patched, false)
+    }
+    registerTransform(PatchArc::class) {
+        from.attribute(artifactType, "jar").attribute(patched, false)
+        to.attribute(artifactType, "jar").attribute(patched, true)
+    }
+
+    val api by configurations
+    val patchArc by configurations.creating {
+        attributes {
+            attribute(patched, true)
+        }
+    }
+    configurations.named("compileOnlyApi").configure { extendsFrom(patchArc) }
+    "runtimeOnly"(files(patchArc))
+
+
+    val arcLib = api.dependencies.find { it.name == "arc-core" }
+        ?: error("Can't find arc-core")
+    api.dependencies.remove(arcLib)
+    patchArc(arcLib as ExternalModuleDependency) {
+        isTransitive = false
+    }
+}
\ No newline at end of file
diff --git a/core/build.gradle.kts b/core/build.gradle.kts
index 9d9d170c1fb00fbd4bf35c1a2f04bcff6dca09cf..3bd39a625ae9f703cac0d38bde51b8f163ffbae9 100644
--- a/core/build.gradle.kts
+++ b/core/build.gradle.kts
@@ -4,6 +4,7 @@ import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
 plugins {
     java
     kotlin("jvm")
+    id("mindustryX.buildExt")
 }
 sourceSets.main {
     java.setSrcDirs(listOf("src/", layout.buildDirectory.dir("/generated/sources/annotationProcessor/java/main")))
diff --git a/settings.gradle b/settings.gradle
index 17add3c489d87175c3ceb175b03cba0b3a22ee79..bac8aba4ee445ef2ed036a90713f50dd77e18277 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -9,6 +9,8 @@ if(JavaVersion.current().ordinal() < JavaVersion.VERSION_16.ordinal()){
     throw new Exception("!!! YOU MUST USE JAVA 16 OR ABOVE TO COMPILE AND RUN MINDUSTRY !!! Read the README. Your version: ${System.properties["java.version"]}")
 }
 
+includeBuild("buildPlugins")
+
 include 'core', 'server', 'annotations', 'tools', 'tests'
 include 'desktop', 'ios'
 
