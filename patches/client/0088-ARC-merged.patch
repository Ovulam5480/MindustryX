From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Wed, 24 Jan 2024 15:39:50 +0800
Subject: [PATCH] ARC merged
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Way-Zer:
removed: LabelController,ARCChat,QuickCameraTable,changelogreaded, UpdateDialog, 主页标语(联网), 学术日报, 热更新(无效), 检查更新, arcPlayerEffect(VIP), District(区域规划器)
remove WindowManager.java
还原maxSchematicSize设置，优化ARCUnits
remove NumberFormat(已替代)
PICK 9eaa74b9 优化单位绘图执行逻辑，减少性能开销。同时不开启显示其他队伍状态时不绘制任何单位信息（除了碰撞箱）
  Lucky Clover <jmj18795967847@gmail.com> on 2024/2/29 at 10:09

MinRi2: improve drawText;PausedDialog重排

Cong0707: remove AboutCN_ARC

单位能力显示 优化
way-zer <himc.wicp@gmail.com> on 2024/4/18 at 23:22

remove getThemeColor()
way-zer <himc.wicp@gmail.com> on 2024/4/20 at 22:06

波次信息面板自动失焦;面板挤长ui
7c336939 MinRi2 <2275045670@qq.com> on 2024/4/20 at 22:25

* remove "selectTeam"(功能与工具箱重复)
* 移动QuickTool
* 清理ARCUI
way-zer <himc.wicp@gmail.com> on 2024/4/29

* remove "fontSize"
* remove "USIDDialog"(usid管理器)
* remove "AchievementsDialog"(学术成就)
* clean JoinDialog
* clean Block.drawPurePlaceText and Block.drawText
* 整理ARCBuilds ARCUnits 外部调用
way-zer <himc.wicp@gmail.com> on 2024/5/4

* fix "alwaysShowUnitRTSAi"
* KeyCode.unknown -> unset
* "@sectors.production" bug
* revert MenuFragment "discord and mobile info" button.
* fix about "unitTrans"
* 重制编辑器功能，修复错误的辅助线实现
way-zer <himc.wicp@gmail.com> on 2024/5/11

* clean "arcdrillmode"
* 还原unitHide实现;修复"showMineBeam"实现
* 从ARC同步MusicDialog(API更新)
* 重制炮台子弹范围显示
* arcSetCamera -> control.input.panCamera
way-zer <himc.wicp@gmail.com> on 2024/5/19

remove blockDrop and minimapTools(小地图工具)
way-zer <himc.wicp@gmail.com> on 2024/6/10 at 14:27

* remove arcChatPicture(图片分享) and MusicDialog(松鼠音乐)
* clean about `Format.duration` and `MessageDialog.share`
* clean about `ARCUI.arcInfo`
* split MessageDialog and clean ARCUI
* clean ARCVars
way-zer <himc.wicp@gmail.com> on 2024/6/14

* move package
* clean DrawUtilities
way-zer <himc.wicp@gmail.com> on 2024/6/15

clean PowerInfo, ArcMessageDialog, BlockSelectDialog, ItemImage
way-zer <himc.wicp@gmail.com> on 2024/6/30

remove minimap.forceShowPlayer, minimap.unitDetailsIcon, 左键切换视角(原版已实现右键切视角)
way-zer <himc.wicp@gmail.com> on 2024/7/2

* 修复BE版指挥菜单错乱
* 移除多余小地图按钮
way-zer <himc.wicp@gmail.com> on 2024/7/13
---
 core/src/mindustry/ai/BlockIndexer.java       |  116 ++
 core/src/mindustry/core/Renderer.java         |    3 +-
 core/src/mindustry/core/UI.java               |    3 +
 core/src/mindustry/editor/MapInfoDialog.java  |  146 ++-
 .../entities/abilities/ShieldArcAbility.java  |    7 +-
 .../mindustry/entities/comp/BuildingComp.java |   18 +-
 .../mindustry/entities/comp/PlayerComp.java   |   26 +-
 .../mindustry/entities/comp/ShieldComp.java   |    6 +
 .../mindustry/entities/comp/StatusComp.java   |   12 +
 core/src/mindustry/game/Schematic.java        |  158 +++
 core/src/mindustry/game/Universe.java         |    2 +-
 .../src/mindustry/graphics/BlockRenderer.java |   17 +-
 core/src/mindustry/graphics/Drawf.java        |   54 +
 core/src/mindustry/graphics/MenuRenderer.java |  114 +-
 .../mindustry/graphics/OverlayRenderer.java   |   84 +-
 core/src/mindustry/input/Binding.java         |   12 +-
 core/src/mindustry/input/DesktopInput.java    |   98 +-
 core/src/mindustry/input/InputHandler.java    |   56 +-
 core/src/mindustry/input/MobileInput.java     |   17 +-
 core/src/mindustry/type/UnitType.java         |  162 ++-
 core/src/mindustry/type/Weapon.java           |   25 +-
 core/src/mindustry/ui/Fonts.java              |    2 +-
 core/src/mindustry/ui/Minimap.java            |    2 -
 .../ui/dialogs/ContentInfoDialog.java         |   27 +-
 .../ui/dialogs/CustomRulesDialog.java         |  121 +-
 .../mindustry/ui/dialogs/DatabaseDialog.java  |    9 +-
 .../mindustry/ui/dialogs/PausedDialog.java    |   12 +-
 .../mindustry/ui/dialogs/PlanetDialog.java    |   70 +-
 .../ui/dialogs/SchematicsDialog.java          |  383 +++++-
 .../ui/dialogs/SettingsMenuDialog.java        |    1 -
 .../mindustry/ui/fragments/ChatFragment.java  |   25 +-
 .../ui/fragments/ConsoleFragment.java         |    3 +
 .../mindustry/ui/fragments/HudFragment.java   |  235 +++-
 .../mindustry/ui/fragments/MenuFragment.java  |   59 +-
 .../ui/fragments/PlacementFragment.java       |  212 +++-
 .../ui/fragments/PlayerListFragment.java      |  202 ++-
 core/src/mindustry/world/Block.java           |   18 +-
 core/src/mindustry/world/Build.java           |   50 +
 .../world/blocks/ConstructBlock.java          |   42 +-
 .../mindustry/world/blocks/ItemSelection.java |    3 +-
 .../world/blocks/defense/ForceProjector.java  |    4 +
 .../world/blocks/defense/MendProjector.java   |   16 +-
 .../blocks/defense/OverdriveProjector.java    |    7 +-
 .../blocks/defense/turrets/BaseTurret.java    |    5 +-
 .../blocks/defense/turrets/ReloadTurret.java  |   13 +
 .../world/blocks/defense/turrets/Turret.java  |   21 +
 .../world/blocks/production/Drill.java        |   23 +-
 .../blocks/production/GenericCrafter.java     |   29 +
 .../world/blocks/storage/CoreBlock.java       |    9 +
 core/src/mindustryX/Hooks.java                |   25 +-
 core/src/mindustryX/features/ArcBuilds.java   |  160 +++
 core/src/mindustryX/features/ArcOld.java      |   42 +
 core/src/mindustryX/features/ArcRadar.java    |  239 ++++
 core/src/mindustryX/features/ArcUnits.java    |  346 +++++
 .../mindustryX/features/ArcWaveSpawner.java   |  258 ++++
 core/src/mindustryX/features/MarkerType.java  |   12 +-
 .../mindustryX/features/PicToMindustry.java   |  343 +++++
 core/src/mindustryX/features/RenderExt.java   |   13 +-
 core/src/mindustryX/features/UIExt.java       |    1 +
 .../features/ui/ArcMessageDialog.java         |  419 +++++++
 .../mindustryX/features/ui/ArcPowerInfo.java  |   70 ++
 .../features/ui/ArcWaveInfoDialog.java        | 1117 +++++++++++++++++
 .../features/ui/BlockSelectDialog.java        |   65 +
 63 files changed, 5591 insertions(+), 258 deletions(-)
 create mode 100644 core/src/mindustryX/features/ArcBuilds.java
 create mode 100644 core/src/mindustryX/features/ArcRadar.java
 create mode 100644 core/src/mindustryX/features/ArcUnits.java
 create mode 100644 core/src/mindustryX/features/ArcWaveSpawner.java
 create mode 100644 core/src/mindustryX/features/PicToMindustry.java
 create mode 100644 core/src/mindustryX/features/ui/ArcMessageDialog.java
 create mode 100644 core/src/mindustryX/features/ui/ArcPowerInfo.java
 create mode 100644 core/src/mindustryX/features/ui/ArcWaveInfoDialog.java
 create mode 100644 core/src/mindustryX/features/ui/BlockSelectDialog.java

diff --git a/core/src/mindustry/ai/BlockIndexer.java b/core/src/mindustry/ai/BlockIndexer.java
index 7f944a3eb06180f9e2b760bbd5aa41709ddf6611..4972f424edd41b8a29d926a09bc55987066d33aa 100644
--- a/core/src/mindustry/ai/BlockIndexer.java
+++ b/core/src/mindustry/ai/BlockIndexer.java
@@ -42,6 +42,14 @@ public class BlockIndexer{
     /** Array used for returning and reusing. */
     private Seq<Building> breturnArray = new Seq<>(Building.class);
 
+    /** Stores all wallore quadrants on the map. Maps ID to qX to qY to a list of tiles with that ore. */
+    private IntSeq[][][] oresWall;
+    /** All wallores available on this map. */
+    private final ObjectIntMap<Item> allOresWall = new ObjectIntMap<>();
+
+    public Integer[] floorOresCount = new Integer[content.blocks().size +1];
+    public Integer[] wallOresCount = new Integer[content.blocks().size +1];
+
     public BlockIndexer(){
         clearFlags();
 
@@ -61,7 +69,15 @@ public class BlockIndexer{
             clearFlags();
 
             allOres.clear();
+            allOresWall.clear();
+            floorOresCount = new Integer[content.blocks().size +1];
+            wallOresCount = new Integer[content.blocks().size +1];
+            for (int ls=0;ls<content.blocks().size;ls++){
+                floorOresCount[ls] = 0;
+                wallOresCount[ls] = 0;
+            }
             ores = new IntSeq[content.items().size][][];
+            oresWall = new IntSeq[content.items().size][][];
             quadWidth = Mathf.ceil(world.width() / (float)quadrantSize);
             quadHeight = Mathf.ceil(world.height() / (float)quadrantSize);
             blocksPresent = new boolean[content.blocks().size];
@@ -94,8 +110,36 @@ public class BlockIndexer{
                         }
                         ores[drop.id][qx][qy].add(tile.pos());
                         allOres.increment(drop);
+                        if(tile.overlay().itemDrop!=null) floorOresCount[tile.overlay().id] +=1;
+                        else if(tile.floor().itemDrop!=null) floorOresCount[tile.floor().id] +=1;
+                    }else{
+                        if(oresWall[drop.id] == null){
+                            oresWall[drop.id] = new IntSeq[quadWidth][quadHeight];
+                        }
+                        if(oresWall[drop.id][qx][qy] == null){
+                            oresWall[drop.id][qx][qy] = new IntSeq(false, 16);
+                        }
+                        oresWall[drop.id][qx][qy].add(tile.pos());
+                        allOresWall.increment(drop);
+                        if(tile.overlay().itemDrop!=null) wallOresCount[tile.overlay().id] +=1;
                     }
                 }
+                if(tile.block()!=null && tile.block().itemDrop!=null){
+                    int qx = (tile.x / quadrantSize);
+                    int qy = (tile.y / quadrantSize);
+                    if(oresWall[tile.block().itemDrop.id] == null){
+                        oresWall[tile.block().itemDrop.id] = new IntSeq[quadWidth][quadHeight];
+                    }
+                    if(oresWall[tile.block().itemDrop.id][qx][qy] == null){
+                        oresWall[tile.block().itemDrop.id][qx][qy] = new IntSeq(false, 16);
+                    }
+                    oresWall[tile.block().itemDrop.id][qx][qy].add(tile.pos());
+                    allOresWall.increment(tile.block().itemDrop);
+                    wallOresCount[tile.block().id] +=1;
+                }
+                if(tile.block()!=null && tile.floor().liquidDrop!=null){
+                    floorOresCount[tile.floor().id] +=1;
+                }
             }
         });
     }
@@ -168,6 +212,50 @@ public class BlockIndexer{
                 seq.removeValue(pos);
                 allOres.increment(drop, -1);
             }
+
+
+            ///wallore
+            if(oresWall[drop.id] == null){
+                oresWall[drop.id] = new IntSeq[quadWidth][quadHeight];
+            }
+            if(oresWall[drop.id][qx][qy] == null){
+                oresWall[drop.id][qx][qy] = new IntSeq(false, 16);
+            }
+
+            pos = tile.pos();
+            seq = oresWall[drop.id][qx][qy];
+            //when the drop can be mined, record the ore position
+            if(tile.block() != Blocks.air && !seq.contains(pos)){
+                seq.add(pos);
+                allOresWall.increment(drop);
+            }else{
+                //otherwise, it likely became blocked, remove it (even if it wasn't there)
+                seq.removeValue(pos);
+                allOresWall.increment(drop, -1);
+            }
+        }
+        else if(tile.block()!=null && tile.block().itemDrop!=null){
+            int qx = tile.x / quadrantSize;
+            int qy = tile.y / quadrantSize;
+            ///wallore
+            if(oresWall[tile.block().itemDrop.id] == null){
+                oresWall[tile.block().itemDrop.id] = new IntSeq[quadWidth][quadHeight];
+            }
+            if(oresWall[tile.block().itemDrop.id][qx][qy] == null){
+                oresWall[tile.block().itemDrop.id][qx][qy] = new IntSeq(false, 16);
+            }
+
+            int pos = tile.pos();
+            var seq = oresWall[tile.block().itemDrop.id][qx][qy];
+            //when the drop can be mined, record the ore position
+            if(!seq.contains(pos)){
+                seq.add(pos);
+                allOresWall.increment(tile.block().itemDrop);
+            }else{
+                //otherwise, it likely became blocked, remove it (even if it wasn't there)
+                seq.removeValue(pos);
+                allOresWall.increment(tile.block().itemDrop, -1);
+            }
         }
 
     }
@@ -194,6 +282,10 @@ public class BlockIndexer{
         return allOres.get(item) > 0;
     }
 
+    public boolean hasOreWall(Item item){
+        return allOresWall.get(item) > 0;
+    }
+
     /** Returns all damaged tiles by team. */
     public Seq<Building> getDamaged(Team team){
         if(damagedTiles[team.id] == null){
@@ -437,6 +529,30 @@ public class BlockIndexer{
         return findClosestOre(unit.x, unit.y, item);
     }
 
+    public Tile findClosestWallOre(float xp, float yp, Item item){
+        if(oresWall[item.id] != null){
+            float minDst = 0f;
+            Tile closest = null;
+            for(int qx = 0; qx < quadWidth; qx++){
+                for(int qy = 0; qy < quadHeight; qy++){
+                    var arr = oresWall[item.id][qx][qy];
+                    if(arr != null && arr.size > 0){
+                        Tile tile = world.tile(arr.first());
+                        if(tile.block() != Blocks.air){
+                            float dst = Mathf.dst2(xp, yp, tile.worldx(), tile.worldy());
+                            if(closest == null || dst < minDst){
+                                closest = tile;
+                                minDst = dst;
+                            }
+                        }
+                    }
+                }
+            }
+            return closest;
+        }
+
+        return null;
+    }
     private void process(Tile tile){
         var team = tile.team();
         //only process entity changes with centered tiles
diff --git a/core/src/mindustry/core/Renderer.java b/core/src/mindustry/core/Renderer.java
index d21aa28efe895c7d76dfd903a9942a03f5a012b9..9e28b63e85dff5119c43f7dd3b278536f4d88c9f 100644
--- a/core/src/mindustry/core/Renderer.java
+++ b/core/src/mindustry/core/Renderer.java
@@ -28,6 +28,7 @@ import static arc.Core.*;
 import static mindustry.Vars.*;
 
 public class Renderer implements ApplicationListener{
+    public boolean fogEnabled = true;
     /** These are global variables, for headless access. Cached. */
     public static float laserOpacity = 0.5f, bridgeOpacity = 0.75f;
 
@@ -381,7 +382,7 @@ public class Renderer implements ApplicationListener{
         Draw.reset();
 
         Draw.draw(Layer.overlayUI, overlays::drawTop);
-        if(state.rules.fog) Draw.draw(Layer.fogOfWar, fog::drawFog);
+        if(state.rules.fog && (fogEnabled || state.rules.pvp && player.team().id != 255)) Draw.draw(Layer.fogOfWar, fog::drawFog);
         Draw.draw(Layer.space, () -> {
             if(landCore == null || landTime <= 0f) return;
             landCore.drawLanding(launching && launchCoreType != null ? launchCoreType : (CoreBlock)landCore.block);
diff --git a/core/src/mindustry/core/UI.java b/core/src/mindustry/core/UI.java
index 34ac2770a91fb02b7500fe46ec12f47bc384a061..0502e5341aaf07020b87bd4ae06b83dfbf211f7a 100644
--- a/core/src/mindustry/core/UI.java
+++ b/core/src/mindustry/core/UI.java
@@ -28,6 +28,7 @@ import mindustry.logic.*;
 import mindustry.ui.*;
 import mindustry.ui.dialogs.*;
 import mindustry.ui.fragments.*;
+import mindustryX.features.ui.*;
 
 import static arc.scene.actions.Actions.*;
 import static mindustry.Vars.*;
@@ -372,6 +373,7 @@ public class UI implements ApplicationListener, Loadable{
 
     /** Shows a fading label at the top of the screen. */
     public void showInfoToast(String info, float duration){
+        if (!info.contains("建筑过多单位") && !info.contains("可能造成服务器卡顿"))  ui.chatfrag.addMessage("[acid][公屏][white]"+info);
         var cinfo = Core.scene.find("coreinfo");
         Table table = new Table();
         table.touchable = Touchable.disabled;
@@ -388,6 +390,7 @@ public class UI implements ApplicationListener, Loadable{
 
     /** Shows a label at some position on the screen. Does not fade. */
     public void showInfoPopup(String info, float duration, int align, int top, int left, int bottom, int right){
+        if (!Core.settings.getBool("ShowInfoPopup")) return;
         Table table = new Table();
         table.setFillParent(true);
         table.touchable = Touchable.disabled;
diff --git a/core/src/mindustry/editor/MapInfoDialog.java b/core/src/mindustry/editor/MapInfoDialog.java
index ebc1f0b300d295e45333f1db38ea299c9658ec20..308ecad46ebe9fe68b3e5ab82822a8f7f6d372b0 100644
--- a/core/src/mindustry/editor/MapInfoDialog.java
+++ b/core/src/mindustry/editor/MapInfoDialog.java
@@ -1,5 +1,6 @@
 package mindustry.editor;
 
+import arc.Core;
 import arc.scene.ui.*;
 import arc.struct.*;
 import mindustry.*;
@@ -10,11 +11,12 @@ import mindustry.maps.filters.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.ui.dialogs.*;
+import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
 
 public class MapInfoDialog extends BaseDialog{
-    private WaveInfoDialog waveInfo  = new WaveInfoDialog();
+    private ArcWaveInfoDialog waveInfo  = new ArcWaveInfoDialog();
     private MapGenerateDialog generate = new MapGenerateDialog(false);
     private CustomRulesDialog ruleInfo = new CustomRulesDialog();
     private MapObjectivesDialog objectives = new MapObjectivesDialog();
@@ -33,12 +35,12 @@ public class MapInfoDialog extends BaseDialog{
         cont.clear();
 
         ObjectMap<String, String> tags = editor.tags;
-        
+
         cont.pane(t -> {
             t.add("@editor.mapname").padRight(8).left();
             t.defaults().padTop(15);
 
-            TextField name = t.field(tags.get("name", ""), text -> {
+            TextField name = t.field(state.isPlaying() ? state.map.name() : tags.get("name", ""), text -> {
                 tags.put("name", text);
             }).size(400, 55f).maxTextLength(50).get();
             name.setMessageText("@unknown");
@@ -46,14 +48,78 @@ public class MapInfoDialog extends BaseDialog{
             t.row();
             t.add("@editor.description").padRight(8).left();
 
-            TextArea description = t.area(tags.get("description", ""), Styles.areaField, text -> {
+            TextArea description = t.area(state.isPlaying() ? state.map.description() : tags.get("description", ""), Styles.areaField, text -> {
                 tags.put("description", text);
             }).size(400f, 140f).maxTextLength(1000).get();
 
+            t.row();
+            t.add("[acid]地图模式标签").padRight(8).left();
+
+            TextField modeName = t.field(state.isPlaying() ? state.rules.modeName : tags.get("modeName", ""), Styles.areaField, text -> {
+                tags.put("modeName", text);
+            }).size(400f, 55f).maxTextLength(1000).get();
+
+            if (Core.settings.getBool("arcPlayerList")) {
+                t.row();
+                t.add("[cyan]服务器标签").padRight(8).left();
+                t.button("编辑...", () -> {
+                    BaseDialog dialog = new BaseDialog("地图标签");
+
+                    dialog.cont.pane(td -> {
+                        td.add("[cyan]微泽系服务器标签编辑器 \n[white]BY [violet]Lucky Clover"
+                                + "\n\n[white]用于国内新版微泽系插件标签。"
+                                + "\n[orange]如果您发现标签无效，可能是您所在的服务器插件版本过低。请联系服主更新插件"
+                                + "\n所有标签与主服同步"
+                                + "\n\n[red]需要退出地图界面后重新打开才会更新"
+                                + "\n\n[white]如果有bug欢迎提出"
+                        );
+                        td.row();
+                        td.row();
+
+                        td.add("PVP保护时间(s)").left();
+                        td.field(arcReadStringLabel("@pvpProtect"), pama -> {
+                            arcAddStringLabel(pama, "@pvpProtect");
+                        }).maxTextLength(5).left();
+                        td.row();
+                        td.add("禁用队伍(如1,2,3...)").left();
+                        td.field(arcReadStringLabel("@banTeam"), pama -> {
+                            arcAddStringLabel(pama, "@banTeam");
+                        }).maxTextLength(5).left();
+                        td.row();
+                        td.add("插件选择").left();
+                        td.field(arcReadStringLabel("@mapScript"), pama -> {
+                            arcAddStringLabel(pama, "@mapScript");
+                        }).maxTextLength(6).left();
+                        td.row();
+                        td.check("空域管制 [acid]敌方核心保护区内禁止空军", arcreadBoolLable("[@limitAir]"), islimit -> {
+                            arcAddBoolLable(islimit, "[@limitAir]");
+                        }).left();
+                        td.row();
+                        td.check("塔防模式 [acid]怪物仅会在出生点地板移动，不会攻击", arcreadBoolLable("[@towerDefend]"), islimit -> {
+                            arcAddBoolLable(islimit, "[@towerDefend]");
+                        }).left();
+                        td.row();
+                        td.check("敌人掉落 [acid]非塔防模式下，打怪掉落资源", arcreadBoolLable("[@TDDrop]"), islimit -> {
+                            arcAddBoolLable(islimit, "[@TDDrop]");
+                        }).left();
+                        td.row();
+                        td.check("水漫金山 [acid]蓝队核心会释放洪水淹没你的核心", arcreadBoolLable("[@floodV2]"), islimit -> {
+                            arcAddBoolLable(islimit, "[@flood]");
+                        }).left();
+                    }).left();
+                    dialog.row();
+                    dialog.addCloseButton();
+                    dialog.margin(16f);
+
+                    dialog.show();
+                }).left().width(200f);
+            }
+
+
             t.row();
             t.add("@editor.author").padRight(8).left();
 
-            TextField author = t.field(tags.get("author", ""), text -> {
+            TextField author = t.field(state.isPlaying() ? state.map.author() : tags.get("author", ""), text -> {
                 tags.put("author", text);
             }).size(400, 55f).maxTextLength(50).get();
             author.setMessageText("@unknown");
@@ -117,9 +183,79 @@ public class MapInfoDialog extends BaseDialog{
 
             name.change();
             description.change();
+            modeName.change();
             author.change();
 
             t.margin(16f);
         });
+
+    }
+
+    private String arcReadStringLabel(String labelName) {
+        ObjectMap<String, String> tags = editor.tags;
+        String des = tags.get("description", "");
+        try {
+            int strLength = des.length();
+            int stopindex = 0;
+            for (int i = 0; i < strLength; i++) {
+                if (des.substring(i, i + 2 + labelName.length()).equals("[" + labelName + "=")) {
+                    stopindex = i;
+                    break;
+                }
+            }
+            for (int i = stopindex; i < strLength; i++) {
+                if (des.charAt(i) == ']') {
+                    return des.substring(stopindex + 2 + labelName.length(), i);
+                }
+            }
+        } catch (Exception e) {
+        }
+        return "<未设定参数>";
+    }
+
+    private void arcAddStringLabel(String parameter, String labelName) {
+        ObjectMap<String, String> tags = editor.tags;
+        String des = tags.get("description", "");
+        if (des.contains(labelName)) {
+            try {
+                int strLength = des.length();
+                int stopindex = 0;
+                for (int i = 0; i < strLength; i++) {
+                    if (des.substring(i, i + 2 + labelName.length()).equals("[" + labelName + "=")) {
+                        stopindex = i;
+                        break;
+                    }
+                }
+                for (int i = stopindex; i < strLength; i++) {
+                    if (des.charAt(i) == ']') {
+                        des = des.substring(0, stopindex + 2 + labelName.length()) + parameter + des.substring(i, strLength + 1);
+                        tags.put("description", des);
+                        break;
+                    }
+                }
+            } catch (Exception e) {
+            }
+        } else {
+            tags.put("description", des.concat("[" + labelName + "=" + parameter + "]"));
+        }
+    }
+
+    private boolean arcreadBoolLable(String labelname) {
+        ObjectMap<String, String> tags = editor.tags;
+        if (tags.get("description", "").contains(labelname)) {
+            return Boolean.TRUE;
+        } else {
+            return Boolean.FALSE;
+        }
+    }
+
+    private void arcAddBoolLable(Boolean isadd, String labelname) {
+        ObjectMap<String, String> tags = editor.tags;
+        String des = tags.get("description", "");
+        if (des.contains(labelname) && !isadd) {
+            tags.put("description", des.replace(labelname, ""));
+        } else if (!des.contains(labelname) && isadd) {
+            tags.put("description", des.concat(labelname));
+        }
     }
 }
diff --git a/core/src/mindustry/entities/abilities/ShieldArcAbility.java b/core/src/mindustry/entities/abilities/ShieldArcAbility.java
index 820255f6028e91d1a11ec7dbbee4a796e4d917a8..31580eb175170239b0bb6d970510d397be2a4d96 100644
--- a/core/src/mindustry/entities/abilities/ShieldArcAbility.java
+++ b/core/src/mindustry/entities/abilities/ShieldArcAbility.java
@@ -13,6 +13,7 @@ import mindustry.gen.*;
 import mindustry.graphics.*;
 import mindustry.type.*;
 import mindustry.ui.*;
+import mindustryX.features.ui.*;
 
 public class ShieldArcAbility extends Ability{
     private static Unit paramUnit;
@@ -60,7 +61,7 @@ public class ShieldArcAbility extends Ability{
     public boolean drawArc = true;
     /** If not null, will be drawn on top. */
     public @Nullable String region;
-    /** Color override of the shield. Uses unit shield colour by default. */ 
+    /** Color override of the shield. Uses unit shield colour by default. */
     public @Nullable Color color;
     /** If true, sprite position will be influenced by x/y. */
     public boolean offsetRegion = false;
@@ -80,7 +81,7 @@ public class ShieldArcAbility extends Ability{
 
     @Override
     public void update(Unit unit){
-        
+
         if(data < max){
             data += Time.delta * regen;
         }
@@ -135,6 +136,6 @@ public class ShieldArcAbility extends Ability{
 
     @Override
     public void displayBars(Unit unit, Table bars){
-        bars.add(new Bar("stat.shieldhealth", Pal.accent, () -> data / max)).row();
+        bars.add(new Bar(() -> (data < 0 ? "[red]" : "") + "\uE84D " + FormatDefault.percent(data, max), () -> Pal.accent, () -> data / max)).row();
     }
 }
diff --git a/core/src/mindustry/entities/comp/BuildingComp.java b/core/src/mindustry/entities/comp/BuildingComp.java
index f060739fd6a7005a039088151160f8865297dd14..32b2d39b2a86efbeeea90f636211bf2666c98d69 100644
--- a/core/src/mindustry/entities/comp/BuildingComp.java
+++ b/core/src/mindustry/entities/comp/BuildingComp.java
@@ -41,6 +41,7 @@ import mindustry.world.blocks.power.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
 import mindustry.world.modules.*;
+import mindustryX.features.*;
 
 import java.util.*;
 
@@ -77,6 +78,7 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
 
     transient boolean enabled = true;
     transient @Nullable Building lastDisabler;
+    transient @Nullable Building lastLogicController;
 
     @Nullable PowerModule power;
     @Nullable ItemModule items;
@@ -1421,7 +1423,8 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
         //derelict team icon currently doesn't display
         return team == Team.derelict ?
             block.localizedName + "\n" + Core.bundle.get("block.derelict") :
-            block.localizedName + (team == player.team() || team.emoji.isEmpty() ? "" : " " + team.emoji);
+                "[#" + team.color + "]" + (Core.settings.getBool("colorizedContent") && block.localizedName.length() > 11 ? block.localizedName.substring(11) : block.localizedName) + (team == player.team() || team.emoji.isEmpty() ? "" : " " + team.emoji
+                + (team.id > 5 ? "[" + team.id + "]" : ""));
     }
 
     public TextureRegion getDisplayIcon(){
@@ -1445,7 +1448,7 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
         table.row();
 
         //only display everything else if the team is the same
-        if(team == player.team()){
+        if(team == player.team() || RenderExt.showOtherInfo){
             table.table(bars -> {
                 bars.defaults().growX().height(18f).pad(4);
 
@@ -1546,6 +1549,15 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
             table.add(result).growX();
             table.row();
         }
+        if (lastLogicController != null) {
+            table.add(lastLogicController.block.emoji() + " [lightgray](" + lastLogicController.tileX() + ", " + lastLogicController.tileY() + ")").growX().left().row();
+        }
+        if (Time.time < healSuppressionTime){
+            table.add("\uF89B[red]\uE815").update(label -> {
+                if (healSuppressionTime > 0) label.setText("\uF89B[red]\uE815 [white]~ " + UI.formatTime(healSuppressionTime - Time.time));
+                else label.visible = false;
+            }).row();
+        }
     }
 
      /** Called when this block is tapped to build a UI on the table.
@@ -1561,7 +1573,7 @@ abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc, Timerc,
 
     /** Returns whether a hand cursor should be shown over this block. */
     public Cursor getCursor(){
-        return block.configurable && interactable(player.team()) ? SystemCursor.hand : SystemCursor.arrow;
+        return block.configurable && (RenderExt.showOtherInfo || interactable(player.team())) ? SystemCursor.hand : SystemCursor.arrow;
     }
 
     /**
diff --git a/core/src/mindustry/entities/comp/PlayerComp.java b/core/src/mindustry/entities/comp/PlayerComp.java
index bb62444ec4f5a4a2c36541147ca09cf3113328ad..90731e0c7ccc937e30561f2c381ddea6f9bf19f0 100644
--- a/core/src/mindustry/entities/comp/PlayerComp.java
+++ b/core/src/mindustry/entities/comp/PlayerComp.java
@@ -21,6 +21,8 @@ import mindustry.net.Administration.*;
 import mindustry.net.*;
 import mindustry.net.Packets.*;
 import mindustry.ui.*;
+import mindustry.world.blocks.defense.turrets.BaseTurret;
+import mindustry.world.blocks.production.GenericCrafter;
 import mindustry.world.blocks.storage.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
 import mindustryX.events.*;
@@ -301,7 +303,7 @@ abstract class PlayerComp implements UnitController, Entityc, Syncc, Timerc, Dra
         font.getData().setScale(0.25f / Scl.scl(1f));
         layout.setText(font, name);
 
-        if(!isLocal()){
+        if(Core.settings.getBool("arcSelfName") || !isLocal()){
             Draw.color(0f, 0f, 0f, 0.3f);
             Fill.rect(unit.x, unit.y + nameHeight - layout.height / 2, layout.width + 2, layout.height + 3);
             Draw.color();
@@ -366,6 +368,28 @@ abstract class PlayerComp implements UnitController, Entityc, Syncc, Timerc, Dra
         }
     }
 
+    public void buildDestroyedBlocks() {
+        if (unit.canBuild()) {
+            int count = 0;
+            for (Teams.BlockPlan plan : player.team().data().plans) {
+                if (within(plan.x * tilesize, plan.y * tilesize, buildingRange)) {
+                    unit.addBuild(new BuildPlan(plan.x, plan.y, plan.rotation, content.block(plan.block), plan.config));
+                    if (++count >= 255) break;
+                }
+            }
+        }
+    }
+
+    public void dropItems() {
+        if (state.rules.mode() == Gamemode.pvp || player.unit() == null || player.unit().stack.amount <= 0) {
+            return;
+        }
+        indexer.eachBlock(player.team(), player.x, player.y, itemTransferRange,
+                build -> build.acceptStack(player.unit().item(), player.unit().stack.amount, player.unit()) > 0 && (
+                        build.block instanceof BaseTurret || build.block instanceof GenericCrafter)
+                , build -> Call.transferInventory(player, build)
+        );
+    }
     void sendUnformatted(String unformatted){
         sendUnformatted(null, unformatted);
     }
diff --git a/core/src/mindustry/entities/comp/ShieldComp.java b/core/src/mindustry/entities/comp/ShieldComp.java
index c290fa6251edaaa4d2854fc6f06be8cdb6050dda..132785b228124519812c049ef93fd2e5adaeb641 100644
--- a/core/src/mindustry/entities/comp/ShieldComp.java
+++ b/core/src/mindustry/entities/comp/ShieldComp.java
@@ -1,5 +1,6 @@
 package mindustry.entities.comp;
 
+import arc.math.WindowedMean;
 import arc.util.*;
 import mindustry.*;
 import mindustry.annotations.Annotations.*;
@@ -22,6 +23,8 @@ abstract class ShieldComp implements Healthc, Posc{
     transient float armor;
     /** Shield opacity. */
     transient float shieldAlpha = 0f;
+    transient float lastHealth = 0f, lastShield = 0f;
+    transient WindowedMean healthBalance = new WindowedMean(120);
 
     @Replace
     @Override
@@ -70,5 +73,8 @@ abstract class ShieldComp implements Healthc, Posc{
     public void update(){
         shieldAlpha -= Time.delta / 15f;
         if(shieldAlpha < 0) shieldAlpha = 0f;
+        healthBalance.add(((health - lastHealth) + (shield - lastShield)) / Time.delta);
+        lastHealth = health;
+        lastShield = shield;
     }
 }
diff --git a/core/src/mindustry/entities/comp/StatusComp.java b/core/src/mindustry/entities/comp/StatusComp.java
index 4d3dd11dd07972d4c6dcada51ece6382586fb986..6ca8767b9e4c96cc3223f398360a3d85d955c132 100644
--- a/core/src/mindustry/entities/comp/StatusComp.java
+++ b/core/src/mindustry/entities/comp/StatusComp.java
@@ -240,4 +240,16 @@ abstract class StatusComp implements Posc, Flyingc{
     boolean hasEffect(StatusEffect effect){
         return applied.get(effect.id);
     }
+    void addEntry(StatusEffect effect, float duration) {
+        if (effect.reactive) apply(effect);
+        else {
+            StatusEntry entry = Pools.obtain(StatusEntry.class, StatusEntry::new);
+            entry.set(effect, duration);
+            statuses.add(entry);
+            effect.applied(self(), duration, false);
+        }
+    }
+    Seq<StatusEntry> statuses(){
+        return statuses;
+    }
 }
diff --git a/core/src/mindustry/game/Schematic.java b/core/src/mindustry/game/Schematic.java
index dde5886f6020aa1c372ac3346e81aab0c7fdedf7..4b5c81d32cda84f44ea177cf176f13484c0c7eea 100644
--- a/core/src/mindustry/game/Schematic.java
+++ b/core/src/mindustry/game/Schematic.java
@@ -8,7 +8,15 @@ import mindustry.mod.Mods.*;
 import mindustry.type.*;
 import mindustry.world.*;
 import mindustry.world.blocks.power.*;
+import mindustry.world.blocks.production.Fracker;
+import mindustry.world.blocks.production.GenericCrafter;
+import mindustry.world.blocks.production.Separator;
 import mindustry.world.blocks.storage.*;
+import mindustry.world.consumers.ConsumeItems;
+import mindustry.world.consumers.ConsumeLiquid;
+import mindustry.world.consumers.ConsumeLiquids;
+
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import static mindustry.Vars.*;
 
@@ -23,6 +31,9 @@ public class Schematic implements Publishable, Comparable<Schematic>{
     /** Associated mod. If null, no mod is associated with this schematic. */
     public @Nullable LoadedMod mod;
 
+    public ObjectFloatMap<Item> items;
+    public ObjectFloatMap<Liquid> liquids;
+
     public Schematic(Seq<Stile> tiles, StringMap tags, int width, int height){
         this.tiles = tiles;
         this.tags = tags;
@@ -30,6 +41,10 @@ public class Schematic implements Publishable, Comparable<Schematic>{
         this.height = height;
     }
 
+    public boolean containsBlock(Block block){
+        return tiles.find(tile -> tile.block == block) != null;
+    }
+
     public float powerProduction(){
         return tiles.sumf(s -> s.block instanceof PowerGenerator p ? p.getDisplayedPowerProduction() : 0f);
     }
@@ -38,6 +53,143 @@ public class Schematic implements Publishable, Comparable<Schematic>{
         return tiles.sumf(s -> s.block.consPower != null ? s.block.consPower.usage : 0f);
     }
 
+    public void calProduction() {
+        items = new ObjectFloatMap<>(content.items().copy().size << 1);
+        liquids = new ObjectFloatMap<>(content.liquids().copy().size << 1);
+        tiles.each(t -> {
+            if(t.block== null)
+                return;
+
+            if (t.block instanceof GenericCrafter gc) {
+                for(var c:gc.consumeBuilder){
+                    if(c.optional) continue;
+                    else if(c instanceof ConsumeItems consumeItems){
+                        for (ItemStack stack : consumeItems.items) {
+                            Item item = stack.item;
+                            items.put(item, items.get(item, 0) - stack.amount * 60f / gc.craftTime);
+                        }
+                    }
+                    else if(c instanceof ConsumeLiquid consumeLiquid){
+                        Liquid liquid = consumeLiquid.liquid;
+                        liquids.put(liquid, liquids.get(liquid, 0) - consumeLiquid.amount * 60f);
+                    }
+                    else if(c instanceof ConsumeLiquids consumeLiquids){
+                        for (LiquidStack stack : consumeLiquids.liquids) {
+                            Liquid liquid = stack.liquid;
+                            liquids.put(liquid, liquids.get(liquid, 0) - stack.amount * 60f);
+                        }
+                    }
+                }
+                if(gc.outputsItems()){
+                    for (ItemStack stack : gc.outputItems) {
+                        Item item = stack.item;
+                        items.put(item, items.get(item, 0) + stack.amount * 60f / gc.craftTime);
+                    }
+                }/*
+                if(gc.outputLiquid != null){
+                    liquids.put(gc.outputLiquid.liquid, liquids.get(gc.outputLiquid.liquid, 0) + gc.outputLiquid.amount * 60f);
+                }*/
+                if(gc.outputLiquids !=null) {
+                    for (LiquidStack stack : gc.outputLiquids) {
+                        Liquid liquid = stack.liquid;
+                        liquids.put(liquid, liquids.get(liquid, 0) + stack.amount * 60f);
+                    }
+                }
+            }
+            else if (t.block instanceof Separator s) {
+                for(var c:s.consumeBuilder){
+                    if(c.optional) continue;
+                    else if(c instanceof ConsumeItems consumeItems){
+                        for (ItemStack stack : consumeItems.items) {
+                            Item item = stack.item;
+                            items.put(item, items.get(item, 0) - stack.amount * 60f / s.craftTime);
+                        }
+                    }
+                    else if (c instanceof ConsumeLiquid consumeLiquid) {
+                        Liquid liquid = consumeLiquid.liquid;
+                        liquids.put(liquid, liquids.get(liquid, 0) - consumeLiquid.amount * 60f);
+                    }
+                }
+            }
+            else if (t.block instanceof Fracker f) {
+                for(var c:f.consumeBuilder) {
+                    if (c.optional) continue;
+                    else if (c instanceof ConsumeItems consumeItems) {
+                        for (ItemStack stack : consumeItems.items) {
+                            Item item = stack.item;
+                            items.put(item, items.get(item, 0) - stack.amount * f.itemUseTime / 60f);
+                        }
+                    }
+                }
+            }
+            else if (t.block instanceof PowerGenerator) {
+                if (t.block instanceof  ConsumeGenerator cg) {
+                    for(var c:cg.consumeBuilder){
+                        if(c.optional) continue;
+                        else if(c instanceof ConsumeItems consumeItems){
+                            for (ItemStack stack : consumeItems.items) {
+                                Item item = stack.item;
+                                items.put(item, items.get(item, 0) - stack.amount * 60f / cg.itemDuration);
+                            }
+                        }
+                        else if(c instanceof ConsumeLiquid consumeLiquid){
+                            Liquid liquid = consumeLiquid.liquid;
+                            liquids.put(liquid, liquids.get(liquid, 0) - consumeLiquid.amount * 60f);
+                        }
+                        else if(c instanceof ConsumeLiquids consumeLiquids){
+                            for (LiquidStack stack : consumeLiquids.liquids) {
+                                Liquid liquid = stack.liquid;
+                                liquids.put(liquid, liquids.get(liquid, 0) - stack.amount * 60f);
+                            }
+                        }
+                    }
+                }
+                else if (t.block instanceof NuclearReactor nr) {
+                    for(var c:nr.consumeBuilder){
+                        if(c.optional) continue;
+                        else if(c instanceof ConsumeItems consumeItems){
+                            for (ItemStack stack : consumeItems.items) {
+                                Item item = stack.item;
+                                items.put(item, items.get(item, 0) - stack.amount * 60f / nr.itemDuration);
+                            }
+                        }
+                        else if(c instanceof ConsumeLiquid consumeLiquid){
+                            Liquid liquid = consumeLiquid.liquid;
+                            liquids.put(liquid, liquids.get(liquid, 0) - consumeLiquid.amount * 60f);
+                        }
+                        else if(c instanceof ConsumeLiquids consumeLiquids){
+                            for (LiquidStack stack : consumeLiquids.liquids) {
+                                Liquid liquid = stack.liquid;
+                                liquids.put(liquid, liquids.get(liquid, 0) - stack.amount * 60f);
+                            }
+                        }
+                    }
+                }
+                else if (t.block instanceof ImpactReactor ir) {
+                    for(var c:ir.consumeBuilder){
+                        if(c.optional) continue;
+                        else if(c instanceof ConsumeItems consumeItems){
+                            for (ItemStack stack : consumeItems.items) {
+                                Item item = stack.item;
+                                items.put(item, items.get(item, 0) - stack.amount * 60f / ir.itemDuration);
+                            }
+                        }
+                        else if(c instanceof ConsumeLiquid consumeLiquid){
+                            Liquid liquid = consumeLiquid.liquid;
+                            liquids.put(liquid, liquids.get(liquid, 0) - consumeLiquid.amount * 60f);
+                        }
+                        else if(c instanceof ConsumeLiquids consumeLiquids){
+                            for (LiquidStack stack : consumeLiquids.liquids) {
+                                Liquid liquid = stack.liquid;
+                                liquids.put(liquid, liquids.get(liquid, 0) - stack.amount * 60f);
+                            }
+                        }
+                    }
+                }
+            }
+        });
+    }
+
     public ItemSeq requirements(){
         ItemSeq requirements = new ItemSeq();
 
@@ -142,6 +294,12 @@ public class Schematic implements Publishable, Comparable<Schematic>{
             block = Blocks.air;
         }
 
+        public Stile(Block block, int x, int y){
+            this.block = block;
+            this.x = (short)x;
+            this.y = (short)y;
+        }
+
         public Stile set(Stile other){
             block = other.block;
             x = other.x;
diff --git a/core/src/mindustry/game/Universe.java b/core/src/mindustry/game/Universe.java
index 4aa77d8be7d4876022746b93046e0e8587b9052b..849a46f6bae96b5a65e4874b2621acfcc7e4ded9 100644
--- a/core/src/mindustry/game/Universe.java
+++ b/core/src/mindustry/game/Universe.java
@@ -20,7 +20,7 @@ public class Universe{
     private int netSeconds;
     private float secondCounter;
     private int turn;
-    private float turnCounter;
+    public static float turnCounter;
 
     private @Nullable Schematic lastLoadout;
     private ItemSeq lastLaunchResources = new ItemSeq();
diff --git a/core/src/mindustry/graphics/BlockRenderer.java b/core/src/mindustry/graphics/BlockRenderer.java
index ea5060298da5e478b234e8d0575ab2ceedb5b6e6..e59bff905f7398b0eb3c780c0cda5a3035a75bf2 100644
--- a/core/src/mindustry/graphics/BlockRenderer.java
+++ b/core/src/mindustry/graphics/BlockRenderer.java
@@ -444,13 +444,18 @@ public class BlockRenderer{
                         Draw.z(Layer.block);
                     }
 
-                    if(build.team != pteam){
-                        if(build.block.drawTeamOverlay){
-                            build.drawTeam();
-                            Draw.z(Layer.block);
+                    if(build.team != pteam && build.block.drawTeamOverlay){
+                        Draw.z(Layer.block + 0.01f);
+                        build.drawTeam();
+                    }
+                    if(build.team == player.team() || RenderExt.showOtherInfo){
+                        if(renderer.drawStatus && block.hasConsumers){
+                            build.drawStatus();
+                        }
+                        if(RenderExt.drawBlockDisabled && !build.enabled()){
+                            Draw.z(Layer.power + 1);
+                            build.drawDisabled();
                         }
-                    }else if(renderer.drawStatus && block.hasConsumers){
-                        build.drawStatus();
                     }
                 }
                 Draw.reset();
diff --git a/core/src/mindustry/graphics/Drawf.java b/core/src/mindustry/graphics/Drawf.java
index 44cbc6b38ede0697af8af3321c342c7f117bdcbd..ed4bd9d05114a32e45e18117e02c2a60976f1498 100644
--- a/core/src/mindustry/graphics/Drawf.java
+++ b/core/src/mindustry/graphics/Drawf.java
@@ -148,6 +148,13 @@ public class Drawf{
         Drawf.line(Pal.accent, start.getX() + Tmp.v1.x, start.getY() + Tmp.v1.y, dest.getX() + Tmp.v2.x, dest.getY() + Tmp.v2.y);
     }
 
+    public static void limitLineColor(Position start, Position dest, float len1, float len2,Color color){
+        Tmp.v1.set(dest).sub(start).setLength(len1);
+        Tmp.v2.set(Tmp.v1).scl(-1f).setLength(len2);
+
+        Drawf.line(color, start.getX() + Tmp.v1.x, start.getY() + Tmp.v1.y, dest.getX() + Tmp.v2.x, dest.getY() + Tmp.v2.y);
+    }
+
     public static void dashLineDst(Color color, float x, float y, float x2, float y2){
         dashLine(color, x, y, x2, y2, (int)(Mathf.dst(x, y, x2, y2) / tilesize * 1.6f));
     }
@@ -220,6 +227,32 @@ public class Drawf{
         Draw.reset();
     }
 
+    public static void target2(float x, float y, float rad, float alpha, Color color){
+        // target but no border
+        Lines.stroke(1f);
+        Draw.color(color, alpha);
+        Lines.poly(x, y, 4, rad, Time.time * 1.5f);
+        Lines.spikes(x, y, 3f/7f * rad, 6f/7f * rad, 4, Time.time * 1.5f);
+        Draw.reset();
+    }
+
+    public static void targetc(float x, float y, float rad, float alpha, Color color){
+        // target but no border
+        Lines.stroke(1f);
+        Draw.color(color, alpha);
+        Lines.circle(x, y, rad);
+        Lines.spikes(x, y, 3f/7f * rad, 6f/7f * rad, 4, Time.time * 1.5f);
+        Draw.reset();
+    }
+
+    public static void targetd(float x, float y, float rad, float alpha, Color color){
+        // target but no border
+        Lines.stroke(1f);
+        Draw.color(color, alpha);
+        Lines.spikes(x, y, 3f/7f * rad, 6f/7f * rad, 4, Time.time * 1.5f);
+        Draw.reset();
+    }
+
     /** Sets Draw.z to the text layer, and returns the previous layer. */
     public static float text(){
         float z = Draw.z();
@@ -390,6 +423,27 @@ public class Drawf{
         Draw.color();
     }
 
+    public static void simpleArrow(float x, float y, float x2, float y2, float length, float radius){
+        float angle = Angles.angle(x, y, x2, y2);
+        Tmp.v1.set(x2, y2).sub(x, y).limit(length);
+        float vx = Tmp.v1.x + x, vy = Tmp.v1.y + y;
+        Fill.poly(vx, vy, 3, radius, angle);
+    }
+
+    public static void simpleArrow(float x, float y, float x2, float y2, float length, float radius, Color color){
+        simpleArrow(x, y, x2, y2, length, radius, color,1f);
+    }
+
+    public static void simpleArrow(float x, float y, float x2, float y2, float length, float radius, Color color,float alpha){
+        float angle = Angles.angle(x, y, x2, y2);
+        Tmp.v1.set(x2, y2).sub(x, y).limit(length);
+        float vx = Tmp.v1.x + x, vy = Tmp.v1.y + y;
+
+        Draw.color(color,alpha);
+        Fill.poly(vx, vy, 3, radius, angle);
+        Draw.color();
+    }
+
     public static void laser(TextureRegion line, TextureRegion edge, float x, float y, float x2, float y2){
         laser(line, edge, edge, x, y, x2, y2, 1f);
     }
diff --git a/core/src/mindustry/graphics/MenuRenderer.java b/core/src/mindustry/graphics/MenuRenderer.java
index 949d03f914d70c9bb9826ebeb033458fbeb19cc8..fd2e601e673dfcd266a9501db7121dd8bbbf79a9 100644
--- a/core/src/mindustry/graphics/MenuRenderer.java
+++ b/core/src/mindustry/graphics/MenuRenderer.java
@@ -27,9 +27,10 @@ public class MenuRenderer implements Disposable{
     private CacheBatch batch;
     private float time = 0f;
     private float flyerRot = 45f;
-    private int flyers = Mathf.chance(0.2) ? Mathf.random(35) : Mathf.random(15);
-    //no longer random or "dynamic", mod units in the menu look jarring, and it's not worth the configuration effort
-    private UnitType flyerType = Seq.with(UnitTypes.flare, UnitTypes.horizon, UnitTypes.zenith, UnitTypes.mono, UnitTypes.poly, UnitTypes.mega, UnitTypes.alpha, UnitTypes.beta, UnitTypes.gamma).random();
+    private int flyers = Mathf.chance(0.2) ? Mathf.random(45)  : Mathf.random(25) ;
+    //private UnitType flyerType = content.units().select(u -> !u.isHidden() && u.hitSize <= 20f && u.flying && u.region.found()).random();
+    private UnitType flyerType = content.units().select(u -> !u.isHidden() && u.hitSize >= 10f && u.region.found()).random();
+    private UnitType followType = content.units().select(u -> !u.isHidden() && u.hitSize < flyerType.hitSize*0.8f && u.region.found()).random();
 
     public MenuRenderer(){
         Time.mark();
@@ -230,7 +231,12 @@ public class MenuRenderer implements Disposable{
         batch.drawCache(cacheWall);
         batch.endDraw();
 
-        drawFlyers();
+        if (Core.settings.getBool("menuFlyersFollower")){
+            drawFollowFlyers();
+        }
+        else{
+            drawFlyers();
+        }
 
         Draw.proj(mat);
         Draw.color(0f, 0f, 0f, darkness);
@@ -238,6 +244,77 @@ public class MenuRenderer implements Disposable{
         Draw.color();
     }
 
+    private void drawFollowFlyers(){
+        Draw.color(0f, 0f, 0f, 0.4f);
+
+        TextureRegion icon = flyerType.fullIcon;
+
+        float size = Math.max(icon.width, icon.height) * Draw.scl * 1.6f;
+
+        float sizebehind = Math.max(icon.width, icon.height) * Draw.scl * 1.6f;
+
+        TextureRegion followcion = followType.fullIcon;
+        float followsize = Math.max(icon.width, icon.height) * Draw.scl * 1.6f;
+
+        flyers((x, y) -> {
+            Draw.rect(icon, x - 12f, y - 13f, flyerRot - 90);
+            Draw.rect(followcion, x - 12f - sizebehind/2, y - 13f - sizebehind/3, flyerRot - 90);
+            Draw.rect(followcion, x - 12f - sizebehind/3, y - 13f - sizebehind/2, flyerRot - 90);
+        });
+
+        flyers((x, y) -> {
+            Draw.rect("circle-shadow", x, y, size, size);
+            Draw.rect("circle-shadow", x - sizebehind/3, y - sizebehind/2, followsize, followsize);
+            Draw.rect("circle-shadow", x - sizebehind/2, y - sizebehind/3, followsize, followsize);
+        });
+        Draw.color();
+
+
+        flyers((x, y) -> {
+            float engineOffset = flyerType.engineOffset, engineSize = flyerType.engineSize, rotation = flyerRot;
+
+            Draw.color(Pal.engine);
+            Fill.circle(x + Angles.trnsx(rotation + 180, engineOffset), y + Angles.trnsy(rotation + 180, engineOffset),
+            engineSize + Mathf.absin(Time.time, 2f, engineSize / 4f));
+
+            Draw.color(Color.white);
+            Fill.circle(x + Angles.trnsx(rotation + 180, engineOffset - 1f), y + Angles.trnsy(rotation + 180, engineOffset - 1f),
+            (engineSize + Mathf.absin(Time.time, 2f, engineSize / 4f)) / 2f);
+            Draw.color();
+
+            Draw.rect(icon, x, y, flyerRot - 90);
+            //follower1
+            Draw.rect(followcion, x - sizebehind/3, y - sizebehind/2, flyerRot - 90);
+
+            //follower2
+            Draw.rect(followcion, x - sizebehind/2, y - sizebehind/3, flyerRot - 90);
+
+            if(Core.settings.getBool("menuFlyersRange")){
+                float curStroke = (float)Core.settings.getInt("playerEffectCurStroke")/10f;
+                Color effectcolor = Pal.accent;
+
+                float sectorRad = 0.14f, rotateSpeed = 0.5f;
+                int sectors = 5;
+
+                Lines.stroke(Lines.getStroke() * curStroke);
+
+                Draw.z(Layer.shields + 6.5f);
+                Draw.color(effectcolor);
+
+                //Tmp.v1.trns(flyerType.rotation - 90, x, y).add(x, y);
+                float rx = Tmp.v1.x, ry = Tmp.v1.y;
+
+                if(curStroke > 0){
+                    for(int i = 0; i < sectors; i++){
+                        float rot = i * 360f/sectors + Time.time * rotateSpeed;
+                        Lines.arc(x, y, flyerType.maxRange, sectorRad, rot);
+                    }
+                }
+                Draw.reset();
+            }
+        });
+    }
+
     private void drawFlyers(){
         Draw.color(0f, 0f, 0f, 0.4f);
 
@@ -267,6 +344,32 @@ public class MenuRenderer implements Disposable{
             Draw.color();
 
             Draw.rect(icon, x, y, flyerRot - 90);
+
+
+
+            if(Core.settings.getBool("menuFlyersRange")){
+                float curStroke = (float)Core.settings.getInt("playerEffectCurStroke")/10f;
+                Color effectcolor = Pal.accent;
+
+                float sectorRad = 0.14f, rotateSpeed = 0.5f;
+                int sectors = 5;
+
+                Lines.stroke(Lines.getStroke() * curStroke);
+
+                Draw.z(Layer.shields + 6.5f);
+                Draw.color(effectcolor);
+
+                //Tmp.v1.trns(flyerType.rotation - 90, x, y).add(x, y);
+                float rx = Tmp.v1.x, ry = Tmp.v1.y;
+
+                if(curStroke > 0){
+                    for(int i = 0; i < sectors; i++){
+                        float rot = i * 360f/sectors + Time.time * rotateSpeed;
+                        Lines.arc(x, y, flyerType.maxRange, sectorRad, rot);
+                    }
+                }
+                Draw.reset();
+            }
         });
     }
 
@@ -275,8 +378,9 @@ public class MenuRenderer implements Disposable{
         float th = height * tilesize * 1f + tilesize;
         float range = 500f;
         float offset = -100f;
+        int flyersCount = flyers + Core.settings.getInt("menuFlyersCount");
 
-        for(int i = 0; i < flyers; i++){
+        for(int i = 0; i < flyersCount; i++){
             Tmp.v1.trns(flyerRot, time * (flyerType.speed));
 
             cons.get(
diff --git a/core/src/mindustry/graphics/OverlayRenderer.java b/core/src/mindustry/graphics/OverlayRenderer.java
index 8346eb94d62f3d9cb57e4f63ed39ac34cb07c84d..4d8a5c1d39dc3daac4b27fb078c0327c629512c1 100644
--- a/core/src/mindustry/graphics/OverlayRenderer.java
+++ b/core/src/mindustry/graphics/OverlayRenderer.java
@@ -15,8 +15,8 @@ import mindustry.game.*;
 import mindustry.game.Teams.*;
 import mindustry.gen.*;
 import mindustry.input.*;
-import mindustry.world.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -179,39 +179,83 @@ public class OverlayRenderer{
                     //it must be clear that there is a core here.
                     if(/*core.wasVisible && */Core.camera.bounds(Tmp.r1).overlaps(Tmp.r2.setCentered(core.x, core.y, state.rules.enemyCoreBuildRadius * 2f))){
                         Draw.color(Color.darkGray);
+                        Draw.alpha(0.7f);
                         Lines.circle(core.x, core.y - 2, state.rules.enemyCoreBuildRadius);
                         Draw.color(Pal.accent, core.team.color, 0.5f + Mathf.absin(Time.time, 10f, 0.5f));
+                        Draw.alpha(0.7f);
                         Lines.circle(core.x, core.y, state.rules.enemyCoreBuildRadius);
                     }
                 });
-            }
-        }
+                player.team().cores().each(core ->{
+                    if(state.rules.pvp && Core.camera.bounds(Tmp.r1).overlaps(Tmp.r2.setCentered(core.x, core.y, state.rules.enemyCoreBuildRadius * 2f))){
 
-        Lines.stroke(2f);
-        Draw.color(Color.gray, Color.lightGray, Mathf.absin(Time.time, 8f, 1f));
+                        Draw.color(Color.darkGray);
+                        Draw.alpha(0.4f);
+                        Lines.circle(core.x, core.y - 2, state.rules.enemyCoreBuildRadius);
+                        Draw.color(Pal.accent, core.team.color, 0.5f + Mathf.absin(Time.time, 10f, 0.5f));
+                        Draw.alpha(0.4f);
+                        Lines.circle(core.x, core.y, state.rules.enemyCoreBuildRadius);
+                    }
 
+                });
+            }
+        }
+        /*
         if(state.hasSpawns()){
-            for(Tile tile : spawner.getSpawns()){
-                if(tile.within(player.x, player.y, state.rules.dropZoneRadius + spawnerMargin)){
-                    Draw.alpha(Mathf.clamp(1f - (player.dst(tile) - state.rules.dropZoneRadius) / spawnerMargin));
+            Lines.stroke(2f);
+            Draw.color(Color.gray, Color.lightGray, Mathf.absin(Time.time, 8f, 1f));
+
+            if (Core.settings.getBool("alwaysshowdropzone")) {
+                Draw.alpha(0.8f);
+                for(Tile tile : spawner.getSpawns()) {
                     Lines.dashCircle(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius);
                 }
             }
-        }
+            else {
+                for(Tile tile : spawner.getSpawns()) {
+                    if (tile.within(player.x, player.y, state.rules.dropZoneRadius + spawnerMargin)) {
+                        Draw.alpha(Mathf.clamp(1f - (player.dst(tile) - state.rules.dropZoneRadius) / spawnerMargin));
+                        Lines.dashCircle(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius);
+                    }
+                }
+            }
+            if (Core.settings.getBool("showFlyerSpawn") && spawner.countSpawns() < 20) {
+                for(Tile tile : spawner.getSpawns()) {
+                    float angle = Angles.angle(world.width() / 2f, world.height() / 2f, tile.x, tile.y);
+                    float trns = Math.max(world.width(), world.height()) * Mathf.sqrt2 * tilesize;
+                    float spawnX = Mathf.clamp(world.width() * tilesize / 2f + Angles.trnsx(angle, trns), 0, world.width() * tilesize);
+                    float spawnY = Mathf.clamp(world.height() * tilesize / 2f + Angles.trnsy(angle, trns), 0, world.height() * tilesize);
+                    if (Core.settings.getBool("showFlyerSpawnLine")) {
+                        Draw.color(Color.red, 0.5f);
+                        Lines.line(tile.worldx(), tile.worldy(), spawnX, spawnY);
+                    }
+                    Draw.color(Color.gray, Color.lightGray, Mathf.absin(Time.time, 8f, 1f));
+                    Draw.alpha(0.8f);
+                    Lines.dashCircle(spawnX, spawnY, 5f * tilesize);
 
-        Draw.reset();
+                    Draw.color();
+                    Draw.alpha(0.5f);
+                    Draw.rect(UnitTypes.zenith.fullIcon, spawnX, spawnY);
+                }
+            }
+            Draw.reset();
+        }
+        */
+        ArcWaveSpawner.drawSpawner();
 
         //draw selected block
         if(input.block == null && !Core.scene.hasMouse()){
             Vec2 vec = Core.input.mouseWorld(input.getMouseX(), input.getMouseY());
             Building build = world.buildWorld(vec.x, vec.y);
 
-            if(build != null && build.team == player.team()){
+            //if(build != null && build.team == player.team()){
+            if(build != null){
                 build.drawSelect();
                 if(!build.enabled && build.block.drawDisabled){
                    build.drawDisabled();
                 }
-
+            }
+            if(build != null && build.team == player.team()){
                 if(Core.input.keyDown(Binding.rotateplaced) && build.block.rotate && build.block.quickRotate && build.interactable(player.team())){
                     control.input.drawArrow(build.block, build.tileX(), build.tileY(), build.rotation, true);
                     Draw.color(Pal.accent, 0.3f + Mathf.absin(4f, 0.2f));
@@ -223,12 +267,22 @@ public class OverlayRenderer{
 
         input.drawOverSelect();
 
+        //单位射程
+        if(ui.hudfrag.blockfrag.hover() instanceof Unit unit){
+            Draw.reset();
+            Draw.color(unit.team.color);
+            Lines.dashCircle(unit.x, unit.y, unit.type.range);
+        }
+
         if(ui.hudfrag.blockfrag.hover() instanceof Unit unit && unit.controller() instanceof LogicAI ai && ai.controller != null && ai.controller.isValid()){
             var build = ai.controller;
             Drawf.square(build.x, build.y, build.block.size * tilesize/2f + 2f);
             if(!unit.within(build, unit.hitSize * 2f)){
                 Drawf.arrow(unit.x, unit.y, build.x, build.y, unit.hitSize *2f, 4f);
             }
+			Draw.color(Pal.accent);
+            Lines.line(unit.x, unit.y, build.x, build.y);
+            Draw.color();
         }
 
         //draw selection overlay when dropping item
@@ -257,6 +311,12 @@ public class OverlayRenderer{
                 }
             }
         }
+
+        ArcRadar.drawScanner();
+        ArcScanMode.draw();
+        if(player.unit() instanceof BlockUnitc unitc){
+            unitc.tile().drawSelect();
+        }
     }
 
     public void checkApplySelection(Unit u){
diff --git a/core/src/mindustry/input/Binding.java b/core/src/mindustry/input/Binding.java
index 4bb4579c66cc80af91b8e78a0f37dc9749a22822..570aaa356ded3a4a6d9a8ef60d22a35c4fdbe750 100644
--- a/core/src/mindustry/input/Binding.java
+++ b/core/src/mindustry/input/Binding.java
@@ -99,11 +99,17 @@ public enum Binding implements KeyBind{
     chat_mode(KeyCode.tab),
     console(KeyCode.f8),
 
+    superUnitEffect(KeyCode.o,"ARC"),
+    showRTSAi(KeyCode.l),
+    arcDetail(KeyCode.unset),
+    arcScanMode(KeyCode.unset),
+    oreAdsorption(KeyCode.unset),
+
     //MDTX
-    toggle_unit(KeyCode.unknown, "mindustryX"),
+    toggle_unit(KeyCode.unset, "mindustryX"),
     point(KeyCode.j),
-    lockonLastMark(KeyCode.unknown),
-    toggle_block_render(KeyCode.unknown),
+    lockonLastMark(KeyCode.unset),
+    toggle_block_render(KeyCode.unset),
     ;
 
     private final KeybindValue defaultValue;
diff --git a/core/src/mindustry/input/DesktopInput.java b/core/src/mindustry/input/DesktopInput.java
index 1fc15522d18bf8ca80f7365d68f4a7a7b1fd076c..68df7b6759f42ffabc36bffdd204370ca0ca37d1 100644
--- a/core/src/mindustry/input/DesktopInput.java
+++ b/core/src/mindustry/input/DesktopInput.java
@@ -14,17 +14,25 @@ import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
 import mindustry.*;
+import mindustry.content.Items;
+import mindustry.content.UnitTypes;
 import mindustry.core.*;
+import mindustry.entities.Predict;
+import mindustry.entities.Units;
 import mindustry.entities.units.*;
 import mindustry.game.EventType.*;
 import mindustry.game.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
+import mindustry.type.UnitType;
 import mindustry.ui.*;
 import mindustry.world.*;
+import mindustry.world.blocks.ControlBlock;
+import mindustryX.features.*;
 
 import static arc.Core.camera;
 import static arc.Core.*;
+import static mindustry.Vars.net;
 import static mindustry.Vars.*;
 import static mindustry.input.PlaceMode.*;
 
@@ -56,6 +64,10 @@ public class DesktopInput extends InputHandler{
     /** Time of most recent control group selection */
     public long lastCtrlGroupSelectMillis;
 
+    public boolean autoAim = false;
+    /** Current thing being shot at. */
+    public @Nullable Teamc target;
+
     boolean showHint(){
         return ui.hudfrag.shown && Core.settings.getBool("hints") && selectPlans.isEmpty() && !player.dead() &&
             (!isBuilding && !Core.settings.getBool("buildautopause") || player.unit().isBuilding() || !player.dead() && !player.unit().spawnedByCore());
@@ -102,6 +114,10 @@ public class DesktopInput extends InputHandler{
                 b.table(a -> {
                     a.button("@schematic.add", Icon.save, this::showSchematicSave).colspan(2).size(250f, 50f).disabled(f -> lastSchematic == null || lastSchematic.file != null);
                 });
+                b.row();
+                b.table(a -> {
+                    a.button("@schematic.preview", Icon.info, this::showSchematicPreview).colspan(2).size(250f, 50f).disabled(f -> lastSchematic == null || lastSchematic.file != null);
+                });
             }).margin(6f);
         });
     }
@@ -229,7 +245,8 @@ public class DesktopInput extends InputHandler{
         }
 
         if((Math.abs(Core.input.axis(Binding.move_x)) > 0 || Math.abs(Core.input.axis(Binding.move_y)) > 0 || input.keyDown(Binding.mouse_move)) && (!scene.hasField())){
-            panning = false;
+            if(!Core.settings.getBool("removePan")) panning = false;
+            follow = null;
         }
 
         if(!locked){
@@ -404,7 +421,8 @@ public class DesktopInput extends InputHandler{
             }
         }
 
-        if(player.dead() || locked){
+        //if(player.dead() || locked){
+        if(locked){
             cursorType = SystemCursor.arrow;
             if(!Core.scene.hasMouse()){
                 Core.graphics.cursor(cursorType);
@@ -772,6 +790,14 @@ public class DesktopInput extends InputHandler{
                 Core.settings.put("lasersopacity", 0);
             }
         }
+        if (input.keyDown(Binding.oreAdsorption) && player.unit().tileOn() != null) {
+            player.unit().tileOn().circle(Mathf.ceil(player.unit().type.mineRange / 8f), tile -> {
+                Tile ptile = player.unit().mineTile;
+                if ((ptile == null || player.dst(ptile) > player.dst(tile) || ptile.drop() == Items.sand) && canMine(tile) && tile.drop() != Items.sand) {
+                    player.unit().mineTile = tile;
+                }
+            });
+        }
     }
 
     @Override
@@ -846,7 +872,7 @@ public class DesktopInput extends InputHandler{
     }
 
     protected void updateMovement(Unit unit){
-        boolean omni = unit.type.omniMovement;
+        UnitType type = unit.type;
 
         float speed = unit.speed();
         float xa = Core.input.axis(Binding.move_x);
@@ -858,23 +884,69 @@ public class DesktopInput extends InputHandler{
             movement.add(input.mouseWorld().sub(player).scl(1f / 25f * speed)).limit(speed);
         }
 
-        float mouseAngle = Angles.mouseAngle(unit.x, unit.y);
-        boolean aimCursor = omni && player.shooting && unit.type.hasWeapons() && unit.type.faceTarget && !boosted;
+        boolean busy = unit.mining() || unit.activelyBuilding();
 
-        if(aimCursor){
-            unit.lookAt(mouseAngle);
-        }else{
+        if (Core.settings.getBool("playerNeedShooting")){
+            busy = false;
+        }
+
+        boolean manualShoot = Core.input.keyDown(Binding.select) && shouldShoot && !busy && (type.hasWeapons() || UnitTypes.block.equals(type)) && !boosted;
+
+        float mouseX = unit.aimX(), mouseY = unit.aimY();
+        Vec2 aimPos = Core.input.mouseWorld();
+
+        float lookAtAngle = Angles.mouseAngle(unit.x, unit.y);
+
+        if(target != null) {
+            boolean validHealTarget = type.canHeal && target instanceof Building b && b.isValid() && target.team() == unit.team && b.damaged() && target.within(unit, type.range);
+            if ((Units.invalidateTarget(target, unit, type.range) && !validHealTarget) || state.isEditor()) {
+                target = null;
+            }
+        }
+
+        if (!manualShoot && Core.settings.getBool("autotarget") && !busy) {
+            if (target == null) {
+                float range = unit.hasWeapons() ? unit.range() : 0f;
+                player.shooting = false;
+                if(!(player.unit() instanceof BlockUnitUnit u && u.tile() instanceof ControlBlock c && !c.shouldAutoTarget())){
+                    target = Units.closestTarget(unit.team, unit.x, unit.y, range, u -> u.checkTarget(type.targetAir, type.targetGround), u -> type.targetGround);
+
+                    if(type.canHeal && target == null){
+                        target = Geometry.findClosest(unit.x, unit.y, indexer.getDamaged(Team.sharded));
+                        if(target != null && !unit.within(target, range)){
+                            target = null;
+                        }
+                    }
+                }
+            }
+            else {
+                Vec2 intercept = Predict.intercept(unit, target, unit.hasWeapons() ? type.weapons.first().bullet.speed : 0f);
+
+                mouseX = intercept.x;
+                mouseY = intercept.y;
+                player.shooting = !boosted;
+
+                aimPos = intercept;
+                lookAtAngle = unit.angleTo(intercept);
+            }
+        }
+        else {
+            target = null;
+        }
+        if (type.omniMovement && type.faceTarget && unit.isShooting) {
+            unit.lookAt(lookAtAngle);
+        }
+        else {
             unit.lookAt(unit.prefRotation());
         }
 
         unit.movePref(movement);
-
-        unit.aim(Core.input.mouseWorld());
+        if (!autoAim) unit.aim(aimPos);
         unit.controlWeapons(true, player.shooting && !boosted);
 
-        player.boosting = Core.input.keyDown(Binding.boost);
-        player.mouseX = unit.aimX();
-        player.mouseY = unit.aimY();
+        player.boosting = Core.input.keyDown(Binding.boost) || Core.settings.getBool("forceBoost");
+        player.mouseX = mouseX;
+        player.mouseY = mouseY;
 
         //update payload input
         if(unit instanceof Payloadc){
diff --git a/core/src/mindustry/input/InputHandler.java b/core/src/mindustry/input/InputHandler.java
index 091e13a8586e5dee6fc98ec8c8a5acd63b2898a3..d506f00d0bd6de17b7f4a69d4e154255855c1e9a 100644
--- a/core/src/mindustry/input/InputHandler.java
+++ b/core/src/mindustry/input/InputHandler.java
@@ -36,11 +36,13 @@ import mindustry.world.*;
 import mindustry.world.blocks.ConstructBlock.*;
 import mindustry.world.blocks.*;
 import mindustry.world.blocks.distribution.*;
+import mindustry.world.blocks.logic.*;
 import mindustry.world.blocks.payloads.*;
 import mindustry.world.blocks.storage.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
 import mindustry.world.meta.*;
 import mindustryX.features.*;
+import mindustryX.features.func.*;
 
 import java.util.*;
 
@@ -58,6 +60,8 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     final static int maxLength = 100;
     final static Rect r1 = new Rect(), r2 = new Rect();
     final static Seq<Unit> tmpUnits = new Seq<>(false);
+    public static Player follow;
+    public static int followIndex = 0;
     final static Binding[] controlGroupBindings = {
     Binding.block_select_01,
     Binding.block_select_02,
@@ -108,6 +112,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     /** Groups of units saved to different hotkeys */
     public IntSeq[] controlGroups = new IntSeq[controlGroupBindings.length];
 
+    public Rect lastSelection = new Rect();
     private Seq<BuildPlan> plansOut = new Seq<>(BuildPlan.class);
     private QuadTree<BuildPlan> playerPlanTree = new QuadTree<>(new Rect());
 
@@ -626,7 +631,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
                 player.con.send(packet, true);
             }
 
-            throw new ValidateException(player, "Player cannot configure a tile.");
+            if(headless) throw new ValidateException(player, "Player cannot configure a tile.");
         }
         build.configured(player == null || player.dead() ? null : player.unit(), value);
         Events.fire(new ConfigEvent(build, player, value));
@@ -650,9 +655,8 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
             throw new ValidateException(player, "Player cannot control a building.");
         }
 
-        if(player.team() == build.team && build.canControlSelect(player.unit())){
+        if((player.team() == build.team || (build instanceof CoreBuild && state.rules.editor)) && build.canControlSelect(player.unit())){
             var before = player.unit();
-
             build.onControlSelect(player.unit());
 
             if(!before.dead && before.spawnedByCore && !before.isPlayer()){
@@ -853,6 +857,10 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
                 }
             }
         }
+
+        if(follow != null && !follow.dead()){
+            Core.camera.position.lerpDelta(follow, 0.08f);
+        }
     }
 
     public void checkUnit(){
@@ -1006,6 +1014,8 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
                     attack = selectedEnemyUnit(target.x, target.y);
                 }
 
+                if(input.keyDown(KeyCode.altLeft)) attack = null;
+
                 int[] ids = new int[selectedUnits.size];
                 for(int i = 0; i < ids.length; i++){
                     ids[i] = selectedUnits.get(i).id;
@@ -1201,6 +1211,11 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
         });
     }
 
+    protected void showSchematicPreview(){
+        if(lastSchematic == null) return;
+        ui.schematics.showInfo(lastSchematic);
+    }
+
     public void rotatePlans(Seq<BuildPlan> plans, int direction){
         int ox = schemOriginX(), oy = schemOriginY();
 
@@ -1234,6 +1249,19 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
             plan.x = World.toTile(wx - plan.block.offset) + ox;
             plan.y = World.toTile(wy - plan.block.offset) + oy;
             plan.rotation = plan.block.planRotation(Mathf.mod(plan.rotation + direction, 4));
+
+            if(Core.settings.getBool("rotateCanvas") && plan.block instanceof CanvasBlock cb){
+                CanvasBlock.CanvasBuild temp = cb.new CanvasBuild();
+                Pixmap pix = cb.makePixmap((byte[])plan.config), pix2 = new Pixmap(cb.canvasSize, cb.canvasSize);
+                pix.each((px, py) -> pix2.setRaw(
+                direction >= 0 ? py : cb.canvasSize - py - 1,
+                direction >= 0 ? cb.canvasSize - px - 1 : px,
+                pix.getRaw(px, py)));
+                plan.config = temp.packPixmap(pix2);
+                temp.remove();
+                pix.dispose();
+                pix2.dispose();
+            }
         });
     }
 
@@ -1265,6 +1293,14 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
 
             //flip rotation
             plan.block.flipRotation(plan, x);
+
+            if(Core.settings.getBool("rotateCanvas") && plan.block instanceof CanvasBlock cb){
+                CanvasBlock.CanvasBuild temp = cb.new CanvasBuild();
+                Pixmap pix = cb.makePixmap((byte[])plan.config);
+                plan.config = temp.packPixmap(x ? pix.flipX() : pix.flipY());
+                temp.remove();
+                pix.dispose();
+            }
         });
     }
 
@@ -1389,12 +1425,17 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     protected void drawSelection(int x1, int y1, int x2, int y2, int maxLength, Color col1, Color col2){
         NormalizeDrawResult result = Placement.normalizeDrawArea(Blocks.air, x1, y1, x2, y2, false, maxLength, 1f);
 
+        String arcSelectionSize = Math.abs(x2 - x1) + 1 + "×" + (Math.abs(y1 - y2) + 1);
+        FuncX.drawText(Tmp.v1.set((x1 + x2) / 2f, Math.max(y1, y2) + 1).scl(tilesize), arcSelectionSize, 2f, Pal.accent, Align.top);
         Lines.stroke(2f);
 
         Draw.color(col1);
         Lines.rect(result.x, result.y - 1, result.x2 - result.x, result.y2 - result.y);
         Draw.color(col2);
         Lines.rect(result.x, result.y, result.x2 - result.x, result.y2 - result.y);
+
+        lastSelection.set(x1, y1, x2 - x1, y2 - y1);
+        lastSelection.normalize();
     }
 
     protected void flushSelectPlans(Seq<BuildPlan> plans){
@@ -1580,7 +1621,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
         if(build.block.commandable && commandMode){
             //TODO handled in tap.
             consumed = true;
-        }else if(build.block.configurable && build.interactable(player.team())){ //check if tapped block is configurable
+        }else if(build.block.configurable && (build.interactable(player.team()) || RenderExt.showOtherInfo)){ //check if tapped block is configurable
             consumed = true;
             if((!config.isShown() && build.shouldShowConfigure(player)) //if the config fragment is hidden, show
             //alternatively, the current selected block can 'agree' to switch config tiles
@@ -1609,7 +1650,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
         //consume tap event if necessary
         if(build.interactable(player.team()) && build.block.consumesTap){
             consumed = true;
-        }else if(build.interactable(player.team()) && build.block.synthetic() && (!consumed || build.block.allowConfigInventory)){
+        }else if(build.interactable(player.team()) && build.block.synthetic() && (!consumed || build.block.allowConfigInventory || settings.getBool("forceConfigInventory"))){
             if(build.block.hasItems && build.items.total() > 0){
                 inv.showFor(build);
                 consumed = true;
@@ -1754,7 +1795,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
 
     public @Nullable Building selectedControlBuild(){
         Building build = world.buildWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
-        if(build != null && !player.dead() && build.canControlSelect(player.unit()) && build.team == player.team()){
+        if(build != null && !player.dead() && build.canControlSelect(player.unit()) && (build.team == player.team() || (build instanceof CoreBuild && state.rules.editor))){
             return build;
         }
         return null;
@@ -1840,6 +1881,9 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     }
 
     public boolean canShoot(){
+        if(Core.settings.getBool("playerNeedShooting")){
+            return block == null && !onConfigurable() && !isDroppingItem() && !commandMode;
+        }
         return block == null && !onConfigurable() && !isDroppingItem() && !player.unit().activelyBuilding() &&
         !(player.unit() instanceof Mechc && player.unit().isFlying()) && !player.unit().mining() && !commandMode;
     }
diff --git a/core/src/mindustry/input/MobileInput.java b/core/src/mindustry/input/MobileInput.java
index ce16f8d91596a937835b7ab55977be5ea490df76..3edfa9d96d0cce492e4aed47bccd9b4c146149fa 100644
--- a/core/src/mindustry/input/MobileInput.java
+++ b/core/src/mindustry/input/MobileInput.java
@@ -333,7 +333,7 @@ public class MobileInput extends InputHandler implements GestureListener{
                     //why the heck doesn't setOrigin work for scaling
                     img.setTranslation(img.getWidth(), 0f);
                 });
-
+                b.button(Icon.info, style, this::showSchematicPreview).disabled(f -> lastSchematic == null || lastSchematic.file != null);
             }).margin(4f);
         });
     }
@@ -1026,18 +1026,23 @@ public class MobileInput extends InputHandler implements GestureListener{
             payloadTarget = null;
         }
 
-        movement.set(targetPos).sub(player).limit(speed);
-        movement.setAngle(Mathf.slerp(movement.angle(), unit.vel.angle(), 0.05f));
+        if (!Core.settings.getBool("viewMode")) {
+            movement.set(targetPos).sub(player).limit(speed);
+            movement.setAngle(Mathf.slerp(movement.angle(), unit.vel.angle(), 0.05f));
 
-        if(player.within(targetPos, attractDst)){
+            if(player.within(targetPos, attractDst)){
+                movement.setZero();
+                unit.vel.approachDelta(Vec2.ZERO, unit.speed() * type.accel / 2f);
+            }
+        }
+        else {
             movement.setZero();
-            unit.vel.approachDelta(Vec2.ZERO, unit.speed() * type.accel / 2f);
         }
 
         unit.hitbox(rect);
         rect.grow(4f);
 
-        player.boosting = collisions.overlapsTile(rect, EntityCollisions::solid) || !unit.within(targetPos, 85f);
+        player.boosting = collisions.overlapsTile(rect, EntityCollisions::solid) || !unit.within(targetPos, 85f) || Core.settings.getBool("forceBoost");
 
         unit.movePref(movement);
 
diff --git a/core/src/mindustry/type/UnitType.java b/core/src/mindustry/type/UnitType.java
index 682d2cdb951823b61c7951c8c19ed8a0a976f396..797114ab14787678789dd364fa1a890ced8c6ec1 100644
--- a/core/src/mindustry/type/UnitType.java
+++ b/core/src/mindustry/type/UnitType.java
@@ -17,6 +17,7 @@ import mindustry.ai.*;
 import mindustry.ai.Pathfinder.*;
 import mindustry.ai.types.*;
 import mindustry.annotations.Annotations.*;
+import mindustryX.features.ArcUnits;
 import mindustry.content.*;
 import mindustry.core.*;
 import mindustry.ctype.*;
@@ -38,6 +39,7 @@ import mindustry.world.blocks.units.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
 import mindustryX.features.*;
+import mindustryX.features.ui.*;
 
 import static arc.graphics.g2d.Draw.*;
 import static mindustry.Vars.*;
@@ -45,6 +47,8 @@ import static mindustry.Vars.*;
 public class UnitType extends UnlockableContent implements Senseable{
     public static final float shadowTX = -12, shadowTY = -13;
     private static final Vec2 legOffset = new Vec2();
+    public static float unitTrans = 1f;//current unitTrans when draw
+    private Table unitStatus = new Table();
 
     /** Environmental flags that are *all* required for this unit to function. 0 = any environment */
     public int envRequired = 0;
@@ -515,23 +519,103 @@ public class UnitType extends UnlockableContent implements Senseable{
 
     public void landed(Unit unit){}
 
+    private void displayStatusEffect(Unit unit,Table table){
+        if (unit.statuses().isEmpty()) return;
+        table.row().table(t -> {
+            for(StatusEntry entry : unit.statuses()){
+                if(t.getChildren().size % 5 == 0) t.row();
+                t.stack(
+                new Table(o -> {
+                    o.left();
+                    o.add(new Image(entry.effect.uiIcon)).size(iconMed).scaling(Scaling.fit);
+                }),
+                new Table(tt -> {
+                    tt.left().bottom();
+                    tt.add(entry.effect.permanent || entry.time > Time.toHours * 10f ? "Inf" : UI.formatTime(entry.time)).style(Styles.outlineLabel);
+                    tt.pack();
+                })).padLeft(8f);
+            }
+        });
+    }
+
+    private void updateStatusTable(Unit unit){
+        unitStatus.clear();
+        displayStatusEffect(unit,unitStatus);
+
+        Table statusText = getStatustext(unit.healthMultiplier(), unit.damageMultiplier(), unit.reloadMultiplier(), unit.speedMultiplier());
+        if(statusText != null){
+            unitStatus.row();
+            unitStatus.add(statusText).growX().wrap().left();
+        }
+    }
+
+    public static Table getStatustext(float healthMultiplier, float damageMultiplier, float reloadMultiplier, float speedMultiplier){
+        Seq<String> statusText = new Seq<>();
+        if(healthMultiplier != 1f){
+            statusText.add(" [acid]血量[white]: " + FormatDefault.format(healthMultiplier));
+        }
+        if(damageMultiplier != 1f){
+            statusText.add(" [red]伤害[white]: " + FormatDefault.format(damageMultiplier));
+        }
+        if(reloadMultiplier != 1f){
+            statusText.add(" [violet]攻速[white]: " + FormatDefault.format(reloadMultiplier));
+        }
+        if(speedMultiplier != 1f){
+            statusText.add(" [cyan]移速[white]: " + FormatDefault.format(speedMultiplier));
+        }
+        if (statusText.isEmpty()) return null;
+        Table table = new Table();
+        for (int i = 0;i < statusText.size;i++) {
+            if (i % 2 == 0) table.add(">>");
+            table.add(statusText.get(i)).left();
+            if (i % 2 == 1) table.row();
+        }
+        return table;
+    }
+
     public void display(Unit unit, Table table){
         table.table(t -> {
             t.left();
             t.add(new Image(uiIcon)).size(iconMed).scaling(Scaling.fit);
-            t.labelWrap(unit.isPlayer() ? unit.getPlayer().coloredName() + "\n[lightgray]" + localizedName : localizedName).left().width(190f).padLeft(5);
+            if(unit.team.id < 6){
+                if (unit.isPlayer()) {
+                    t.labelWrap(unit.getPlayer().coloredName() + "\n[#" + unit.team.color + "]" + localizedName).left().width(190f).padLeft(5);
+                } else {
+                    t.labelWrap("[#" + unit.team.color + "]" + localizedName).left().width(190f).padLeft(5);
+                }
+            }else{
+                if (unit.isPlayer()) {
+                    t.labelWrap(unit.getPlayer().coloredName() + "\n[#" + unit.team.color + "]" + localizedName + "[" + unit.team.id + "]").left().width(190f).padLeft(5);
+                } else {
+                    t.labelWrap("[#" + unit.team.color + "]" + localizedName + "[" + unit.team.id + "]").left().width(190f).padLeft(5);
+                }
+            }
         }).growX().left();
         table.row();
 
         table.table(bars -> {
             bars.defaults().growX().height(20f).pad(4);
 
-            //TODO overlay shields
-            bars.add(new Bar("stat.health", Pal.health, unit::healthf).blink(Color.white));
+            bars.add(new Bar(() -> {
+                updateStatusTable(unit);
+                StringBuilder str = new StringBuilder();
+                if(unit.shield() > 0){
+                    str.append(FormatDefault.format(unit.health)).append("[gray]+[white]").append(FormatDefault.format(unit.shield));
+                }else{
+                    str.append("\uE813 ").append(new Format(4).percent(unit.health, unit.maxHealth));
+                }
+                if (!Mathf.equal(unit.healthBalance.rawMean(), 0f, 0.1f)) {
+                    str.append(unit.healthBalance.rawMean() < 0 ? "[scarlet]" : "[acid]+");
+                    float number = unit.healthBalance.rawMean() * Time.toSeconds;
+                    str.append(FormatDefault.format(number));
+                    str.append("/s[]");
+                }
+                return str.toString();
+            }, () -> Pal.health, unit::healthf).blink(Color.white));
             bars.row();
 
             if(state.rules.unitAmmo){
-                bars.add(new Bar(ammoType.icon() + " " + Core.bundle.get("stat.ammo"), ammoType.barColor(), () -> unit.ammo / ammoCapacity));
+                bars.add(new Bar(() -> ammoType.icon() + " " + Core.bundle.format("bar.ammoDetail", unit.ammo, ammoCapacity), () -> ammoType.barColor(), () -> unit.ammo / ammoCapacity));
                 bars.row();
             }
 
@@ -539,8 +623,11 @@ public class UnitType extends UnlockableContent implements Senseable{
                 ability.displayBars(unit, bars);
             }
 
-            if(payloadCapacity > 0 && unit instanceof Payloadc payload){
-                bars.add(new Bar("stat.payloadcapacity", Pal.items, () -> payload.payloadUsed() / unit.type().payloadCapacity));
+            if(unit instanceof Payloadc payload){
+                bars.add(new Bar(Strings.format("装载：@/@ @",
+                Strings.autoFixed(payload.payloadUsed() / tilesize / tilesize, 4),
+                Strings.autoFixed(payloadCapacity / tilesize / tilesize, 4),
+                StatUnit.blocksSquared.localized()), Pal.items, () -> payload.payloadUsed() / unit.type().payloadCapacity));
                 bars.row();
 
                 var count = new float[]{-1};
@@ -550,18 +637,21 @@ public class UnitType extends UnlockableContent implements Senseable{
                         count[0] = payload.payloadUsed();
                     }
                 }).growX().left().height(0f).pad(0f);
+                bars.row();
             }
         }).growX();
+        table.row();
+        table.table(t-> unitStatus = t).growX();
 
         if(unit.controller() instanceof LogicAI ai){
             table.row();
-            table.add(Blocks.microProcessor.emoji() + " " + Core.bundle.get("units.processorcontrol")).growX().wrap().left();
-            if(ai.controller != null && (Core.settings.getBool("mouseposition") || Core.settings.getBool("position"))){
-                table.row();
-                table.add("[lightgray](" + ai.controller.tileX() + ", " + ai.controller.tileY() + ")").growX().wrap().left();
-            }
+            table.table(tt->{
+                tt.add(Blocks.microProcessor.emoji() + " " + Core.bundle.get("units.processorcontrol")).growX().left();
+                if(ai.controller != null && (Core.settings.getBool("mouseposition") || Core.settings.getBool("position"))){
+                    tt.add("[lightgray](" + ai.controller.tileX() + ", " + ai.controller.tileY() + ")").growX().right();
+                }
+            }).growX().wrap().left();
             table.row();
-            table.label(() -> Iconc.settings + " " + (long)unit.flag + "").color(Color.lightGray).growX().wrap().left();
             if(net.active() && ai.controller != null && ai.controller.lastAccessed != null){
                 table.row();
                 table.add(Core.bundle.format("lastaccessed", ai.controller.lastAccessed)).growX().wrap().left();
@@ -572,6 +662,11 @@ public class UnitType extends UnlockableContent implements Senseable{
         }
 
         table.row();
+        table.table(t -> {
+            t.add(Iconc.settings + " " + (long)unit.flag + "").color(Color.lightGray).growX();
+            t.add(Fonts.getUnicodeStr(unit.type().name) + unit.team.data().countType(unit.type()) + "/" + Units.getStringCap(unit.team)).color(Color.lightGray).growX();
+        }).growX();
+        table.row();
     }
 
     /** @return whether this block supports a specific environment. */
@@ -1239,6 +1334,9 @@ public class UnitType extends UnlockableContent implements Senseable{
         Mechc mech = unit instanceof Mechc ? (Mechc)unit : null;
         float z = isPayload ? Draw.z() : unit.elevation > 0.5f ? (lowAltitude ? Layer.flyingUnitLow : Layer.flyingUnit) : groundLayer + Mathf.clamp(hitSize / 4000f, 0, 0.01f);
 
+        unitTrans = ArcUnits.drawARCUnits(unit);
+        if(unitTrans == 0) return;
+
         if(unit.controller().isBeingControlled(player.unit())){
             drawControl(unit);
         }
@@ -1378,7 +1476,7 @@ public class UnitType extends UnlockableContent implements Senseable{
     }
 
     public void drawShield(Unit unit){
-        float alpha = unit.shieldAlpha();
+        float alpha = unit.shieldAlpha() * unitTrans;
         float radius = unit.hitSize() * 1.3f;
         Fill.light(unit.x, unit.y, Lines.circleVertices(radius), radius,
             Color.clear,
@@ -1390,6 +1488,7 @@ public class UnitType extends UnlockableContent implements Senseable{
         Draw.z(unit.isFlying() ? Layer.flyingUnitLow : Layer.groundUnit - 2);
 
         Draw.color(Pal.accent, Color.white, Mathf.absin(4f, 0.3f));
+        Draw.alpha(unitTrans);
         Lines.poly(unit.x, unit.y, 4, unit.hitSize + 1.5f);
 
         Draw.reset();
@@ -1403,7 +1502,7 @@ public class UnitType extends UnlockableContent implements Senseable{
         float dest = floor.canShadow ? 1f : 0f;
         //yes, this updates state in draw()... which isn't a problem, because I don't want it to be obvious anyway
         unit.shadowAlpha = unit.shadowAlpha < 0 ? dest : Mathf.approachDelta(unit.shadowAlpha, dest, 0.11f);
-        Draw.color(Pal.shadow, Pal.shadow.a * unit.shadowAlpha);
+        Draw.color(Pal.shadow, Pal.shadow.a * unit.shadowAlpha * unitTrans);
 
         Draw.rect(shadowRegion, unit.x + shadowTX * e, unit.y + shadowTY * e, unit.rotation - 90);
         Draw.color();
@@ -1418,7 +1517,7 @@ public class UnitType extends UnlockableContent implements Senseable{
     }
 
     public void drawSoftShadow(float x, float y, float rotation, float alpha){
-        Draw.color(0, 0, 0, 0.4f * alpha);
+        Draw.color(0, 0, 0, 0.4f * alpha * unitTrans);
         float rad = 1.6f;
         float size = Math.max(region.width, region.height) * region.scl();
         Draw.rect(softShadowRegion, x, y, size * rad * Draw.xscl, size * rad * Draw.yscl, rotation - 90);
@@ -1441,18 +1540,21 @@ public class UnitType extends UnlockableContent implements Senseable{
             Draw.mixcol();
 
             size = ((3f + sin) * unit.itemTime + 0.5f) * 2;
-            Draw.color(Pal.accent);
+            Draw.color(Pal.accent, unitTrans);
             Draw.rect(itemCircleRegion,
             unit.x + Angles.trnsx(unit.rotation + 180f, itemOffsetY),
             unit.y + Angles.trnsy(unit.rotation + 180f, itemOffsetY),
             size, size);
 
-            if(unit.isLocal() && !renderer.pixelate){
+            if(ArcUnits.unitItemCarried || (unit.isLocal() && !renderer.pixelate)){
+                float z = Draw.z();
+                Draw.z(z + .01f); // Remove this if you enjoy 1000 texture swaps
                 Fonts.outline.draw(unit.stack.amount + "",
                 unit.x + Angles.trnsx(unit.rotation + 180f, itemOffsetY),
                 unit.y + Angles.trnsy(unit.rotation + 180f, itemOffsetY) - 3,
                 Pal.accent, 0.25f * unit.itemTime / Scl.scl(1f), false, Align.center
                 );
+                Draw.z(z);
             }
 
             Draw.reset();
@@ -1535,7 +1637,7 @@ public class UnitType extends UnlockableContent implements Senseable{
 
     public Color cellColor(Unit unit){
         float f = Mathf.clamp(unit.healthf());
-        return Tmp.c1.set(Color.black).lerp(unit.team.color, f + Mathf.absin(Time.time, Math.max(f * 5f, 1f), 1f - f));
+        return Tmp.c1.set(Color.black).lerp(unit.team.color, f + Mathf.absin(Time.time, Math.max(f * 5f, 1f), 1f - f)).a(unitTrans);
     }
 
     public void drawLight(Unit unit){
@@ -1576,7 +1678,7 @@ public class UnitType extends UnlockableContent implements Senseable{
 
         if(footRegion.found()){
             for(Leg leg : legs){
-                Drawf.shadow(leg.base.x, leg.base.y, ssize, invDrown);
+                Drawf.shadow(leg.base.x, leg.base.y, ssize, invDrown * unitTrans);
             }
         }
 
@@ -1594,7 +1696,7 @@ public class UnitType extends UnlockableContent implements Senseable{
             if(footRegion.found() && leg.moving && shadowElevation > 0){
                 float scl = shadowElevation * invDrown;
                 float elev = Mathf.slope(1f - leg.stage) * scl;
-                Draw.color(Pal.shadow);
+                Draw.color(Pal.shadow, Pal.shadow.a * unitTrans);
                 Draw.rect(footRegion, leg.base.x + shadowTX * elev, leg.base.y + shadowTY * elev, position.angleTo(leg.base));
                 Draw.color();
             }
@@ -1673,8 +1775,9 @@ public class UnitType extends UnlockableContent implements Senseable{
 
         Floor floor = unit.isFlying() ? Blocks.air.asFloor() : unit.floorOn();
 
+        Draw.alpha(unitTrans);
         if(floor.isLiquid){
-            Draw.color(Color.white, floor.mapColor, 0.5f);
+            Draw.color(Color.white, floor.mapColor, 0.5f * unitTrans);
         }
 
         for(int i : Mathf.signs){
@@ -1696,6 +1799,8 @@ public class UnitType extends UnlockableContent implements Senseable{
             Draw.color(Color.white);
         }
 
+        Draw.alpha(unitTrans); //
+
         Draw.rect(baseRegion, unit, mech.baseRotation() - 90);
 
         Draw.mixcol();
@@ -1703,12 +1808,12 @@ public class UnitType extends UnlockableContent implements Senseable{
 
     public void applyOutlineColor(Unit unit){
         if(unit.drownTime > 0 && unit.lastDrownFloor != null){
-            Draw.color(Color.white, Tmp.c1.set(unit.lastDrownFloor.mapColor).mul(0.8f), unit.drownTime * 0.9f);
+            Draw.color(Color.white, Tmp.c1.set(unit.lastDrownFloor.mapColor).mul(0.8f), unit.drownTime * 0.9f * unitTrans);
         }
     }
 
     public void applyColor(Unit unit){
-        Draw.color();
+        Draw.color(Color.white, unitTrans);
         if(healFlash){
             Tmp.c1.set(Color.white).lerp(healColor, Mathf.clamp(unit.healTime - unit.hitTime));
         }
@@ -1723,6 +1828,13 @@ public class UnitType extends UnlockableContent implements Senseable{
         }
     }
 
+    public String typeColor() {
+        if (naval) return "[cyan]";
+        else if (allowLegStep) return "[magenta]";
+        else if (flying) return "[acid]";
+        else if (hovering) return "[sky]";
+        else return "[stat]";
+    }
     //endregion
 
     public static class UnitEngine implements Cloneable{
@@ -1761,13 +1873,13 @@ public class UnitType extends UnlockableContent implements Senseable{
             );
             Draw.z(z);*/
 
-            Draw.color(color);
+            Draw.color(color, unitTrans);
             Fill.circle(
             unit.x + ex,
             unit.y + ey,
             (radius + Mathf.absin(Time.time, 2f, radius / 4f)) * scale
             );
-            Draw.color(type.engineColorInner);
+            Draw.color(type.engineColorInner, unitTrans);
             Fill.circle(
             unit.x + ex - Angles.trnsx(rot + rotation, 1f),
             unit.y + ey - Angles.trnsy(rot + rotation, 1f),
diff --git a/core/src/mindustry/type/Weapon.java b/core/src/mindustry/type/Weapon.java
index f9ec8feac6e944e76b5e2309da9b78e9d1269348..54aecfe829705b2f0f39743f476fbc8dcf408d93 100644
--- a/core/src/mindustry/type/Weapon.java
+++ b/core/src/mindustry/type/Weapon.java
@@ -24,6 +24,7 @@ import mindustry.graphics.*;
 import mindustry.world.meta.*;
 import mindustryX.features.*;
 
+import static arc.math.Mathf.doubleRadDeg;
 import static mindustry.Vars.*;
 
 public class Weapon implements Cloneable{
@@ -227,10 +228,11 @@ public class Weapon implements Cloneable{
         wy = unit.y + Angles.trnsy(rotation, x, y) + Angles.trnsy(weaponRotation, 0, -realRecoil);
 
         if(shadow > 0){
-            Drawf.shadow(wx, wy, shadow);
+            Drawf.shadow(wx, wy, shadow, UnitType.unitTrans);
         }
 
         if(top){
+            Draw.alpha(UnitType.unitTrans);
             drawOutline(unit, mount);
         }
 
@@ -256,13 +258,13 @@ public class Weapon implements Cloneable{
         if(region.found()) Draw.rect(region, wx, wy, weaponRotation);
 
         if(cellRegion.found()){
-            Draw.color(unit.type.cellColor(unit));
+            Draw.color(unit.type.cellColor(unit), UnitType.unitTrans);
             Draw.rect(cellRegion, wx, wy, weaponRotation);
             Draw.color();
         }
 
         if(heatRegion.found() && mount.heat > 0){
-            Draw.color(heatColor, mount.heat);
+            Draw.color(heatColor, mount.heat * UnitType.unitTrans);
             Draw.blend(Blending.additive);
             Draw.rect(heatRegion, wx, wy, weaponRotation);
             Draw.blend();
@@ -285,6 +287,23 @@ public class Weapon implements Cloneable{
 
         Draw.xscl = 1f;
 
+        if (mount.shoot && ArcUnits.unitWeaponTargetLine){
+            if(mount.aimX !=0 && mount.aimY != 0  && Mathf.len(mount.aimX - wx, mount.aimY - wy) <= 1200f){
+                Draw.z(z + 1f);
+                Lines.stroke(1f);
+                if (unit.controller() == player) {
+                    Draw.color(RenderExt.playerEffectColor);
+                } else {
+                    Draw.color(unit.team.color);
+                }
+                Draw.alpha(0.8f);
+                Lines.line(wx, wy, mount.aimX, mount.aimY);
+                if(!(unit.controller() instanceof Player) || Core.settings.getInt("unitTargetType") == 0)
+                    Lines.spikes(mount.aimX, mount.aimY, 4f, 4f, 4, (float)(Math.atan((mount.aimX - wx) / (mount.aimY - wy) * doubleRadDeg)) + 45f);
+                Draw.reset();
+            }
+        }
+
         Draw.z(z);
     }
 
diff --git a/core/src/mindustry/ui/Fonts.java b/core/src/mindustry/ui/Fonts.java
index c02e09ff53a80aaf540223828208ad86b96d4bec..491a2a32020bd658941ce8e74d8becd0da5ab720 100644
--- a/core/src/mindustry/ui/Fonts.java
+++ b/core/src/mindustry/ui/Fonts.java
@@ -30,7 +30,7 @@ public class Fonts{
     private static final ObjectSet<String> unscaled = ObjectSet.with("iconLarge");
     private static ObjectIntMap<String> unicodeIcons = new ObjectIntMap<>();
     private static IntMap<String> unicodeToName = new IntMap<>();
-    private static ObjectMap<String, String> stringIcons = new ObjectMap<>();
+    public static ObjectMap<String, String> stringIcons = new ObjectMap<>();
     private static ObjectMap<String, TextureRegion> largeIcons = new ObjectMap<>();
 
     public static Font def, outline, icon, iconLarge, tech, logic;
diff --git a/core/src/mindustry/ui/Minimap.java b/core/src/mindustry/ui/Minimap.java
index a280c5811e522419857fab650db7c2f13c1d3075..adbc80fcd5cfb2b4e127603b1241b9c5b133e5e9 100644
--- a/core/src/mindustry/ui/Minimap.java
+++ b/core/src/mindustry/ui/Minimap.java
@@ -22,8 +22,6 @@ public class Minimap extends Table{
 
         mapCell = add(new Element(){
             {
-                setSize(Scl.scl(140f));
-
                 addListener(new ClickListener(KeyCode.mouseRight){
                     @Override
                     public void clicked(InputEvent event, float cx, float cy){
diff --git a/core/src/mindustry/ui/dialogs/ContentInfoDialog.java b/core/src/mindustry/ui/dialogs/ContentInfoDialog.java
index 8defe26a2482e54d24d9b12e4a9ae453e13348f3..bd97f9cc7c1c491b1cb7eee0c19a32041b225674 100644
--- a/core/src/mindustry/ui/dialogs/ContentInfoDialog.java
+++ b/core/src/mindustry/ui/dialogs/ContentInfoDialog.java
@@ -8,8 +8,10 @@ import arc.util.*;
 import mindustry.ctype.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
+import mindustry.ui.Styles;
 import mindustry.input.*;
 import mindustry.world.meta.*;
+import mindustryX.features.ui.*;
 
 import static arc.Core.*;
 import static mindustry.Vars.*;
@@ -38,8 +40,9 @@ public class ContentInfoDialog extends BaseDialog{
         content.checkStats();
 
         table.table(title1 -> {
-            title1.image(content.uiIcon).size(iconXLarge).scaling(Scaling.fit);
-            title1.add("[accent]" + content.localizedName + (settings.getBool("console") ? "\n[gray]" + content.name : "")).padLeft(5);
+            title1.image(content.uiIcon).size(iconXLarge).scaling(Scaling.fit).get().clicked(() -> Core.app.setClipboardText(content.emoji()));
+            int logicId = content.getLogicId();
+            title1.add("[accent]" + content.localizedName + "\n[gray]" + content.name + (logicId != -1 ? " <#" + logicId +">": "")).padLeft(5);
         });
 
         table.row();
@@ -89,12 +92,30 @@ public class ContentInfoDialog extends BaseDialog{
         }
 
         if(content.details != null){
-            table.add("[gray]" + (content.unlocked() || !content.hideDetails ? content.details : Iconc.lock + " " + Core.bundle.get("unlock.incampaign"))).pad(6).padTop(20).width(400f).wrap().fillX();
+            //table.add("[gray]" + (content.unlocked() || !content.hideDetails ? content.details : Iconc.lock + " " + Core.bundle.get("unlock.incampaign"))).pad(6).padTop(20).width(400f).wrap().fillX();
+            table.add("[gray]" + content.details ).pad(6).padTop(20).width(400f).wrap().fillX();
             table.row();
         }
 
         content.displayExtra(table);
 
+        table.table(t -> {
+            t.row();
+            t.table(tt->{
+                tt.button(content.emoji(), Styles.cleart, () -> Core.app.setClipboardText(content.emoji())).width(60f).tooltip(content.emoji());
+                tt.button(Icon.info, Styles.clearNonei, () -> Core.app.setClipboardText(content.name)).width(50f).tooltip(content.name);
+                tt.button(Icon.book, Styles.clearNonei, () -> Core.app.setClipboardText(content.description)).width(50f).tooltip(content.description);
+            });
+
+            t.row();
+            t.table(tt -> {
+                tt.add("♐");
+                tt.button("简", Styles.cleart, () -> ArcMessageDialog.shareContent(content, false)).width(50f);
+                tt.button("详", Styles.cleart, () -> ArcMessageDialog.shareContent(content, true)).width(50f);
+            }).visible(() -> Core.settings.getBool("arcShareWaveInfo"));
+
+        }).fillX().padLeft(10);
+
         ScrollPane pane = new ScrollPane(table);
         cont.add(pane);
 
diff --git a/core/src/mindustry/ui/dialogs/CustomRulesDialog.java b/core/src/mindustry/ui/dialogs/CustomRulesDialog.java
index a277593dd3ca7ecab8e2b49410f1a7e3ef27c4b2..e88487d6754008cc415c47b054f83098b20c8adb 100644
--- a/core/src/mindustry/ui/dialogs/CustomRulesDialog.java
+++ b/core/src/mindustry/ui/dialogs/CustomRulesDialog.java
@@ -3,6 +3,7 @@ package mindustry.ui.dialogs;
 import arc.*;
 import arc.func.*;
 import arc.graphics.*;
+import arc.math.geom.*;
 import arc.scene.style.*;
 import arc.scene.ui.*;
 import arc.scene.ui.ImageButton.*;
@@ -16,11 +17,13 @@ import mindustry.game.*;
 import mindustry.game.Rules.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
+import mindustry.graphics.g3d.*;
 import mindustry.io.*;
 import mindustry.type.*;
 import mindustry.type.Weather.*;
 import mindustry.ui.*;
 import mindustry.world.*;
+import mindustryX.features.*;
 
 import static arc.util.Time.*;
 import static mindustry.Vars.*;
@@ -38,6 +41,7 @@ public class CustomRulesDialog extends BaseDialog{
     public String currentName = "";
     public String ruleSearch = "";
     public Seq<Runnable> additionalSetup; // for modding to easily add new rules
+    private Seq<Team> teams;
 
     public CustomRulesDialog(){
         this(false);
@@ -57,6 +61,7 @@ public class CustomRulesDialog extends BaseDialog{
         additionalSetup = new Seq<>();
         categories = new Seq<>();
         categoryNames = new Seq<>();
+        teams = Seq.with(Team.baseTeams);
 
         buttons.button("@edit", Icon.pencil, () -> {
             BaseDialog dialog = new BaseDialog("@waves.edit");
@@ -220,13 +225,11 @@ public class CustomRulesDialog extends BaseDialog{
         check("@rules.wavesending", b -> rules.waveSending = b, () -> rules.waveSending, () -> rules.waves);
         check("@rules.wavetimer", b -> rules.waveTimer = b, () -> rules.waveTimer, () -> rules.waves);
         check("@rules.waitForWaveToEnd", b -> rules.waitEnemies = b, () -> rules.waitEnemies, () -> rules.waves && rules.waveTimer);
+        number("@rules.winWave", b -> rules.winWave = (int)b, () -> (int)rules.winWave);
         check("@rules.airUseSpawns", b -> rules.airUseSpawns = b, () -> rules.airUseSpawns, () -> rules.waves);
         numberi("@rules.wavelimit", f -> rules.winWave = f, () -> rules.winWave, () -> rules.waves, 0, Integer.MAX_VALUE);
         number("@rules.wavespacing", false, f -> rules.waveSpacing = f * 60f, () -> rules.waveSpacing / 60f, () -> rules.waves && rules.waveTimer, 1, Float.MAX_VALUE);
-        //this is experimental, because it's not clear that 0 makes it default.
-        if(experimental){
-            number("@rules.initialwavespacing", false, f -> rules.initialWaveSpacing = f * 60f, () -> rules.initialWaveSpacing / 60f, () -> rules.waves && rules.waveTimer, 0, Float.MAX_VALUE);
-        }
+        number("@rules.initialwavespacing", false, f -> rules.initialWaveSpacing = f * 60f, () -> rules.initialWaveSpacing / 60f, () -> rules.waves && rules.waveTimer, 0, Float.MAX_VALUE);
         number("@rules.dropzoneradius", false, f -> rules.dropZoneRadius = f * tilesize, () -> rules.dropZoneRadius / tilesize, () -> rules.waves);
 
 
@@ -247,7 +250,7 @@ public class CustomRulesDialog extends BaseDialog{
         check("@rules.reactorexplosions", b -> rules.reactorExplosions = b, () -> rules.reactorExplosions);
         check("@rules.schematic", b -> rules.schematicsAllowed = b, () -> rules.schematicsAllowed);
         check("@rules.coreincinerates", b -> rules.coreIncinerates = b, () -> rules.coreIncinerates);
-        check("@rules.cleanupdeadteams", b -> rules.cleanupDeadTeams = b, () -> rules.cleanupDeadTeams, () -> rules.pvp);
+        check("@rules.cleanupdeadteams", b -> rules.cleanupDeadTeams = b, () -> rules.cleanupDeadTeams);
         check("@rules.disableworldprocessors", b -> rules.disableWorldProcessors = b, () -> rules.disableWorldProcessors);
         number("@rules.buildcostmultiplier", false, f -> rules.buildCostMultiplier = f, () -> rules.buildCostMultiplier, () -> !rules.infiniteResources);
         number("@rules.buildspeedmultiplier", f -> rules.buildSpeedMultiplier = f, () -> rules.buildSpeedMultiplier, 0.001f, 50f);
@@ -267,6 +270,9 @@ public class CustomRulesDialog extends BaseDialog{
         if(Core.bundle.get("bannedblocks").toLowerCase().contains(ruleSearch)){
             current.button("@bannedblocks", () -> showBanned("@bannedblocks", ContentType.block, rules.bannedBlocks, Block::canBeBuilt)).left().width(300f).row();
         }
+        if(Core.bundle.get("revealedblocks").toLowerCase().contains(ruleSearch)){
+            current.button("@revealedblocks", () -> showBanned("@revealedblocks", ContentType.block, rules.revealedBlocks, b -> b.showUnlock() && (!b.isVanilla() || b.hasEmoji()))).left().width(300f).row();
+        }
         check("@rules.hidebannedblocks", b -> rules.hideBannedBlocks = b, () -> rules.hideBannedBlocks);
         check("@bannedblocks.whitelist", b -> rules.blockWhitelist = b, () -> rules.blockWhitelist);
 
@@ -299,6 +305,7 @@ public class CustomRulesDialog extends BaseDialog{
         check("@rules.explosions", b -> rules.damageExplosions = b, () -> rules.damageExplosions);
         check("@rules.fire", b -> rules.fire = b, () -> rules.fire);
         check("@rules.fog", b -> rules.fog = b, () -> rules.fog);
+        check("@rules.staticFog", b -> rules.staticFog = b, () -> rules.staticFog);
         check("@rules.lighting", b -> rules.lighting = b, () -> rules.lighting);
 
         if(experimental){
@@ -322,11 +329,50 @@ public class CustomRulesDialog extends BaseDialog{
                 b.add("@rules.ambientlight");
             }, () -> ui.picker.show(rules.ambientLight, rules.ambientLight::set)).left().width(250f).row();
         }
+        if(Core.bundle.get("rules.staticColor").toLowerCase().contains(ruleSearch)){
+            current.button(b -> {
+                b.left();
+                b.table(Tex.pane, in -> {
+                    in.stack(new Image(Tex.alphaBg), new Image(Tex.whiteui){{
+                        update(() -> setColor(rules.staticColor));
+                    }}).grow();
+                }).margin(4).size(50f).padRight(10);
+                b.add("@rules.staticColor");
+            }, () -> ui.picker.show(rules.staticColor, rules.staticColor::set)).left().width(250f).row();
+        }
+        if(Core.bundle.get("rules.dynamicColor").toLowerCase().contains(ruleSearch)){
+            current.button(b -> {
+                b.left();
+                b.table(Tex.pane, in -> {
+                    in.stack(new Image(Tex.alphaBg), new Image(Tex.whiteui){{
+                        update(() -> setColor(rules.dynamicColor));
+                    }}).grow();
+                }).margin(4).size(50f).padRight(10);
+                b.add("@rules.dynamicColor");
+            }, () -> ui.picker.show(rules.dynamicColor, rules.dynamicColor::set)).left().width(250f).row();
+        }
 
         if(Core.bundle.get("rules.weather").toLowerCase().contains(ruleSearch)){
             current.button("@rules.weather", this::weatherDialog).width(250f).left().row();
         }
 
+        category("arcExperimental");
+        check("@rules.logicUnitBuild", b -> rules.logicUnitBuild = b, () -> rules.logicUnitBuild);
+        check("@rules.coreDestroyClear",b->rules.coreDestroyClear = b,()->rules.coreDestroyClear);
+        check("@rules.unitPayloadUpdate",b->rules.unitPayloadUpdate = b,()->rules.unitPayloadUpdate);
+        check("@rules.showSpawns",b->rules.showSpawns = b,()->rules.showSpawns);
+        check("允许控制单位", b -> rules.possessionAllowed = b, () -> rules.possessionAllowed);
+        check("禁用重建", b -> rules.ghostBlocks = b, () -> !rules.ghostBlocks);
+        if(Core.bundle.get("hiddenBuildItems").toLowerCase().contains(ruleSearch)){
+            current.button("@hiddenBuildItems", () -> showBanned("@hiddenBuildItems", ContentType.item, rules.hiddenBuildItems, Item::showUnlock)).left().width(300f).row();
+        }
+
+        check("@rules.limitarea", b -> rules.limitMapArea = b, () -> rules.limitMapArea);
+        numberi("x", x -> state.rules.limitX = x, () -> state.rules.limitX, () -> state.rules.limitMapArea, 0, 10000);
+        numberi("y", y -> state.rules.limitY = y, () -> state.rules.limitY, () -> state.rules.limitMapArea, 0, 10000);
+        numberi("w", w -> state.rules.limitWidth = w, () -> state.rules.limitWidth, () -> state.rules.limitMapArea, 0, 10000);
+        numberi("h", h -> state.rules.limitHeight = h, () -> state.rules.limitHeight, () -> state.rules.limitMapArea, 0, 10000);
+        check("@rules.disableOutsideArea",b -> rules.disableOutsideArea = b, () -> rules.disableOutsideArea);
 
         category("planet");
         if(Core.bundle.get("rules.title.planet").toLowerCase().contains(ruleSearch)){
@@ -337,10 +383,10 @@ public class CustomRulesDialog extends BaseDialog{
 
                 t.defaults().size(140f, 50f);
 
-                for(Planet planet : content.planets().select(p -> p.accessible && p.visible && p.isLandable())){
-                    t.button(planet.localizedName, style, () -> {
-                        planet.applyRules(rules);
-                    }).group(group).checked(b -> rules.planet == planet);
+            for(Planet planet : content.planets()){
+                t.button(planet.localizedName, style, () -> {
+                    planet.applyRules(rules);
+                }).group(group).checked(b -> rules.planet == planet);
 
                     if(t.getChildren().size % 3 == 0){
                         t.row();
@@ -361,10 +407,29 @@ public class CustomRulesDialog extends BaseDialog{
         if(showRuleEditRule){
             check("@rules.allowedit", b -> rules.allowEditRules = b, () -> rules.allowEditRules);
         }
+        current.button("所有队伍开启无限火力", () -> {
+            for(Team team : Team.all){
+                team.rules().cheat = true;
+            }
+            setup();
+        }).width(256f).height(32f).row();
+        current.button("所有队伍关闭无限火力", () -> {
+            for(Team team : Team.all){
+                team.rules().cheat = false;
+            }
+            setup();
+        }).width(256f).height(32f).row();
+
         team("@rules.playerteam", t -> rules.defaultTeam = t, () -> rules.defaultTeam);
         team("@rules.enemyteam", t -> rules.waveTeam = t, () -> rules.waveTeam);
 
-        for(Team team : Team.baseTeams){
+        current.button("更多队伍设置", Styles.flatBordert, () -> UIExt.teamSelect.select(team -> teams.contains(team), team -> {
+            if(teams.contains(team)) teams.remove(team);
+            else teams.add(team);
+            setup();
+        })).marginLeft(14f).fillX().height(55f).row();
+
+        for(Team team : teams){
             boolean[] shown = {false};
             Table wasCurrent = current;
 
@@ -381,6 +446,10 @@ public class CustomRulesDialog extends BaseDialog{
                 current = c;
                 TeamRule teams = rules.teams.get(team);
 
+                check("@rules.cheat", b -> teams.cheat = b, () -> teams.cheat);
+                check("@rules.infiniteAmmo",b -> teams.infiniteAmmo = b, () -> teams.infiniteAmmo);
+                check("@rules.aiCoreSpawn", b -> teams.aiCoreSpawn = b, () -> teams.aiCoreSpawn);
+
                 number("@rules.blockhealthmultiplier", f -> teams.blockHealthMultiplier = f, () -> teams.blockHealthMultiplier);
                 number("@rules.blockdamagemultiplier", f -> teams.blockDamageMultiplier = f, () -> teams.blockDamageMultiplier);
 
@@ -412,6 +481,32 @@ public class CustomRulesDialog extends BaseDialog{
             }, () -> shown[0]).left().growX().row();
         }
 
+        check("自定义背景[lightgray](需要设置空地板)", t -> {
+            rules.planetBackground = t ? new PlanetParams(){{planet = Planets.sun;zoom=1f;camPos = new Vec3(1.2388899f, 1.6047299f, 2.4758825f);}} : null;
+            setup();
+        }, () -> rules.planetBackground != null);
+        if (rules.planetBackground != null){
+            current.table(Tex.button, t -> {
+                t.margin(10f);
+                var group = new ButtonGroup<>();
+                var style = Styles.flatTogglet;
+
+                t.defaults().size(140f, 50f);
+
+                for(Planet planet : content.planets()){
+                    t.button(planet.localizedName, style, () -> rules.planetBackground.planet = planet).group(group).checked(b -> rules.planetBackground.planet == planet);
+                    if(t.getChildren().size % 3 == 0){
+                        t.row();
+                    }
+                }
+            }).left().fill(false).expand(false, false).row();
+            number("放缩", f -> rules.planetBackground.zoom = f, () -> rules.planetBackground.zoom, 0.0001f, 999);
+            number("位置x", f -> rules.planetBackground.camPos.x = f, () -> rules.planetBackground.camPos.x);
+            number("位置y", f -> rules.planetBackground.camPos.y = f, () -> rules.planetBackground.camPos.y);
+            number("位置z", f -> rules.planetBackground.camPos.z = f, () -> rules.planetBackground.camPos.z);
+        }
+
+
         additionalSetup.each(Runnable::run);
 
         for(var i = 0; i < categories.size; i++){
@@ -446,6 +541,7 @@ public class CustomRulesDialog extends BaseDialog{
                     cons.get(team);
                 }).pad(1f).checked(b -> prov.get() == team).size(60f).tooltip(team.coloredName()).with(i -> i.getStyle().imageUpColor = team.color);
             }
+            t.button(Icon.add, Styles.squareTogglei, 38f, () -> UIExt.teamSelect.pickOne(cons, prov.get())).pad(1f).checked(b -> !Seq.with(Team.baseTeams).contains(prov.get())).size(60f).tooltip("[acid]更多队伍选择");
         }).padTop(0).row();
     }
 
@@ -478,7 +574,7 @@ public class CustomRulesDialog extends BaseDialog{
             t.field((prov.get()) + "", s -> cons.get(Strings.parseInt(s)))
                 .update(a -> a.setDisabled(!condition.get()))
                 .padRight(100f)
-                .valid(f -> Strings.parseInt(f) >= min && Strings.parseInt(f) <= max).width(120f).left();
+                .valid(f -> Strings.parseInt(f) >= -999999 && Strings.parseInt(f) <= 999999999).width(120f).left();
         }).padTop(0).row();
     }
 
@@ -491,7 +587,8 @@ public class CustomRulesDialog extends BaseDialog{
             t.field((integer ? (int)prov.get() : prov.get()) + "", s -> cons.get(Strings.parseFloat(s)))
             .padRight(100f)
             .update(a -> a.setDisabled(!condition.get()))
-            .valid(f -> Strings.canParsePositiveFloat(f) && Strings.parseFloat(f) >= min && Strings.parseFloat(f) <= max).width(120f).left();
+            //.valid(f -> Strings.canParsePositiveFloat(f) && Strings.parseFloat(f) >= min && Strings.parseFloat(f) <= max).width(120f).left();
+            .valid(f ->  Strings.canParsePositiveFloat(f)).width(120f).left();
         }).padTop(0);
         current.row();
     }
diff --git a/core/src/mindustry/ui/dialogs/DatabaseDialog.java b/core/src/mindustry/ui/dialogs/DatabaseDialog.java
index 9fdefa9e1c6dfb0303031f4e6eb4cad22923eed5..23060df1a8f0f39b718242da0133ce2ab7c291dc 100644
--- a/core/src/mindustry/ui/dialogs/DatabaseDialog.java
+++ b/core/src/mindustry/ui/dialogs/DatabaseDialog.java
@@ -16,9 +16,10 @@ import mindustry.graphics.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.*;
+import mindustryX.features.ui.*;
 
-import static arc.Core.*;
 import static mindustry.Vars.*;
+import static mindustryX.features.ArcOld.colorizeContent;
 
 public class DatabaseDialog extends BaseDialog{
     private TextField search;
@@ -41,6 +42,7 @@ public class DatabaseDialog extends BaseDialog{
         }).fillX().padBottom(4).row();
 
         cont.pane(all).scrollX(false);
+        colorizeContent();
     }
 
     void rebuild(){
@@ -53,7 +55,8 @@ public class DatabaseDialog extends BaseDialog{
             ContentType type = ContentType.all[j];
 
             Seq<UnlockableContent> array = allContent[j]
-                .select(c -> c instanceof UnlockableContent u && !u.isHidden()  &&
+                .select(c -> c instanceof UnlockableContent u &&
+                    (AdvanceToolTable.allBlocksReveal || !u.isHidden()) &&
                     (text.isEmpty() || u.localizedName.toLowerCase().contains(text))).as();
             if(array.size == 0) continue;
 
@@ -98,7 +101,7 @@ public class DatabaseDialog extends BaseDialog{
                                 ui.content.show(unlock);
                             }
                         });
-                        image.addListener(new Tooltip(t -> t.background(Tex.button).add(unlock.localizedName + (settings.getBool("console") ? "\n[gray]" + unlock.name : ""))));
+                        image.addListener(new Tooltip(t -> t.background(Tex.button).add(unlock.localizedName + "\n[gray]" + unlock.name + (logicVars.lookupLogicId(unlock) != -1 ? " <#" + logicVars.lookupLogicId(unlock) +">": ""))));
                     }
 
                     if((++count) % cols == 0){
diff --git a/core/src/mindustry/ui/dialogs/PausedDialog.java b/core/src/mindustry/ui/dialogs/PausedDialog.java
index 677b3d53ed8c1614e0b802d6712e5d4b219e7bea..cec75cca43ea5852d2427ae6b6ba230d9c8fb71e 100644
--- a/core/src/mindustry/ui/dialogs/PausedDialog.java
+++ b/core/src/mindustry/ui/dialogs/PausedDialog.java
@@ -62,7 +62,7 @@ public class PausedDialog extends BaseDialog{
             cont.button("@back", Icon.left, this::hide).name("back");
             cont.button("@settings", Icon.settings, ui.settings::show).name("settings");
 
-            if(!state.isCampaign() && !state.isEditor()){
+            if(Core.settings.getBool("save_more_map") || (!state.isCampaign() && !state.isEditor())){
                 cont.row();
                 cont.button("@savegame", Icon.save, save::show);
                 cont.button("@loadgame", Icon.upload, load::show).disabled(b -> net.active());
@@ -89,6 +89,10 @@ public class PausedDialog extends BaseDialog{
 
             cont.row();
 
+            cont.button("@joingame", Icon.host, () -> {
+                this.hide();
+                ui.join.show();
+            });
             cont.button("@quit", Icon.exit, this::showQuitConfirm).colspan(2).width(dw + 10f).update(s -> s.setText(control.saves.getCurrent() != null && control.saves.getCurrent().isAutosave() ? "@save.quit" : "@quit"));
 
         }else{
@@ -121,6 +125,12 @@ public class PausedDialog extends BaseDialog{
                 s.setText(control.saves.getCurrent() != null && control.saves.getCurrent().isAutosave() ? "@save.quit" : "@quit");
                 s.getLabelCell().growX().wrap();
             });
+
+            if(mobile){
+                cont.row();
+                int columns = cont.getColumns();
+                cont.button("@database", Icon.book, ui.database::show).colspan(columns).size(Float.NEGATIVE_INFINITY, 60).fillX();
+            }
         }
     }
 
diff --git a/core/src/mindustry/ui/dialogs/PlanetDialog.java b/core/src/mindustry/ui/dialogs/PlanetDialog.java
index c8f4fb44c2d382c3430964e6197cde3f45bf8695..6af74ac5d883532c2fcb5c031bcebd810a079072 100644
--- a/core/src/mindustry/ui/dialogs/PlanetDialog.java
+++ b/core/src/mindustry/ui/dialogs/PlanetDialog.java
@@ -36,6 +36,8 @@ import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.blocks.storage.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
+import mindustryX.features.*;
+import mindustryX.features.func.*;
 
 import static arc.Core.*;
 import static mindustry.Vars.*;
@@ -68,9 +70,13 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
     private Texture[] planetTextures;
 
+    private boolean alwaysShowName = false;
+
+    private int viewInt = 60;
+
     public PlanetDialog(){
         super("", Styles.fullDialog);
-        
+
         state.renderer = this;
         state.drawUi = true;
 
@@ -284,6 +290,13 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
             buttons.add().growX();
             buttons.add(sectorTop).minWidth(230f);
             buttons.add().growX();
+            buttons.button("显示周期", Icon.settings, () -> {
+                if(viewInt == 1) viewInt = 60;
+                else if(viewInt == 60) viewInt = 120;
+                else viewInt = 1;
+                UIExt.announce("调整资源输入|输出显示周期为 [orange]" + viewInterval(viewInt));
+            }).size(100f, 54f).pad(2).bottom();
+            buttons.button("区块名称", Icon.bookOpen, () -> alwaysShowName = !alwaysShowName).size(100f, 54f).pad(2).bottom();
             addTech();
         }
     }
@@ -520,6 +533,11 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
                         Draw.rect(icon, 0, 0, iw, iw * icon.height / icon.width);
                     });
                 }
+                planets.drawPlane(sec, () -> {
+                    if((canSelect(sec) || sec.hasBase()) && alwaysShowName){
+                        FuncX.drawText(Vec2.ZERO, (sec.preset != null ? "" : "[gray]") + sec.name(), Scl.scl(2));
+                    }
+                });
             }
         }
 
@@ -661,7 +679,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
             //sector notifications & search
             c.top().right();
-            c.defaults().width(290f);
+            c.defaults().width(350f);
 
             c.button(bundle.get("sectorlist") +
             (attacked == 0 ? "" : "\n[red]⚠[lightgray] " + bundle.format("sectorlist.attacked", "[red]" + attacked + "[]")),
@@ -705,7 +723,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
             readd[0] = () -> {
                 con.clearChildren();
-                for(Sector sec : all){
+                for(Sector sec : all.copy().sort(sector -> sector.info.production.size)){
                     if(sec.hasBase() && (searchText.isEmpty() || sec.name().toLowerCase().contains(searchText.toLowerCase()))){
                         con.button(t -> {
                             t.marginRight(10f);
@@ -724,6 +742,19 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
                                 String ic = sec.iconChar() == null ? "" : sec.iconChar() + " ";
 
                                 head.add(ic + sec.name()).growX().wrap();
+
+                                if(!mobile && !sec.info.export.isEmpty() && sec.info.destination != null && sec.info.destination.hasBase()){
+                                    String des = sec.info.destination.iconChar();
+                                    String text = Iconc.rightOpen + " " + (des == null || des.isEmpty() ? "" : des + " ") + sec.info.destination.name();
+                                    head.button(text, Styles.cleart, () -> {
+                                        ui.planet.showSelect(sec, other -> {
+                                            if(other.planet == sec.planet){
+                                                sec.info.destination = other;
+                                            }
+                                        });
+                                    }).minWidth(150f).right().padRight(10f);
+                                }
+
                             }).growX().row();
 
                             if(sec.isAttacked()){
@@ -762,7 +793,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
             buffer.end();
 
             Draw.color(color);
-            Draw.rect(Draw.wrap(buffer.getTexture()), width/2f, height/2f, width, -height);
+            Draw.rect(Draw.wrap(buffer.getTexture()), width / 2f, height / 2f, width, -height);
             Draw.color();
         }
     }
@@ -866,14 +897,15 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
         Table t = new Table().left();
 
         int i = 0;
+        int rowSet = settings.getInt("itemSelectionWidth");
         for(var item : content.items()){
             var stat = stats.get(item);
             if(stat == null) continue;
-            int total = (int)(stat.mean * 60 * scl);
-            if(total > 1){
+            int total = (int)(stat.mean * viewInt * scl);
+            if(total != 0){
                 t.image(item.uiIcon).padRight(3);
-                t.add(UI.formatAmount(total) + " " + Core.bundle.get("unit.perminute")).color(Color.lightGray).padRight(3);
-                if(++i % 3 == 0){
+                t.add(UI.formatAmount(total)).color(Color.lightGray).padRight(3);
+                if(++i % rowSet == 0){
                     t.row();
                 }
             }
@@ -881,7 +913,11 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
         if(t.getChildren().any()){
             c.defaults().left();
-            c.add(name).row();
+            c.table(label -> {
+                label.add(name).color(Pal.accent);
+                label.add("(" + viewInterval(viewInt) + ")").color(Pal.accent);
+            }).center().row();
+            c.image().color(Pal.accent).fillX().row();
             builder.get(c);
             c.add(t).padLeft(10f).row();
         }
@@ -908,7 +944,8 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
             }
 
             if(sector.save != null && sector.info.resources.any()){
-                c.add("@sectors.resources").left().row();
+                c.add("@sectors.resources").color(Pal.accent).center().row();
+                c.image().color(Pal.accent).fillX().row();
                 c.table(t -> {
                     for(UnlockableContent uc : sector.info.resources){
                         if(uc == null) continue;
@@ -943,7 +980,8 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
             //stored resources
             if(sector.hasBase() && items.total > 0){
 
-                c.add("@sectors.stored").left().row();
+                c.add("@sectors.stored").color(Pal.accent).center().row();
+                c.image().color(Pal.accent).fillX().row();
                 c.table(t -> {
                     t.left();
 
@@ -953,7 +991,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
                         for(ItemStack stack : items){
                             res.image(stack.item.uiIcon).padRight(3);
                             res.add(UI.formatAmount(Math.max(stack.amount, 0))).color(Color.lightGray);
-                            if(++i % 4 == 0){
+                            if(++i % settings.getInt("itemSelectionWidth") == 0){
                                 res.row();
                             }
                         }
@@ -1205,6 +1243,7 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
 
                     return;
                 }
+                if(attacked != sector && settings.getBool("forceIgnoreAttack")) ui.showInfo("[red]警告：你的一个区块正在遭受攻击。[white]\n但你使用了学术端的作弊功能来强行切换区块，这可能导致未知问题！");
             }
         }
 
@@ -1287,6 +1326,13 @@ public class PlanetDialog extends BaseDialog implements PlanetInterfaceRenderer{
         if(shouldHide) hide();
     }
 
+    private String viewInterval(int viewInt){
+        if(viewInt == 60) return "每分";
+        else if(viewInt == 120) return "每周期";
+        else if(viewInt == 1) return "每秒";
+        else return "每" + viewInt + "秒";
+    }
+
     public enum Mode{
         /** Look around for existing sectors. Can only deploy. */
         look,
diff --git a/core/src/mindustry/ui/dialogs/SchematicsDialog.java b/core/src/mindustry/ui/dialogs/SchematicsDialog.java
index 3907f10dbee3695599e0f70bdfde13c34c53b50d..4b7cb241f7801895227073ba10ac22a5f67b6a51 100644
--- a/core/src/mindustry/ui/dialogs/SchematicsDialog.java
+++ b/core/src/mindustry/ui/dialogs/SchematicsDialog.java
@@ -15,6 +15,12 @@ import arc.scene.ui.layout.*;
 import arc.scene.utils.*;
 import arc.struct.*;
 import arc.util.*;
+import mindustryX.features.PicToMindustry;
+import mindustry.core.*;
+import mindustryX.features.ui.ArcMessageDialog;
+import mindustry.content.Blocks;
+import mindustry.content.Planets;
+import mindustry.content.UnitTypes;
 import mindustry.ctype.*;
 import mindustry.game.*;
 import mindustry.gen.*;
@@ -22,10 +28,15 @@ import mindustry.graphics.*;
 import mindustry.input.*;
 import mindustry.type.*;
 import mindustry.ui.*;
+import mindustry.world.Block;
+import mindustry.world.blocks.production.GenericCrafter;
+import mindustry.world.meta.StatUnit;
+import mindustryX.features.*;
 
 import java.util.regex.*;
 
 import static mindustry.Vars.*;
+import static mindustry.content.Items.*;
 
 public class SchematicsDialog extends BaseDialog{
     private static final float tagh = 42f;
@@ -37,9 +48,34 @@ public class SchematicsDialog extends BaseDialog{
     private Pattern ignoreSymbols = Pattern.compile("[`~!@#$%^&*()\\-_=+{}|;:'\",<.>/?]");
     private Seq<String> tags, selectedTags = new Seq<>();
     private boolean checkedTags;
+    private String blueprintlink = "https://docs.qq.com/sheet/DVHNoS3lIcm1NbFFS";
+
+    private String surpuloTags = UnitTypes.gamma.emoji(), erekirTags = UnitTypes.emanate.emoji();
+    private  Seq<String> planetTags = new Seq<String>().add(surpuloTags,erekirTags);
+    public static final String ShareType = "[blue]<Schem>";
+
+    private boolean clipbroad = true;
+    private boolean fromShare = false;
 
     public SchematicsDialog(){
         super("@schematics");
+        Events.on(EventType.WorldLoadEvent.class, event -> {
+            if(state.rules.env == Planets.serpulo.defaultEnv){
+                if (state.rules.hiddenBuildItems.equals(Planets.erekir.hiddenItems)){
+                    if (selectedTags.contains(erekirTags)) selectedTags.remove(erekirTags);
+                    if (!selectedTags.contains(surpuloTags)) selectedTags.add(surpuloTags);
+                }else{
+                    if (selectedTags.contains(erekirTags)) selectedTags.remove(erekirTags);
+                    if (selectedTags.contains(surpuloTags)) selectedTags.remove(surpuloTags);
+                }
+
+            }
+            else if(state.rules.env == Planets.erekir.defaultEnv){
+                if (selectedTags.contains(surpuloTags)) selectedTags.remove(surpuloTags);
+                if (!selectedTags.contains(erekirTags)) selectedTags.add(erekirTags);
+            }
+        });
+
         Core.assets.load("sprites/schematic-background.png", Texture.class).loaded = t -> t.setWrap(TextureWrap.repeat);
 
         tags = Core.settings.getJson("schematic-tags", Seq.class, String.class, Seq::new);
@@ -47,6 +83,14 @@ public class SchematicsDialog extends BaseDialog{
         shouldPause = true;
         addCloseButton();
         buttons.button("@schematic.import", Icon.download, this::showImport);
+        if (mobile) buttons.row();
+        buttons.button("[cyan]蓝图档案馆", Icon.link, () -> {
+            if(!Core.app.openURI(blueprintlink)){
+                ui.showErrorMessage("@linkfail");
+                Core.app.setClipboardText(blueprintlink);
+            }
+        });
+        buttons.button("[violet]转换器[white] " + Blocks.canvas.emoji() + Blocks.logicDisplay.emoji() + Blocks.sorter.emoji(), Icon.image, PicToMindustry::show);
         makeButtonOverlay();
         shown(this::setup);
         onResize(this::setup);
@@ -105,6 +149,48 @@ public class SchematicsDialog extends BaseDialog{
 
         cont.row();
 
+        cont.table(in -> {
+            in.left();
+            in.add("科技树：").padRight(4);
+
+            //tags (no scroll pane visible)
+            in.pane(Styles.noBarPane, t -> {
+                rebuildTags = () -> {
+                    t.clearChildren();
+                    t.left();
+
+                    t.defaults().pad(2).height(tagh);
+                    for(var tag : planetTags){
+                        t.button(tag, Styles.togglet, () -> {
+                            if(selectedTags.contains(tag)){
+                                selectedTags.remove(tag);
+                            }else{
+                                selectedTags.add(tag);
+                            }
+                            rebuildPane.run();
+                        }).checked(selectedTags.contains(tag)).with(c -> c.getLabel().setWrap(false));
+                    }
+                };
+                rebuildTags.run();
+            }).fillX().height(tagh).scrollY(false);
+
+            in.button(Icon.refreshSmall, this::syncPlanetTags).size(tagh).pad(2).tooltip("刷新");
+            in.add("辅助筛选：").padLeft(20f).padRight(4);
+            in.button(copper.emoji(), Styles.togglet, () -> {
+                        Core.settings.put("arcSchematicCanBuild", !Core.settings.getBool("arcSchematicCanBuild"));
+                        rebuildPane.run();
+                    }).size(tagh).pad(2).tooltip("可建造(核心有此类资源+地图未禁用)").checked(t->Core.settings.getBool("arcSchematicCanBuild"));
+            if (Core.settings.getBool("autoSelSchematic")) {
+                in.add("蓝图包含：").padLeft(20f).padRight(4);
+                in.button(control.input.block == null ? "[red]\uE815" : control.input.block.emoji(), Styles.togglet, () -> {
+                    control.input.block = null;
+                    rebuildPane.run();
+                }).size(tagh).pad(2).tooltip("蓝图需包含此建筑").checked(t -> control.input.block != null);
+            }
+        }).height(tagh).fillX();
+
+        cont.row();
+
         cont.pane(t -> {
             t.top();
 
@@ -133,6 +219,9 @@ public class SchematicsDialog extends BaseDialog{
                     if(selectedTags.any() && !s.labels.containsAll(selectedTags)) continue;
                     //make sure search fits
                     if(!search.isEmpty() && !ignoreSymbols.matcher(s.name().toLowerCase()).replaceAll("").contains(searchString)) continue;
+
+                    if(Core.settings.getBool("autoSelSchematic") && control.input.block!=null && !s.containsBlock(control.input.block)) continue;
+                    if (Core.settings.getBool("arcSchematicCanBuild") && !arcSchematicCanBuild(s)) continue;
                     if(firstSchematic == null) firstSchematic = s;
 
                     Button[] sel = {null};
@@ -205,6 +294,11 @@ public class SchematicsDialog extends BaseDialog{
 
             rebuildPane.run();
         }).grow().scrollX(false);
+
+        if(Core.settings.getBool("autoSelSchematic") && control.input.block!=null){
+            String text = "[orange]蓝图筛选模式[white]:蓝图必须包含 "+control.input.block.emoji();
+            UIExt.announce(text, 5f);
+        }
     }
 
     public void showInfo(Schematic schematic){
@@ -275,15 +369,48 @@ public class SchematicsDialog extends BaseDialog{
                     t.row();
                     dialog.hide();
                 }
-                t.button("@schematic.copy", Icon.copy, style, () -> {
+                t.button("@schematic.exportfile", Icon.export, style, () -> {
                     dialog.hide();
-                    ui.showInfoFade("@copied");
-                    Core.app.setClipboardText(schematics.writeBase64(s));
+                    platform.export(s.name(), schematicExtension, file -> Schematics.write(s, file));
                 }).marginLeft(12f);
                 t.row();
-                t.button("@schematic.exportfile", Icon.export, style, () -> {
+                t.button("[cyan]剪贴板[white]/[gray]消息框", Icon.copy, style, () -> {
+                    clipbroad = !clipbroad;
+                }).marginLeft(12f).update(button -> button.setText(clipbroad? "[cyan]剪贴板[white]/[gray]消息框" : "[gray]剪贴板[white]/[cyan]消息框"));
+                t.row();
+
+                t.button("蓝图代码", Icon.copy, style, () -> {
+                    dialog.hide();
+                    arcSendBlueprintMsg(schematics.writeBase64(s));
+                }).marginLeft(12f);
+                t.row();
+                t.button("记录蓝图[cyan][简]", Icon.export, style, () -> {
+                    dialog.hide();
+                    arcSendBlueprintMsg(arcSchematicsInfo(s,false));
+                }).marginLeft(12f);
+                t.row();
+                t.button("记录蓝图[cyan][详]", Icon.export, style, () -> {
+                    dialog.hide();
+                    arcSendBlueprintMsg(arcSchematicsInfo(s,true));
+                }).marginLeft(12f);
+                t.row();
+                t.button("分享蓝图", Icon.export, style, () -> {
+                    try {
+                        Http.HttpRequest req = Http.post("https://pastebin.com/api/api_post.php", "api_dev_key=sdBDjI5mWBnHl9vBEDMNiYQ3IZe0LFEk&api_option=paste&api_paste_expire_date=10M&api_paste_code=" + schematics.writeBase64(s));
+                        req.submit(r -> {
+                            String code = r.getResultAsString();
+                            if (clipbroad) arcSendClipBroadMsg(s, code);
+                            //添加颜色字符，保持ARC兼容性
+                            else ArcMessageDialog.share("[blue]<Schem>[]", " " + code.substring(code.lastIndexOf('/') + 1));
+                        });
+                        req.error(e -> Core.app.post(() -> {
+                            ui.showException("分享失败", e);
+                            if(clipbroad) arcSendClipBroadMsg(s, "x");
+                        }));
+                    } catch (Exception e) {
+                        ui.showException("分享失败", e);
+                    }
                     dialog.hide();
-                    platform.export(s.name(), schematicExtension, file -> Schematics.write(s, file));
                 }).marginLeft(12f);
             });
         });
@@ -292,6 +419,85 @@ public class SchematicsDialog extends BaseDialog{
         dialog.show();
     }
 
+    private void arcSendBlueprintMsg(String msg){
+        if(clipbroad){
+            Core.app.setClipboardText(msg);
+            UIExt.announce("已保存至剪贴板");
+        }else{
+            UIExt.sendChatMessage(msg);
+            UIExt.announce("已发送到聊天框");
+        }
+    }
+
+    private void arcSendClipBroadMsg(Schematic schem, String msg){
+        StringBuilder s = new StringBuilder();
+        s.append("这是一条来自 MDTX-").append(Version.mdtXBuild).append("的分享记录\n");
+        s.append("分享者：").append(player.name).append("\n");
+        s.append("蓝图代码链接：").append(msg).append("\n");
+        s.append("蓝图名：").append(schem.name()).append("\n");
+        s.append("蓝图造价：");
+        ItemSeq arr = schem.requirements();
+        for(ItemStack stack : arr){
+            s.append(stack.item.localizedName).append(stack.amount).append("|");
+        }
+        s.append("\n").append("电力：");
+        float cons = schem.powerConsumption() * 60, prod = schem.powerProduction() * 60;
+        if(!Mathf.zero(prod)){
+            s.append("+").append(Strings.autoFixed(prod, 2));
+            if(!Mathf.zero(cons)){
+                s.append("|");
+            }
+        }
+        if(!Mathf.zero(cons)){
+            s.append("-").append(Strings.autoFixed(cons, 2));
+        }
+        if (schematics.writeBase64(schem).length() > 3500) s.append("\n").append("蓝图代码过长，请点击链接查看");
+        else s.append("\n").append("蓝图代码：\n").append(schematics.writeBase64(schem));
+        Core.app.setClipboardText(Strings.stripColors(s.toString()));
+        UIExt.announce("已保存至剪贴板");
+    }
+
+    public void readShare(String base64, @Nullable Player sender) {
+        Core.app.post(() -> {
+            try {
+                Schematic s = Schematics.readBase64(base64);
+                s.removeSteamID();
+                s.tags.put("name", sender == null ? "来自服务器的蓝图" : "来自" + sender.plainName() + "的蓝图");
+                fromShare = true;
+                SchematicsDialog.this.showInfo(s);
+            } catch(Throwable e) {
+                ui.showException(e);
+            }
+        });
+    }
+
+    private String arcSchematicsInfo(Schematic schem, boolean description){
+        StringBuilder builder = new StringBuilder("标记了蓝图[" + schem.name() + "]。");
+        builder.append("属性：").append(schem.width).append("x").append(schem.height).append("，").append(schem.tiles.size).append("个建筑。");
+        if(description){
+            builder.append("耗材：");
+            ItemSeq arr = schem.requirements();
+            for(ItemStack s : arr){
+                builder.append(s.item.emoji()).append(s.amount).append("|");
+            }
+
+            builder.append("。电力：");
+            cont.row();
+            float cons = schem.powerConsumption() * 60, prod = schem.powerProduction() * 60;
+            if(!Mathf.zero(prod)){
+                builder.append("+").append(Strings.autoFixed(prod, 2));
+                if(!Mathf.zero(cons)){
+                    builder.append("|");
+                }
+            }
+            if(!Mathf.zero(cons)){
+                builder.append("-").append(Strings.autoFixed(cons, 2));
+            }
+        }
+        return builder.toString();
+    }
+
+
     public void showEdit(Schematic s){
         new BaseDialog("@schematic.edit"){{
             setFillParent(true);
@@ -572,6 +778,11 @@ public class SchematicsDialog extends BaseDialog{
                     t.button("@schematic.texttag", Icon.add, () -> showNewTag(res -> rebuild[0].run())).wrapLabel(false).get().getLabelCell().padLeft(5);
                     t.button("@schematic.icontag", Icon.add, () -> showNewIconTag(res -> rebuild[0].run())).wrapLabel(false).get().getLabelCell().padLeft(5);
                 });
+                p.row();
+                p.table(t ->{
+                    t.left().defaults().fillX().height(tagh).pad(2);
+                    t.button("自动标签", Icon.add, () -> arcAutoTags(res -> rebuild[0].run())).wrapLabel(false).get().getLabelCell().padLeft(5);
+                });
 
             };
 
@@ -580,6 +791,135 @@ public class SchematicsDialog extends BaseDialog{
         dialog.show();
     }
 
+    void arcAutoTags(Cons<String> cons){
+        new Dialog(){{
+            closeOnBack();
+            setFillParent(true);
+
+            cont.pane(t -> {
+                resized(true, () -> {
+                    t.clearChildren();
+                    t.marginRight(19f);
+                    t.defaults().size(48f);
+
+                    int cols = (int)Math.min(20, Core.graphics.getWidth() / Scl.scl(52f));
+
+                    for(ContentType ctype : defaultContentIcons){
+                        t.row();
+                        t.image().colspan(cols).growX().width(Float.NEGATIVE_INFINITY).height(3f).color(Pal.accent);
+                        t.row();
+
+                        int i = 0;
+                        for(UnlockableContent u : content.getBy(ctype).<UnlockableContent>as()){
+                            if(!u.isHidden() && u.unlockedNow() && u.hasEmoji() && !tags.contains(u.emoji())){
+                                t.button(new TextureRegionDrawable(u.uiIcon), Styles.flati, iconMed, () -> {
+                                    String out = u.emoji() + "";
+
+                                    tags.add(out);
+                                    tagsChanged();
+
+                                    if(u instanceof Block block){
+                                        for(Schematic s : schematics.all()){
+                                            s.tiles.each(sBlock -> {
+                                                if(sBlock.block == block){
+                                                    addTag(s,out);
+                                                    cons.get(out);
+                                                    hide();
+                                                }
+                                            });
+                                        }
+                                    }
+                                    else if(u instanceof Item item){
+                                        Seq<Block> blocklist = new Seq<>();
+                                        for (Block factory : content.blocks()) {
+                                            if(factory instanceof GenericCrafter crafter){
+                                                if(crafter.outputItems == null) continue;
+                                                for(ItemStack stack:crafter.outputItems){
+                                                if (stack.item == item) blocklist.add(factory);
+                                                }
+                                            }
+                                        }
+                                        for(Schematic s : schematics.all()){
+                                            s.tiles.each(sBlock -> {
+                                                if(blocklist.contains(sBlock.block)){
+                                                    addTag(s,out);
+                                                    cons.get(out);
+                                                    hide();
+                                                }
+                                            });
+                                        }
+                                    }
+                                    else if(u instanceof Liquid liquid){
+                                        Seq<Block> blocklist = new Seq<>();
+                                        for (Block factory : content.blocks()) {
+                                            if(factory instanceof GenericCrafter crafter){
+                                                if(crafter.outputLiquids==null) continue;
+                                                for(LiquidStack stack: crafter.outputLiquids){
+                                                    if (stack.liquid == liquid) blocklist.add(factory);
+                                                }
+                                            }
+                                        }
+                                        for(Schematic s : schematics.all()){
+                                            s.tiles.each(sBlock -> {
+                                                if(blocklist.contains(sBlock.block)){
+                                                    addTag(s,out);
+                                                    cons.get(out);
+                                                    hide();
+                                                }
+                                            });
+                                        }
+                                    }
+
+
+                                    cons.get(out);
+
+                                    hide();
+                                });
+
+                                if(++i % cols == 0) t.row();
+                            }
+                        }
+                    }
+                });
+            });
+            buttons.button("@back", Icon.left, this::hide).size(210f, 64f);
+        }}.show();
+    }
+
+    void syncPlanetTags(){
+        UIExt.announce("标签自动分类中...请稍后");
+        for(Schematic s : schematics.all()){
+            Boolean surpulo = true;
+            Boolean erekir = true;
+            for (Item item:erekirOnlyItems){
+                if(s.requirements().has(item)) {
+                    surpulo = false;
+                    break;
+                }
+            }
+            for(Item item : serpuloItems.copy().removeAll(erekirItems::contains)){
+                if(s.requirements().has(item)) {
+                    erekir = false;
+                    break;
+                }
+            }
+
+            if(surpulo && !s.labels.contains(surpuloTags)) addTag(s,surpuloTags);
+            if(erekir && !s.labels.contains(erekirTags)) addTag(s,erekirTags);
+        }
+        UIExt.announce("标签分类完成");
+    }
+
+    boolean arcSchematicCanBuild(Schematic s){
+        for (ItemStack item : s.requirements()){
+            if (!ui.hudfrag.coreItems.hadItem(item.item)) return false;
+        }
+        for (Block block: state.rules.bannedBlocks){
+            if (s.containsBlock(block)) return false;
+        }
+        return true;
+    }
+
     void buildTags(Schematic schem, Table t){
         buildTags(schem, t, true);
     }
@@ -790,13 +1130,44 @@ public class SchematicsDialog extends BaseDialog{
                     }
                 });
             }
+            cont.row();
 
+            schem.calProduction();
+            cont.table(r -> {
+                int i = 0;
+                for(Item item : schem.items.keys()){
+                    r.image(item.uiIcon).left().size(iconMed);
+                    r.label(
+                            () -> (schem.items.get(item, 0) > 0 ? "+" : "") + Strings.autoFixed(schem.items.get(item, 0), 2) + StatUnit.perSecond.localized()
+                    ).padLeft(2).left().padRight(5).color(Color.lightGray);
+                    if(++i % 4 == 0){
+                        r.row();
+                    }
+                }
+                for (Liquid liquid : schem.liquids.keys()) {
+                    r.image(liquid.uiIcon).left().size(iconMed);
+                    r.label(
+                            () -> (schem.liquids.get(liquid, 0) > 0 ? "+" : "") + Strings.autoFixed(schem.liquids.get(liquid, 0), 2) + StatUnit.perSecond.localized()
+                    ).padLeft(2).left().padRight(5).color(Color.lightGray);
+                    if(++i % 4 == 0){
+                        r.row();
+                    }
+                }
+            });
             buttons.clearChildren();
             buttons.defaults().size(Core.graphics.isPortrait() ? 150f : 210f, 64f);
             buttons.button("@back", Icon.left, this::hide);
             buttons.button("@editor.export", Icon.upload, () -> showExport(schem));
             buttons.button("@edit", Icon.edit, () -> showEdit(schem));
-
+            if (fromShare) {
+                fromShare = false;
+                buttons.button("@save", Icon.save, () -> {
+                    schematics.add(schem);
+                    setup();
+                    ui.showInfoFade("@schematic.saved");
+                    checkTags(schem);
+                });
+            }
             show();
         }
     }
diff --git a/core/src/mindustry/ui/dialogs/SettingsMenuDialog.java b/core/src/mindustry/ui/dialogs/SettingsMenuDialog.java
index c56d6bf691ba20d0d97fde2295819f82c6e3fbd9..b71452eca5b3527f0c2ee15edd8d6ef01ab4365d 100644
--- a/core/src/mindustry/ui/dialogs/SettingsMenuDialog.java
+++ b/core/src/mindustry/ui/dialogs/SettingsMenuDialog.java
@@ -300,7 +300,6 @@ public class SettingsMenuDialog extends BaseDialog{
         sound.sliderPref("musicvol", 100, 0, 100, 1, i -> i + "%");
         sound.sliderPref("sfxvol", 100, 0, 100, 1, i -> i + "%");
         sound.sliderPref("ambientvol", 100, 0, 100, 1, i -> i + "%");
-        sound.sliderPref("arcvol", settings.getInt("musicvol"), 0, 100, 1, i -> i + "%");
 
         game.sliderPref("saveinterval", 60, 10, 5 * 120, 10, i -> Core.bundle.format("setting.seconds", i));
 
diff --git a/core/src/mindustry/ui/fragments/ChatFragment.java b/core/src/mindustry/ui/fragments/ChatFragment.java
index 89b9a23ce2bb850df5c7ae99a5f964753a807662..03bbbbfca69229893fc097479f4078843ea0c56d 100644
--- a/core/src/mindustry/ui/fragments/ChatFragment.java
+++ b/core/src/mindustry/ui/fragments/ChatFragment.java
@@ -163,7 +163,10 @@ public class ChatFragment extends Table{
         Draw.alpha(shadowColor.a * opacity);
 
         float theight = offsety + spacing + getMarginBottom() + scene.marginBottom;
-        for(int i = scrollPos; i < messages.size && i < messagesShown + scrollPos && (i < fadetime || shown); i++){
+        int messageCount = 0;
+        for(int i = scrollPos; i < messages.size && messageCount < messagesShown && (i < fadetime || shown); i++){
+            if(!chatValidType(messages.get(i))) continue;
+            messageCount += 1;
 
             layout.setText(font, messages.get(i), Color.white, textWidth, Align.bottomLeft, true);
             theight += layout.height + textspacing;
@@ -194,6 +197,17 @@ public class ChatFragment extends Table{
         }
     }
 
+    private boolean chatValidType(String msg){
+        int chatType = settings.getInt("chatValidType");
+        if(chatType == 0 && (msg.contains("[acid][公屏][white]") || msg.contains("[逻辑~"))) return false;
+        else if(chatType == 1 &&
+        (msg.contains("加入了服务器") || msg.contains("离开了服务器") || msg.contains("小贴士") || msg.contains("自动存档完成") ||
+        msg.contains("登录成功") || msg.contains("经验+") || msg.contains("[ARC")
+        || (msg.contains("[acid][公屏][white]")) || msg.contains("[逻辑~"))) return false;
+        else if(chatType == 2 && !(msg.contains("[acid][公屏][white]") || msg.contains("[逻辑~"))) return false;
+        return true;
+    }
+
     private void sendMessage(){
         String message = chatfield.getText().trim();
         clearChatInput();
@@ -216,6 +230,8 @@ public class ChatFragment extends Table{
             if(mobile){
                 TextInput input = new TextInput();
                 input.maxLength = maxTextLength;
+                //MDTX mobile chatField support (from ARC)
+                input.text = chatfield.getText() + " ";
                 input.accepted = text -> {
                     chatfield.setText(text);
                     sendMessage();
@@ -245,7 +261,12 @@ public class ChatFragment extends Table{
     }
 
     public void updateChat(){
-        chatfield.setText(mode.normalizedPrefix() + history.get(historyPos));
+        //MDTX: better prefix handle (from ARC)
+        if(history.get(historyPos).contains(mode.normalizedPrefix())){
+            chatfield.setText(history.get(historyPos));
+        }else{
+            chatfield.setText(mode.normalizedPrefix() + history.get(historyPos));
+        }
         updateCursor();
     }
 
diff --git a/core/src/mindustry/ui/fragments/ConsoleFragment.java b/core/src/mindustry/ui/fragments/ConsoleFragment.java
index e74e6a12e3da57eb58598eb4e679a7990c109def..013255ce5aa828d538814fa25dc64c6a56bf9136 100644
--- a/core/src/mindustry/ui/fragments/ConsoleFragment.java
+++ b/core/src/mindustry/ui/fragments/ConsoleFragment.java
@@ -12,9 +12,11 @@ import arc.scene.ui.TextField.*;
 import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
+import mindustryX.features.ui.ArcMessageDialog;
 import mindustry.game.EventType.*;
 import mindustry.input.*;
 import mindustry.ui.*;
+import mindustryX.features.ui.ArcMessageDialog.*;
 
 import static arc.Core.*;
 import static mindustry.Vars.*;
@@ -163,6 +165,7 @@ public class ConsoleFragment extends Table{
         clearChatInput();
 
         if(message.replace(" ", "").isEmpty()) return;
+        ArcMessageDialog.addMsg(new Msg(Type.console,message));
 
         //special case for 'clear' command
         if(message.equals("clear")){
diff --git a/core/src/mindustry/ui/fragments/HudFragment.java b/core/src/mindustry/ui/fragments/HudFragment.java
index 931de74134ae4c8672dc96c894bb058f7c6644c0..05ee253ff82f534c6d43692397a135799de17457 100644
--- a/core/src/mindustry/ui/fragments/HudFragment.java
+++ b/core/src/mindustry/ui/fragments/HudFragment.java
@@ -14,6 +14,7 @@ import arc.scene.ui.ImageButton.*;
 import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
+import mindustry.*;
 import mindustry.annotations.Annotations.*;
 import mindustry.content.*;
 import mindustry.core.GameState.*;
@@ -34,6 +35,7 @@ import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
 import static mindustry.gen.Tex.*;
+import static mindustry.ui.Styles.*;
 
 public class HudFragment{
     private static final float dsize = 65f, pauseHeight = 36f;
@@ -45,6 +47,8 @@ public class HudFragment{
     public NewCoreItemsDisplay coreItems = new NewCoreItemsDisplay();
     private AuxiliaryTools auxiliaryTools;
 
+    private boolean hideObjectives = true;
+
     private String hudText = "";
     private boolean showHudText;
 
@@ -52,6 +56,8 @@ public class HudFragment{
     private Table lastUnlockLayout;
     private long lastToast;
 
+    private final Table arcStatus = new Table();
+
     public void build(Group parent){
         auxiliaryTools = new AuxiliaryTools();
 
@@ -92,6 +98,11 @@ public class HudFragment{
             showToast(Icon.warning, Core.bundle.format("sector.attacked", e.sector.name()));
         });
 
+        Events.on(WorldLoadEvent.class,e->{
+            hideObjectives = false;
+            rebuildArcStatus();
+        });
+
         //paused table
         parent.fill(t -> {
             t.name = "paused";
@@ -116,13 +127,16 @@ public class HudFragment{
             t.add(new Minimap()).name("minimap");
             t.row();
             //position
-            t.label(() ->
-                (Core.settings.getBool("position") ? player.tileX() + "," + player.tileY() + "\n" : "") +
-                (Core.settings.getBool("mouseposition") ? "[lightgray]" + World.toTile(Core.input.mouseWorldX()) + "," + World.toTile(Core.input.mouseWorldY()) : ""))
-            .visible(() -> Core.settings.getBool("position") || Core.settings.getBool("mouseposition"))
-            .touchable(Touchable.disabled)
-            .style(Styles.outlineLabel)
-            .name("position");
+            t.table(tt-> {
+                tt.label(() -> player.unit().type.emoji() +
+                                (Core.settings.getBool("position") ? player.tileX() + "," + player.tileY() + "\n" : "") +
+                                (Core.settings.getBool("mouseposition") ? "[lightgray]" + "♐" + World.toTile(Core.input.mouseWorldX()) + "," + World.toTile(Core.input.mouseWorldY()) : ""))
+                        .visible(() -> Core.settings.getBool("position") || Core.settings.getBool("mouseposition"))
+                        .touchable(Touchable.disabled)
+                        .style(Styles.outlineLabel)
+                        .name("position");
+                tt.button("♐",cleart, MarkerType::lockOnLastMark).size(30,30).tooltip("锁定上个标记点");
+            }).style(Styles.outlineLabel);
             if(Core.settings.getInt("AuxiliaryTable") == 3){
                 t.row();
                 t.table(infoWave -> {
@@ -219,12 +233,16 @@ public class HudFragment{
             Table wavesMain, editorMain;
 
             cont.stack(wavesMain = new Table(), editorMain = new Table()).height(wavesMain.getPrefHeight())
-            .name("waves/editor");
+            .name("waves/editor").top().left();
 
             wavesMain.visible(() -> shown && !state.isEditor());
             wavesMain.top().left().name = "waves";
 
             wavesMain.table(s -> {
+                if(Core.settings.getBool("arcSpecificTable")){
+                    s.add(makeStatusTableArc()).grow().name("status");
+                    return;
+                }
                 //wave info button with text
                 s.add(makeStatusTable()).grow().name("status");
 
@@ -245,7 +263,13 @@ public class HudFragment{
                         logic.skipWave();
                     }
                 }).growY().fillX().right().width(40f).disabled(b -> !canSkipWave()).name("skip").get().toBack();
-            }).width(dsize * 5 + 4f).name("statustable");
+                // Power bar display
+                if (Core.settings.getBool("powerStatistic")){
+                    s.row();
+                    s.add(ArcPowerInfo.getBars()).growX().colspan(s.getColumns());
+                }
+
+            }).width(dsize * 5 + 4f).name("statustable").left();
 
             wavesMain.row();
 
@@ -261,6 +285,7 @@ public class HudFragment{
 
             editorMain.name = "editor";
             editorMain.table(Tex.buttonEdge4, t -> {
+                t.visible(() -> UIExt.advanceToolTable != null && UIExt.advanceToolTable.parent.visible);
                 //t.margin(0f);
                 t.name = "teams";
                 t.add("@editor.teams").growX().left();
@@ -279,6 +304,7 @@ public class HudFragment{
                             teams.row();
                         }
                     }
+                    teams.button("更多", () -> UIExt.teamSelect.pickOne(team -> Call.setPlayerTeamEditor(player, team), player.team())).center().row();
                 }).left();
             }).width(dsize * 5 + 4f);
             editorMain.visible(() -> shown && state.isEditor());
@@ -303,6 +329,8 @@ public class HudFragment{
                 IntFormat mem = new IntFormat("memory");
                 IntFormat memnative = new IntFormat("memory2");
 
+                info.add("MDTX~"+ Version.mdtXBuild).color(Pal.accent).left();
+                info.row();
                 info.label(() -> fps.get(Core.graphics.getFramesPerSecond())).left().style(Styles.outlineLabel).name("fps");
                 info.row();
                 info.label(() -> Strings.format("LG/DW/UI(ms) @/@/@", Time.nanosToMillis(DebugUtil.logicTime), Time.nanosToMillis(DebugUtil.rendererTime), Time.nanosToMillis(DebugUtil.uiTime)))
@@ -311,6 +339,10 @@ public class HudFragment{
                 info.label(() -> Strings.format("D/V/T/F @/@/@/@",
                 DebugUtil.lastDrawRequests, DebugUtil.lastVertices, DebugUtil.lastSwitchTexture, DebugUtil.lastFlushCount)).left().style(Styles.outlineLabel).name("draw");
                 info.row();
+                if (!android){
+                    info.label(() -> "缩放: " + String.format("%.2f", renderer.getScale())).left().style(Styles.outlineLabel);
+                    info.row();
+                }
 
                 if(android){
                     info.label(() -> memnative.get((int)(Core.app.getJavaHeap() / 1024 / 1024), (int)(Core.app.getNativeHeap() / 1024 / 1024))).left().style(Styles.outlineLabel).name("memory2");
@@ -390,7 +422,7 @@ public class HudFragment{
                 }
                 return max == 0f ? 0f : val / max;
             }).blink(Color.white).outline(new Color(0, 0, 0, 0.6f), 7f)).grow())
-            .fillX().width(320f).height(60f).name("boss").visible(() -> state.rules.waves && state.boss() != null && !(mobile && Core.graphics.isPortrait())).padTop(7).row();
+            .fillX().width(320f).height(60f).name("boss").visible(() -> Core.settings.getBool("override_boss_shown") && state.rules.waves && state.boss() != null && !(mobile && Core.graphics.isPortrait())).padTop(7).row();
 
             t.table(Styles.black3, p -> p.margin(4).label(() -> hudText).style(Styles.outlineLabel)).touchable(Touchable.disabled).with(p -> p.visible(() -> {
                 p.color.a = Mathf.lerpDelta(p.color.a, Mathf.num(showHudText), 0.2f);
@@ -921,6 +953,143 @@ public class HudFragment{
         return table;
     }
 
+
+    private Table makeStatusTableArc() {
+        Table table = new Table(buttonEdge4);
+
+        table.name = "waves";
+
+        table.marginTop(0).marginBottom(4).marginLeft(4);
+
+        table.table(t -> {
+            t.margin(0);
+            t.clicked(() -> {
+                if (!player.dead() && mobile) {
+                    Call.unitClear(player);
+                    control.input.recentRespawnTimer = 1f;
+                    control.input.controlledType = null;
+                }
+            });
+            t.image(() -> player.icon()).size(iconMed);
+            t.row();
+            t.add(new Bar(
+                    () -> {
+                        if (player.unit().shield > 0) {
+                            return UI.formatAmount((long) player.unit().health) + "[gray]+[white]" + UI.formatAmount((long) player.unit().shield);
+                        } else {
+                            return UI.formatAmount((long) player.unit().health);
+                        }
+                    },
+                    () -> Pal.health,
+                    () -> Math.min(player.unit().health / player.unit().maxHealth, 1))).height(18).growX();
+            t.row();
+            t.add(new Bar(
+                    () -> {
+                        if (state.rules.unitAmmo)
+                            return player.unit().type.ammoType.icon() + (int) player.unit().ammo + "/" + player.unit().type.ammoCapacity;
+                        else return player.unit().type.ammoType.icon();
+                    },
+                    () -> player.unit().type.ammoType.barColor(),
+                    () -> {
+                        if (state.rules.unitAmmo) return player.unit().ammo / player.unit().type.ammoCapacity;
+                        else return 1;
+                    })).height(18).growX();
+            t.row();
+
+        }).size(110, 80).padRight(4);
+
+        rebuildArcStatus();
+        table.add(arcStatus).growX().pad(4f);
+
+        // Power bar display
+        if (Core.settings.getBool("powerStatistic")) {
+            table.row();
+            table.add(ArcPowerInfo.getBars()).growX().colspan(table.getColumns());
+        }
+        return table;
+    }
+
+    private void rebuildArcStatus() {
+        arcStatus.clear();
+
+        boolean showSkipWave = canSkipWave();
+        arcStatus.update(() -> {
+            if (showSkipWave !=  canSkipWave()) rebuildArcStatus();
+        });
+
+        arcStatus.clicked(() -> {
+            hideObjectives = !hideObjectives;
+            rebuildArcStatus();
+        });
+
+        if (!getStatusText().isEmpty()) {
+            arcStatus.labelWrap(() -> hideObjectives && getStatusText().length() > 20 ? getStatusText().substring(0, 20) : getStatusText()).width(showSkipWave ? 150f : 190f);
+        } else {
+            arcStatus.table(tt->{
+                tt.update(() -> {
+                    if (!getStatusText().isEmpty()) rebuildArcStatus();
+                });
+                tt.add(new Bar(
+                        this::calWaveShower,
+                        () -> Color.valueOf("ccffcc"),
+                        () -> {
+                            if (CalWinWave() >= 1 && CalWinWave() >= state.wave)
+                                return state.wave / (float) CalWinWave();
+                            else return 1f;
+                        })).height(18).growX().row();
+                tt.add(new Bar(
+                        () -> FormatDefault.duration((float)((state.rules.waveTimer ? state.wavetime : state.tick) / 60)),
+                        () -> Color.valueOf("F5DEB3"),
+                        () -> state.wavetime / state.rules.waveSpacing)).height(18).growX().row();
+                tt.add(new Bar(
+                        () -> {
+                            if (Vars.spawner.countSpawns() <= 1 || state.rules.mode() == Gamemode.pvp) {
+                                return "[orange]" + state.enemies + "[gray](+" + calWaveEnemy(state.wave - 1) + ")";
+                            } else if (calWaveEnemy(state.wave - 1) > 0) {
+                                return "[orange]" + state.enemies + "[gray](+" + calWaveEnemy(state.wave - 1) + "×" + Vars.spawner.countSpawns() + ")";
+                            } else {
+                                return "[orange]" + state.enemies + "[gray](+0)";
+                            }
+                        },
+                        () -> Color.valueOf("F4A460"),
+                        () -> state.enemies / ((float) calWaveEnemy(state.wave - 2) * Vars.spawner.countSpawns()))).height(18).growX();
+            }).width(showSkipWave? 150f : 190f);
+        }
+
+        if (canSkipWave()) {
+            arcStatus.button(Icon.play, clearNonei, 30f, () -> {
+                if (net.client() && player.admin) {
+                    Call.adminRequest(player, AdminAction.wave, null);
+                } else {
+                    logic.skipWave();
+                }
+            }).growY().fillX().right().width(40f);
+        }
+    }
+
+    public String getStatusText() {
+        StringBuilder objBuilder = new StringBuilder();
+
+        if (state.rules.objectives.any()) {
+            boolean first = true;
+            for (var obj : state.rules.objectives) {
+                if (!obj.qualified()) continue;
+
+                String text = obj.text();
+                if (text != null) {
+                    if (!first) objBuilder.append('\n');
+                    objBuilder.append(text);
+
+                    first = false;
+                }
+            }
+        }
+        if (objBuilder.length() == 0 && state.rules.mission != null)
+            objBuilder.append(state.rules.mission);
+
+        return objBuilder.toString();
+    }
+
     private void addInfoTable(Table table){
         table.name = "infotable";
         table.left();
@@ -965,7 +1134,51 @@ public class HudFragment{
     }
 
     private boolean canSkipWave(){
-        return state.rules.waves && state.rules.waveSending && ((net.server() || player.admin) || !net.active()) && state.enemies == 0 && !spawner.isSpawning();
+        return Core.settings.getBool("overrideSkipWave") || state.rules.waves && state.rules.waveSending && ((net.server() || player.admin) || !net.active()) && state.enemies == 0 && !spawner.isSpawning();
+    }
+
+    private String calWaveShower(){
+        StringBuilder builder = new StringBuilder();
+
+
+        if(!state.rules.waves && state.rules.attackMode){
+            int sum = Math.max(state.teams.present.sum(t -> t.team != player.team() ? t.cores.size : 0), 1);
+            builder.append("敌人核心：[orange]").append(sum);
+            return builder.toString();
+        }
+
+        if(!state.rules.waves && state.isCampaign()){
+            builder.append("[lightgray]").append(Core.bundle.get("sector.curcapture"));
+        }
+
+        if(!state.rules.waves){
+            return builder.toString();
+        }
+
+        if(CalWinWave() > 1 && CalWinWave() >= state.wave){
+            builder.append("[orange]").append(state.wave).append("[white]/[yellow]").append(CalWinWave());
+        }else{
+            builder.append("波次：[orange]").append(state.wave);
+        }
+        return builder.toString();
+    }
+
+    private int calWaveEnemy(int wave){
+        int waveEnemy = 0;
+        for(SpawnGroup group : state.rules.spawns){
+            waveEnemy += group.getSpawned(Math.max(0, wave));
+        }
+        return waveEnemy;
+    }
+
+    private int CalWinWave(){
+        if (state.rules.winWave >= 1) return state.rules.winWave;
+        int maxwave = 0;
+        for(SpawnGroup group : state.rules.spawns){
+            maxwave = Math.max(maxwave ,group.end);
+        }
+        if (maxwave > 10000) return 0;
+        return maxwave + 1;
     }
 
 }
diff --git a/core/src/mindustry/ui/fragments/MenuFragment.java b/core/src/mindustry/ui/fragments/MenuFragment.java
index 25d953a861fbcddea24225be733445e953e717ef..85a5ca45ad3c3741633b646bff8d8ba90b9542a2 100644
--- a/core/src/mindustry/ui/fragments/MenuFragment.java
+++ b/core/src/mindustry/ui/fragments/MenuFragment.java
@@ -1,6 +1,7 @@
 package mindustry.ui.fragments;
 
 import arc.*;
+import arc.files.*;
 import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
@@ -33,6 +34,14 @@ public class MenuFragment{
 
     MenuFloatLabel floatLabel;
 
+    Fi arcBackground;
+    String arcBackgroundPath = Core.settings.getString("arcBackgroundPath");
+    Seq<Fi> arcBGList;
+
+    Image img = new Image();
+
+    int arcBackgroundIndex = 0;
+
     public void build(Group parent){
         renderer = new MenuRenderer();
 
@@ -44,7 +53,18 @@ public class MenuFragment{
         parent.addChild(floatLabel = new MenuFloatLabel());
         parent = group;
 
-        parent.fill((x, y, w, h) -> renderer.render());
+        if(arcBackgroundPath != null && Core.files.absolute(arcBackgroundPath).exists() && Core.files.absolute(arcBackgroundPath).list().length >= 1){
+            arcBackgroundIndex = (int)(Math.random() * Core.files.absolute(arcBackgroundPath).list().length);
+            nextBackGroundImg();
+            if(arcBGList.size == 0){
+                parent.fill((x, y, w, h) -> renderer.render());
+            }else{
+                group.addChild(img);
+                img.setFillParent(true);
+            }
+        }else{
+            parent.fill((x, y, w, h) -> renderer.render());
+        }
 
         parent.fill(c -> {
             c.pane(Styles.noBarPane, cont -> {
@@ -91,6 +111,11 @@ public class MenuFragment{
             }));
         }
 
+        parent.fill(c -> c.bottom().left().table(t -> {
+            t.background(Tex.buttonEdge3);
+            t.button("\uE83D", Styles.cleart, this::nextBackGroundImg).width(50f);
+        }).visible(() -> Core.settings.getString("arcBackgroundPath", "").length() != 0).left().width(100));
+
         String versionText = ((Version.build == -1) ? "[#fc8140aa]" : "[#ffffffba]") + Version.combined();
         parent.fill((x, y, w, h) -> {
             TextureRegion logo = Core.atlas.find("logo");
@@ -116,6 +141,22 @@ public class MenuFragment{
         }).touchable = Touchable.disabled;
     }
 
+    private void nextBackGroundImg(){
+        arcBGList = Core.files.absolute(arcBackgroundPath).findAll(f -> !f.isDirectory() && (f.extEquals("png") || f.extEquals("jpg") || f.extEquals("jpeg")));
+        if(arcBGList.size == 0) return;
+        arcBackgroundPath = Core.settings.getString("arcBackgroundPath");
+        arcBackgroundIndex += 1;
+        arcBackgroundIndex = arcBackgroundIndex % arcBGList.size;
+        new Thread(() -> {
+            try{
+                arcBackground = arcBGList.get(arcBackgroundIndex);
+                Core.app.post(() -> img.setDrawable(new TextureRegion(new Texture(arcBackground))));
+            }catch(Exception e){
+                Core.app.post(() -> ui.showException("背景图片无效:" + arcBGList.get(arcBackgroundIndex).path(), e));
+            }
+        }).start();
+    }
+
     private void buildMobile(){
         container.clear();
         container.name = "buttons";
@@ -133,7 +174,7 @@ public class MenuFragment{
             tools = new MobileButton(Icon.settings, "@settings", ui.settings::show),
             mods = new MobileButton(Icon.book, "@mods", ui.mods::show),
             exit = new MobileButton(Icon.exit, "@quit", () -> Core.app.exit()),
-            about = new MobileButton(Icon.info, "@about.button", ui.about::show);
+            database = new MobileButton(Icon.book, "@database", ui.database::show);
 
         Seq<MobileButton> customs = customButtons.map(b -> new MobileButton(b.icon, b.text, b.runnable == null ? () -> {} : b.runnable));
 
@@ -152,11 +193,12 @@ public class MenuFragment{
             container.add(editor);
             container.add(tools);
             container.add(mods);
+            container.add(database);
             // add even custom buttons (before the exit button)
             for(int i = 0; i < customs.size; i += 2){
                 container.add(customs.get(i));
             }
-            container.add(ios ? about : exit);
+            if(!ios) container.add(exit);
         }else{
             container.marginTop(0f);
             container.add(play);
@@ -174,7 +216,9 @@ public class MenuFragment{
                 container.add(customs.get(i));
                 if(i % 2 == 0) container.row();
             }
-            container.add(ios ? about : exit);
+            if(!ios) container.add(exit);
+            container.row();
+            container.add(database);
         }
     }
 
@@ -196,14 +240,15 @@ public class MenuFragment{
                     new MenuButton("@campaign", Icon.play, () -> checkPlay(ui.planet::show)),
                     new MenuButton("@joingame", Icon.add, () -> checkPlay(ui.join::show)),
                     new MenuButton("@customgame", Icon.terrain, () -> checkPlay(ui.custom::show)),
-                    new MenuButton("@loadgame", Icon.download, () -> checkPlay(ui.load::show))
-                ),
+                    new MenuButton("@loadgame", Icon.download, () -> checkPlay(ui.load::show)),
+                    new MenuButton("@editor", Icon.terrain, () -> checkPlay(ui.maps::show)),
+                     steam ? new MenuButton("@workshop", Icon.steam, platform::openWorkshop) : null
+            ),
                 new MenuButton("@database.button", Icon.menu,
                     new MenuButton("@schematics", Icon.paste, ui.schematics::show),
                     new MenuButton("@database", Icon.book, ui.database::show),
                     new MenuButton("@about.button", Icon.info, ui.about::show)
                 ),
-                new MenuButton("@editor", Icon.terrain, () -> checkPlay(ui.maps::show)), steam ? new MenuButton("@workshop", Icon.steam, platform::openWorkshop) : null,
                 new MenuButton("@mods", Icon.book, ui.mods::show),
                 new MenuButton("@settings", Icon.settings, ui.settings::show)
             );
diff --git a/core/src/mindustry/ui/fragments/PlacementFragment.java b/core/src/mindustry/ui/fragments/PlacementFragment.java
index 2c3e6ad5249a532799dde66f1abde1ac5884a2a8..cd6b06189153afbe838a8a2d862044ad8d440c67 100644
--- a/core/src/mindustry/ui/fragments/PlacementFragment.java
+++ b/core/src/mindustry/ui/fragments/PlacementFragment.java
@@ -1,6 +1,7 @@
 package mindustry.ui.fragments;
 
 import arc.*;
+import arc.func.Boolf;
 import arc.graphics.*;
 import arc.input.*;
 import arc.math.geom.*;
@@ -12,6 +13,7 @@ import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
 import mindustry.ai.*;
+import mindustryX.features.ui.BlockSelectDialog;
 import mindustry.content.*;
 import mindustry.core.*;
 import mindustry.entities.*;
@@ -24,22 +26,27 @@ import mindustry.input.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.*;
+import mindustry.world.blocks.ConstructBlock;
 import mindustry.world.blocks.ConstructBlock.*;
+import mindustryX.features.*;
+import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
 
 public class PlacementFragment{
-    final int rowWidth = 4;
+    private int rowWidth, maxRow;
 
     public Category currentCategory = Category.distribution;
 
     Seq<Block> returnArray = new Seq<>(), returnArray2 = new Seq<>();
     Seq<Category> returnCatArray = new Seq<>();
     boolean[] categoryEmpty = new boolean[Category.all.length];
-    ObjectMap<Category,Block> selectedBlocks = new ObjectMap<>();
+    public ObjectMap<Category,Block> selectedBlocks = new ObjectMap<>();
     ObjectFloatMap<Category> scrollPositions = new ObjectFloatMap<>();
     @Nullable Block menuHoverBlock;
-    @Nullable Displayable hover;
+    @Nullable Displayable hover,hover2;
+    @Nullable Tile hoverTile;
+    @Nullable Object lastDisplayTile;
     @Nullable Building lastFlowBuild, nextFlowBuild;
     @Nullable Object lastDisplayState;
     @Nullable Team lastTeam;
@@ -106,6 +113,10 @@ public class PlacementFragment{
                 if(nextFlowBuild.flowItems() != null) nextFlowBuild.flowItems().updateFlow();
                 if(nextFlowBuild.liquids != null) nextFlowBuild.liquids.updateFlow();
             }
+
+            if(rowWidth != Core.settings.getInt("itemSelectionWidth", 4) || maxRow != Core.settings.getInt("itemSelectionHeight", 4)){
+                rebuild();
+            }
         });
     }
 
@@ -128,6 +139,27 @@ public class PlacementFragment{
         if(Core.input.keyTap(Binding.pick) && player.isBuilder() && !Core.scene.hasDialog()){ //mouse eyedropper select
             var build = world.buildWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
 
+            if (build == null && AdvanceToolTable.worldCreator) {
+                var tile = world.tileWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
+                if (tile != null) {
+                    Block target;
+                    if (tile.block() != Blocks.air) {
+                        target = tile.block();
+                    }
+                    else if (tile.overlay() != Blocks.air) {
+                        target = tile.overlay();
+                    }
+                    else {
+                        target = tile.floor();
+                    }
+                    if (target != Blocks.air && (target.isVisible() || AdvanceToolTable.allBlocksReveal)) {
+                        input.block = target;
+                        currentCategory = input.block.category;
+                        return true;
+                    }
+
+                }
+            }
             //can't middle click buildings in fog
             if(build != null && build.inFogTo(player.team())){
                 build = null;
@@ -242,6 +274,8 @@ public class PlacementFragment{
     }
 
     public void build(Group parent){
+        rowWidth = Core.settings.getInt("itemSelectionWidth", 4);
+        maxRow = Core.settings.getInt("itemSelectionHeight", 4);
         parent.fill(full -> {
             toggler = full;
             full.bottom().right().visible(() -> ui.hudfrag.shown);
@@ -259,13 +293,14 @@ public class PlacementFragment{
                     group.setMinCheckCount(0);
 
                     for(Block block : getUnlockedByCategory(currentCategory)){
-                        if(!unlocked(block)) continue;
+                        if(!unlocked(block) && !AdvanceToolTable.allBlocksReveal) continue;
+                        if (block == Blocks.air || block instanceof ConstructBlock) continue;
                         if(index++ % rowWidth == 0){
                             blockTable.row();
                         }
 
                         ImageButton button = blockTable.button(new TextureRegionDrawable(block.uiIcon), Styles.selecti, () -> {
-                            if(unlocked(block)){
+                            if(unlocked(block) || AdvanceToolTable.allBlocksReveal){
                                 if((Core.input.keyDown(KeyCode.shiftLeft) || Core.input.keyDown(KeyCode.controlLeft)) && Fonts.getUnicode(block.name) != 0){
                                     Core.app.setClipboardText((char)Fonts.getUnicode(block.name) + "");
                                     ui.showInfoFade("@copied");
@@ -317,19 +352,22 @@ public class PlacementFragment{
 
                         //find current hovered thing
                         Displayable hovered = hover;
+                        Displayable hovered2 = hover2;
+                        Displayable hoveredTile = hoverTile;
                         Block displayBlock = menuHoverBlock != null ? menuHoverBlock : control.input.block;
                         Object displayState = displayBlock != null ? displayBlock : hovered;
                         boolean isHovered = displayBlock == null; //use hovered thing if displayblock is null
 
                         //don't refresh unnecessarily
                         //refresh only when the hover state changes, or the displayed block changes
-                        if(wasHovered == isHovered && lastDisplayState == displayState && lastTeam == player.team()) return;
+                        if(wasHovered == isHovered && lastDisplayState == displayState && lastDisplayTile == hoveredTile) return;
 
                         topTable.clear();
                         topTable.top().left().margin(5);
 
                         lastDisplayState = displayState;
                         wasHovered = isHovered;
+                        lastDisplayTile = hoveredTile;
                         lastTeam = player.team();
 
                         //show details of selected block, with costs
@@ -351,10 +389,10 @@ public class PlacementFragment{
                                 final String keyComboFinal = keyCombo;
                                 header.left();
                                 header.add(new Image(displayBlock.uiIcon)).size(8 * 4);
-                                header.labelWrap(() -> !unlocked(displayBlock) ? Core.bundle.get("block.unknown") : displayBlock.localizedName + keyComboFinal)
+                                header.labelWrap(() -> !unlocked(displayBlock) && !AdvanceToolTable.allBlocksReveal ? Core.bundle.get("block.unknown") : displayBlock.localizedName + keyComboFinal)
                                 .left().width(190f).padLeft(5);
                                 header.add().growX();
-                                if(unlocked(displayBlock)){
+                                if(unlocked(displayBlock) || AdvanceToolTable.allBlocksReveal){
                                     header.button("?", Styles.flatBordert, () -> {
                                         ui.content.show(displayBlock);
                                         Events.fire(new BlockInfoEvent());
@@ -398,6 +436,24 @@ public class PlacementFragment{
                         }else if(hovered != null){
                             //show hovered item, whatever that may be
                             hovered.display(topTable);
+                            if(hovered2 != hovered && hovered2 != null){
+                                topTable.row();
+                                hovered2.display(topTable);
+                            }}
+
+                        //只要可行便绘制地板|建筑，移除了其他重复绘制
+                        if (Core.settings.getBool("hoveredTileInfo") && hoveredTile != null) {
+                            topTable.row();
+                            topTable.row();
+                            topTable.table(t -> {
+                                t.left();
+                                t.add(new Image(hoverTile.floor().uiIcon)).size(20f).left();
+                                t.add(" " + hoverTile.floor().localizedName).left();
+                                if (hoverTile.block() != Blocks.air)
+                                    t.add(" | " + hoverTile.block().emoji() + (hoverTile.build != null ? "[#" + hoverTile.build.team.color + "]" : "") + hoverTile.block().localizedName).left();
+                                if (hoverTile.overlay() != Blocks.air)
+                                    t.add(" | " + hoverTile.overlay().emoji() + hoverTile.overlay().localizedName).left();
+                            }).growX().left();
                         }
                     });
                 }).colspan(3).fillX().visible(this::hasInfoBox).touchable(Touchable.enabled).row();
@@ -435,6 +491,7 @@ public class PlacementFragment{
 
                 //commandTable: commanded units
                 {
+                    boolean arcExtra= Core.settings.getBool("arcCommandTable");
                     commandTable.touchable = Touchable.enabled;
                     commandTable.add(Core.bundle.get("commandmode.name")).fill().center().labelAlign(Align.center).row();
                     commandTable.image().color(Pal.accent).growX().pad(20f).padTop(0f).padBottom(4f).row();
@@ -519,7 +576,7 @@ public class PlacementFragment{
                                                 Call.setUnitCommand(player, units.mapInt(un -> un.id).toArray(), command);
                                             }).checked(i -> currentCommand[0] == command).size(50f).tooltip(command.localized(), true);
 
-                                            if(++scol % 6 == 0) coms.row();
+                                            if(++scol % (rowWidth + 2) == 0) coms.row();
                                         }
 
                                     }).fillX().padTop(4f).left();
@@ -538,13 +595,66 @@ public class PlacementFragment{
                                                 Call.setUnitStance(player, units.mapInt(un -> un.id).toArray(), stance);
                                             }).checked(i -> currentStance[0] == stance).size(50f).tooltip(stance.localized(), true);
 
-                                            if(++scol % 6 == 0) coms.row();
+                                            if(++scol % (rowWidth + 2) == 0) coms.row();
+                                        }
+                                    }).fillX().padTop(4f).left();
+                                }
+                                if(arcExtra && control.input.selectedUnits.size > 0){
+                                    u.row();
+                                    u.table(sp -> {
+                                        float wound = (float) Core.settings.getInt("rtsWoundUnit") / 100f;
+                                        if (control.input.selectedUnits.contains(unit -> unit.health >= unit.maxHealth * wound) && control.input.selectedUnits.contains(unit -> unit.health < unit.maxHealth * wound)){
+                                            sp.table(spp->{
+                                                arcSelectUnits(spp,"[green]\uE813","高血量单位", unit -> unit.health >= unit.maxHealth * wound);
+                                                arcSelectUnits(spp,"[red]\uE80F","低血量单位", unit -> unit.health < unit.maxHealth * wound);
+                                            });
+                                        }
+
+                                        if (control.input.selectedUnits.contains(unit -> unit.type.commands.length > 1) && control.input.selectedUnits.contains(unit -> unit.type.commands.length <= 1)){
+                                            sp.table(spp->{
+                                                arcSelectUnits(spp,"\uE86E","进攻性单位", unit -> unit.type.commands.length <= 1);
+                                                arcSelectUnits(spp,"\uE86B","辅助性单位", unit -> unit.type.commands.length > 1);
+                                            });
+                                        }
+
+                                        int hasFlyer = control.input.selectedUnits.contains(unit -> unit.isFlying()) ? 1 : 0;
+                                        int hasLand = control.input.selectedUnits.contains(unit -> !unit.isFlying() && !unit.type.naval) ? 1 : 0;
+                                        int hasNaval = control.input.selectedUnits.contains(unit -> unit.type.naval) ? 1 : 0;
+                                        if (hasFlyer + hasLand + hasNaval >=2 ){
+                                            sp.table(spp->{
+                                                if (hasFlyer == 1) arcSelectUnits(spp,UnitTypes.flare.emoji(),"飞行单位", unit -> unit.isFlying());
+                                                if (hasLand == 1) arcSelectUnits(spp,UnitTypes.crawler.emoji(),"陆军单位", unit -> !unit.isFlying() && !unit.type.naval);
+                                                if (hasNaval == 1) arcSelectUnits(spp,UnitTypes.retusa.emoji(),"海军单位", unit -> unit.type.naval);
+                                            });
                                         }
                                     }).fillX().padTop(4f).left();
                                 }
                             }else{
                                 u.add(Core.bundle.get("commandmode.nounits")).color(Color.lightGray).growX().center().labelAlign(Align.center).pad(6);
                             }
+                            if(arcExtra && mobile){
+                                u.row();
+                                u.table(sp->{
+                                    sp.button("\uE86D", Styles.cleart, () -> {
+                                        control.input.selectedUnits.clear();
+                                        control.input.commandBuildings.clear();
+                                        for(var unit : player.team().data().units){
+                                            if(unit.isCommandable()){
+                                                control.input.selectedUnits.add(unit);
+                                            }
+                                        }
+                                    }).size(40f);
+                                    sp.button(Blocks.additiveReconstructor.emoji(), Styles.cleart, () -> {
+                                        control.input.selectedUnits.clear();
+                                        control.input.commandBuildings.clear();
+                                        for(var build : player.team().data().buildings){
+                                            if(build.block.commandable){
+                                                control.input.commandBuildings.add(build);
+                                            }
+                                        }
+                                    }).size(40f);
+                                }).fillX().padTop(4f).left().row();
+                            }
                         };
 
                         u.update(() -> {
@@ -613,7 +723,7 @@ public class PlacementFragment{
                 {
                     blockCatTable.table(Tex.pane2, blocksSelect -> {
                         blocksSelect.margin(4).marginTop(0);
-                        blockPane = blocksSelect.pane(blocks -> blockTable = blocks).height(194f).update(pane -> {
+                        blockPane = blocksSelect.pane(blocks -> blockTable = blocks).height(maxRow * 46f + 10f).update(pane -> {
                             if(pane.hasScroll()){
                                 Element result = Core.scene.hit(Core.input.mouseX(), Core.input.mouseY(), true);
                                 if(result == null || !result.isDescendantOf(pane)){
@@ -647,6 +757,17 @@ public class PlacementFragment{
                         boolean needsAssign = categoryEmpty[currentCategory.ordinal()];
 
                         int f = 0;
+                        if (maxRow > 5){
+                            categories.button(Icon.zoom, Styles.clearTogglei, () -> {
+                                new BlockSelectDialog(block -> block.replaceable, block -> {
+                                    control.input.block = block;
+                                    currentCategory = block.category;
+                                    rebuildCategory.run();
+                                    }, block -> control.input.block == block).show();
+                            }).group(group);
+                            categories.image(Styles.black6);
+                            categories.row();
+                        }
                         for(Category cat : getCategories()){
                             if(f++ % 2 == 0) categories.row();
 
@@ -692,7 +813,7 @@ public class PlacementFragment{
     }
 
     Seq<Block> getUnlockedByCategory(Category cat){
-        return returnArray2.selectFrom(content.blocks(), block -> block.category == cat && block.isVisible() && unlocked(block)).sort((b1, b2) -> Boolean.compare(!b1.isPlaceable(), !b2.isPlaceable()));
+        return returnArray2.selectFrom(content.blocks(), block -> block.category == cat &&(AdvanceToolTable.allBlocksReveal||block.isVisible() && unlocked(block)) ).sort((b1, b2) -> Boolean.compare(!b1.isPlaceable(), !b2.isPlaceable()));
     }
 
     Block getSelectedBlock(Category cat){
@@ -706,7 +827,9 @@ public class PlacementFragment{
 
     boolean hasInfoBox(){
         hover = hovered();
-        return control.input.block != null || menuHoverBlock != null || hover != null;
+        hover2 = hoveredblock();
+        hoverTile = hoveredTile();
+        return control.input.block != null || menuHoverBlock != null || hover != null || hoverTile != null;
     }
 
     /** Returns the thing being hovered over. */
@@ -718,24 +841,75 @@ public class PlacementFragment{
         if(Core.scene.hasMouse() || topTable.hit(v.x, v.y, false) != null) return null;
 
         //check for a unit
-        Unit unit = Units.closestOverlap(player.team(), Core.input.mouseWorldX(), Core.input.mouseWorldY(), 5f, u -> !u.isLocal() && u.displayable());
+        Unit unit = Units.closestOverlap(player.team(), Core.input.mouseWorldX(), Core.input.mouseWorldY(), 5f, u -> true);
         //if cursor has a unit, display it
         if(unit != null) return unit;
-
+        unit = Units.closestEnemy(player.team(), Core.input.mouseWorldX(), Core.input.mouseWorldY(), 5f, u -> true);
+        if(unit != null) return unit;
         //check tile being hovered over
         Tile hoverTile = world.tileWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
         if(hoverTile != null){
             //if the tile has a building, display it
-            if(hoverTile.build != null && hoverTile.build.displayable() && !hoverTile.build.inFogTo(player.team())){
+            if(hoverTile.build != null && hoverTile.build.displayable()  && !hoverTile.build.inFogTo(player.team())){
                 return nextFlowBuild = hoverTile.build;
             }
+        }
+
+        return null;
+
+
+    }
+    @Nullable
+    Displayable hoveredblock(){
+        Vec2 v = topTable.stageToLocalCoordinates(Core.input.mouse());
+
+        //if the mouse intersects the table or the UI has the mouse, no hovering can occur
+        if(Core.scene.hasMouse() || topTable.hit(v.x, v.y, false) != null) return null;
 
-            //if the tile has a drop, display the drop
-            if((hoverTile.drop() != null && hoverTile.block() == Blocks.air) || hoverTile.wallDrop() != null || hoverTile.floor().liquidDrop != null){
-                return hoverTile;
+        //check tile being hovered over
+        Tile hoverTile = world.tileWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
+        if(hoverTile != null){
+            //if the tile has a building, display it
+            if(hoverTile.build != null && hoverTile.build.displayable() && !hoverTile.build.inFogTo(player.team())){
+                return nextFlowBuild = hoverTile.build;
             }
         }
 
         return null;
     }
+
+    @Nullable
+    Tile hoveredTile(){
+        Vec2 v = topTable.stageToLocalCoordinates(Core.input.mouse());
+
+        //if the mouse intersects the table or the UI has the mouse, no hovering can occur
+        if(Core.scene.hasMouse() || topTable.hit(v.x, v.y, false) != null) return null;
+
+        //check tile being hovered over
+        Tile hoverTile = world.tileWorld(Core.input.mouseWorld().x, Core.input.mouseWorld().y);
+        if(hoverTile != null && !(hoverTile.build!=null && hoverTile.build.inFogTo(player.team()))) return hoverTile;
+        return null;
+    }
+
+    void arcSelectUnits(Table table, String icon, String info, Boolf<Unit> cons){
+        float size = 40f;
+
+        table.button(icon, Styles.cleart, () -> {}).tooltip(info).size(size).with(b->{
+            var listener = new ClickListener();
+            b.clicked(KeyCode.mouseLeft, () -> {
+                control.input.selectedUnits = control.input.selectedUnits.select(cons::get);
+                Events.fire(Trigger.unitCommandChange);
+                UIExt.announce("[cyan]arc控制器\n[acid]选择" + info + "！");
+            });
+            //right click -> remove
+            b.clicked(KeyCode.mouseRight, () -> {
+                control.input.selectedUnits.removeAll(cons::get);
+                Events.fire(Trigger.unitCommandChange);
+                UIExt.announce("[cyan]arc控制器\n[orange]移除" + info + "！");
+            });
+
+            b.addListener(listener);
+            b.addListener(new HandCursorListener());
+        });
+    }
 }
diff --git a/core/src/mindustry/ui/fragments/PlayerListFragment.java b/core/src/mindustry/ui/fragments/PlayerListFragment.java
index 9286aab19502b5cf40556311572157b20c60fef4..1165df86591dea2b418802c309a55c2bc7a6bfef 100644
--- a/core/src/mindustry/ui/fragments/PlayerListFragment.java
+++ b/core/src/mindustry/ui/fragments/PlayerListFragment.java
@@ -10,23 +10,29 @@ import arc.scene.ui.ImageButton.*;
 import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
-import mindustry.game.*;
+import mindustry.game.Team;
+import mindustry.input.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
-import mindustry.input.*;
 import mindustry.net.*;
 import mindustry.net.Packets.*;
 import mindustry.ui.*;
 import mindustry.ui.dialogs.*;
+import mindustryX.features.*;
+import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
+import static mindustry.input.InputHandler.follow;
 
 public class PlayerListFragment{
     public Table content = new Table().marginRight(13f).marginLeft(13f);
     private boolean visible = false;
     private Interval timer = new Interval();
     private TextField search;
-    private Seq<Player> players = new Seq<>();
+    public Seq<Player> players = new Seq<>();
+
+    private float buttonSize = 30f;
+    private boolean teamMode = false;
 
     public void build(Group parent){
         content.name = "players";
@@ -63,23 +69,23 @@ public class PlayerListFragment{
                     menu.defaults().growX().height(50f).fillY();
                     menu.name = "menu";
 
+                    if (Core.settings.getBool("arcPlayerList") && Core.settings.getBool("easyJS")) menu.button("js换队",() -> teamMode = !teamMode).checked(t->teamMode);
                     menu.button("@server.bans", ui.bans::show).disabled(b -> net.client());
                     menu.button("@server.admins", ui.admins::show).disabled(b -> net.client());
                     menu.button("@close", this::toggle);
                 }).margin(0f).pad(10f).growX();
 
-            }).touchable(Touchable.enabled).margin(14f).minWidth(360f);
+            }).touchable(Touchable.enabled).margin(14f).minWidth(720f);
         });
 
         rebuild();
     }
 
     public void rebuild(){
-        boolean allowTeamSwitch = !state.isCampaign() && (state.rules.pvp || state.rules.infiniteResources);
-
         content.clear();
 
-        float h = 50f;
+        float h = 40f;
+        float bs = (h) - 2f;
         boolean found = false;
 
         players.clear();
@@ -95,6 +101,7 @@ public class PlayerListFragment{
             NetConnection connection = user.con;
 
             if(connection == null && net.server() && !user.isLocal()) return;
+            if(search.getText().length() > 0 && !user.name().toLowerCase().contains(search.getText().toLowerCase()) && !Strings.stripColors(user.name().toLowerCase()).contains(search.getText().toLowerCase())) return;
 
             Table button = new Table();
             button.left();
@@ -121,28 +128,16 @@ public class PlayerListFragment{
                 iconTable.addListener(new HandCursorListener());
             }
             iconTable.margin(8);
-            iconTable.add(new Image(user.icon()).setScaling(Scaling.bounded)).grow();
             iconTable.name = user.name();
             iconTable.touchable = Touchable.enabled;
 
             iconTable.tapped(() -> {
                 if(!user.dead() && clickable){
-                    Core.camera.position.set(user.unit());
                     ui.showInfoFade(Core.bundle.format("viewplayer", user.name), 1f);
-                    if(control.input instanceof DesktopInput input){
-                        input.panning = true;
-                    }
+                    control.input.panCamera(Tmp.v1.set(user.unit()));
                 }
             });
 
-            button.add(iconTable).size(h);
-            button.labelWrap("[#" + user.color().toString().toUpperCase() + "]" + user.name()).style(Styles.outlineLabel).width(170f).pad(10);
-            button.add().grow();
-
-            button.background(Tex.underline);
-
-            button.image(Icon.admin).visible(() -> user.admin && !(!user.isLocal() && net.server())).padRight(5).get().updateVisibility();
-
             var ustyle = new ImageButtonStyle(){{
                 down = Styles.none;
                 up = Styles.none;
@@ -151,10 +146,105 @@ public class PlayerListFragment{
                 imageOverColor = Color.lightGray;
             }};
 
-            if(net.server() || (player.admin && (!user.admin || user == player))){
-                button.add().growY();
+            iconTable.margin(4);
+            iconTable.add(new Image(user.icon()).setScaling(Scaling.bounded)).grow();
+            iconTable.name = user.name();
+
+            if (Core.settings.getBool("arcPlayerList")){
+                button.add(iconTable).size(h);
+                button.image(Icon.admin).visible(() -> user.admin && !(!user.isLocal() && net.server())).size(bs).get().updateVisibility();
+                button.table(
+                    t -> {
+                        t.labelWrap("[#" + user.color().toString().toUpperCase() + "]" + user.name()).minWidth(380f);
+                        t.touchable = Touchable.enabled;
+                        t.tapped(()->{
+                            Core.app.setClipboardText(user.name);
+                            UIExt.announce("复制昵称：" + user.name);
+                        });
+                    }
+                ).width(400f).pad(10f).left();
+
+                button.add().grow();
+
+                button.button("♐", Styles.cleart, () -> {
+                    ArcMessageDialog.share("AT", "戳了" + user.name + "[white]一下，并提醒你留意对话框");
+                }).color(Pal.accent).size(buttonSize);
+
+                button.button(String.valueOf(Iconc.lock), Styles.cleart, () -> {
+                    if(follow != user){
+                        follow = user;
+                    }else {
+                        follow = null;
+                    }
+                    if(control.input instanceof DesktopInput){
+                        ((DesktopInput) control.input).panning = follow == user;
+                        UIExt.announce("追踪玩家：" + user.name);
+                    }
+                }).checked(b -> {
+                    boolean checked = follow == user;
+                    b.setText(checked ? String.valueOf(Iconc.lock) : String.valueOf(Iconc.lockOpen));
+                    return checked;
+                }).size(buttonSize);
+
+                button.button("[coral]" + Iconc.planeOutline, Styles.cleart,
+                () -> {
+                    ui.showConfirm("@confirm", Core.bundle.format("confirmvotekick",  user.name()), () -> {
+                        Call.sendChatMessage("/votekick " + user.name());
+                    });
+                }).size(buttonSize);
+
+                if((net.server() || player.admin) && !user.isLocal() && (!user.admin || net.server())){
+                    button.button("[gold]" + Iconc.zoom, Styles.cleart, () -> Call.adminRequest(user, AdminAction.trace, null)).size(buttonSize);
+                    button.button("[gold]" + Iconc.cancel, Styles.cleart,
+                            () -> ui.showConfirm("@confirm", Core.bundle.format("confirmkick",  user.name()), () -> Call.adminRequest(user, AdminAction.kick, null))).size(buttonSize);
+                    button.button("[gold]" + Iconc.hammer, Styles.cleart,
+                            () -> ui.showConfirm("@confirm", Core.bundle.format("confirmban",  user.name()), () -> Call.adminRequest(user, AdminAction.ban, null))).size(buttonSize);
+                }
+                if (teamMode) {
+                    if (state.teams.getActive().size <= 5){
+                        state.teams.getActive().each(teamData -> button.button("[#" + teamData.team.color + "]" + teamData.team.localized(), Styles.cleart,
+                                () -> Call.sendChatMessage("/js Groups.player.find(e=>e.name== \"" + user.name + "\").team(Team.get(" + teamData.team.id + "))")).size(buttonSize));
+                    }
+                    button.button("[violet]+", Styles.cleart, () -> UIExt.teamSelect.pickOne(team ->
+                    Call.sendChatMessage("/js Groups.player.find(e=>e.name== \"" + user.name + "\").team(Team.get(" + team.id + "))"), user.team())).size(buttonSize);
+                } else if (net.server() || (player.admin && (!user.admin || user == player))) {
+                    if (state.teams.getActive().size <= 5){
+                        state.teams.getActive().each(teamData -> button.button("[#" + teamData.team.color + "]" + teamData.team.localized(), Styles.cleart,
+                                () -> Call.adminRequest(user, AdminAction.switchTeam, teamData.team)).size(buttonSize));
+                    }
+                    button.button("[violet]+",Styles.cleart,()-> UIExt.teamSelect.pickOne(team -> Call.adminRequest(user, AdminAction.switchTeam, team), user.team())).size(buttonSize);
+                }
+                if((net.server() || (player.admin && (!user.admin || user == player))) && !net.client() && !user.isLocal()){
+                    button.button("" + Iconc.admin,Styles.cleart, () -> {
+                        String id = user.uuid();
+
+                        if(user.admin){
+                            ui.showConfirm("@confirm", Core.bundle.format("confirmunadmin",  user.name()), () -> {
+                                netServer.admins.unAdminPlayer(id);
+                                user.admin = false;
+                            });
+                        }else{
+                            ui.showConfirm("@confirm", Core.bundle.format("confirmadmin",  user.name()), () -> {
+                                netServer.admins.adminPlayer(id, user.usid());
+                                user.admin = true;
+                            });
+                        }
+                    }).checked(b -> user.admin).row();
+                }
+            }
+            //原版模式
+            else {
+                button.add(iconTable).size(h);
+                button.labelWrap("[#" + user.color().toString().toUpperCase() + "]" + user.name()).style(Styles.outlineLabel).width(170f).pad(10);
+                button.add().grow();
+
+                button.background(Tex.underline);
+
+                button.image(Icon.admin).visible(() -> user.admin && !(!user.isLocal() && net.server())).padRight(5).get().updateVisibility();
+
+                if(net.server() || (player.admin && (!user.admin || user == player))){
+                    button.add().growY();
 
-                if(allowTeamSwitch || user != player){
                     button.button(Icon.menu, ustyle, () -> {
                         var dialog = new BaseDialog(user.coloredName());
 
@@ -181,43 +271,42 @@ public class PlayerListFragment{
                                     ui.showConfirm("@confirm", Core.bundle.format("confirmkick",  user.name()), () -> Call.adminRequest(user, AdminAction.kick, null));
                                     dialog.hide();
                                 }).row();
+                            }
 
+                            if(!user.isLocal()){
                                 t.button("@player.trace", Icon.zoom, bstyle, () -> {
                                     Call.adminRequest(user, AdminAction.trace, null);
                                     dialog.hide();
                                 }).row();
                             }
 
-                            //there's generally no reason to team switch outside PvP or sandbox, and it's basically an easy way to cheat
-                            if(allowTeamSwitch){
-                                t.button("@player.team", Icon.redo, bstyle, () -> {
-                                    var teamSelect = new BaseDialog(Core.bundle.get("player.team") + ": " + user.name);
-                                    teamSelect.setFillParent(false);
+                            t.button("@player.team", Icon.redo, bstyle, () -> {
+                                var teamSelect = new BaseDialog(Core.bundle.get("player.team") + ": " + user.name);
+                                teamSelect.setFillParent(false);
 
-                                    var group = new ButtonGroup<>();
+                                var group = new ButtonGroup<>();
 
-                                    int i = 0;
+                                int i = 0;
 
-                                    for(Team team : Team.baseTeams){
-                                        var b = new ImageButton(Tex.whiteui, Styles.clearNoneTogglei);
-                                        b.margin(4f);
-                                        b.getImageCell().grow();
-                                        b.getStyle().imageUpColor = team.color;
-                                        b.clicked(() -> {
-                                            Call.adminRequest(user, AdminAction.switchTeam, team);
-                                            teamSelect.hide();
-                                        });
-                                        teamSelect.cont.add(b).size(50f).checked(a -> user.team() == team).group(group);
+                                for(Team team : Team.baseTeams){
+                                    var b = new ImageButton(Tex.whiteui, Styles.clearNoneTogglei);
+                                    b.margin(4f);
+                                    b.getImageCell().grow();
+                                    b.getStyle().imageUpColor = team.color;
+                                    b.clicked(() -> {
+                                        Call.adminRequest(user, AdminAction.switchTeam, team);
+                                        teamSelect.hide();
+                                    });
+                                    teamSelect.cont.add(b).size(50f).checked(a -> user.team() == team).group(group);
 
-                                        if(i++ % 3 == 2) teamSelect.cont.row();
-                                    }
+                                    if(i++ % 3 == 2) teamSelect.cont.row();
+                                }
 
-                                    teamSelect.addCloseButton();
-                                    teamSelect.show();
+                                teamSelect.addCloseButton();
+                                teamSelect.show();
 
-                                    dialog.hide();
-                                }).row();
-                            }
+                                dialog.hide();
+                            }).row();
 
                             if(!net.client() && !user.isLocal()){
                                 t.button("@player.admin", Icon.admin, Styles.togglet, () -> {
@@ -242,20 +331,21 @@ public class PlayerListFragment{
                         dialog.cont.button("@back", Icon.left, dialog::hide).padTop(-1f).size(220f, 55f);
 
                         dialog.show();
+                    }).size(h);
 
+                }else if(!user.isLocal() && !user.admin && net.client() && Groups.player.size() >= 3 && player.team() == user.team()){ //votekick
+                    button.add().growY();
 
-                    }).size(h);
+                    button.button(Icon.hammer, ustyle,
+                        () -> ui.showTextInput("@votekick.reason", Core.bundle.format("votekick.reason.message", user.name()), "",
+                        reason -> Call.sendChatMessage("/votekick #" + user.id + " " + reason)))
+                    .size(h);
                 }
-            }else if(!user.isLocal() && !user.admin && net.client() && Groups.player.size() >= 3 && player.team() == user.team()){ //votekick
-                button.add().growY();
 
-                button.button(Icon.hammer, ustyle,
-                    () -> ui.showTextInput("@votekick.reason", Core.bundle.format("votekick.reason.message", user.name()), "",
-                    reason -> Call.sendChatMessage("/votekick #" + user.id + " " + reason)))
-                .size(h);
             }
-
-            content.add(button).width(350f).height(h + 14);
+            content.add(button).padBottom(-6).width(700f).maxHeight(h + 14);
+            content.row();
+            content.image().height(4f).color(state.rules.pvp|| Core.settings.getBool("arcAlwaysTeamColor") ? user.team().color : Pal.gray).growX();
             content.row();
         }
 
diff --git a/core/src/mindustry/world/Block.java b/core/src/mindustry/world/Block.java
index 01098e5f4564f3e1e7491d34cbbca1a525592c16..cb3874a23f5c4c612af25d78728032fc0a625695 100644
--- a/core/src/mindustry/world/Block.java
+++ b/core/src/mindustry/world/Block.java
@@ -368,7 +368,7 @@ public class Block extends UnlockableContent implements Senseable{
     /** Map of bars by name. */
     protected OrderedMap<String, Func<Building, Bar>> barMap = new OrderedMap<>();
     /** List for building up consumption before init(). */
-    protected Seq<Consume> consumeBuilder = new Seq<>();
+    public Seq<Consume> consumeBuilder = new Seq<>();
 
     protected TextureRegion[] generatedIcons;
     protected TextureRegion[] editorVariantRegions;
@@ -490,6 +490,11 @@ public class Block extends UnlockableContent implements Senseable{
             .sumf(other -> !floating && other.floor().isDeep() ? 0 : other.floor().attributes.get(attr));
     }
 
+    public float sumAttribute(@Nullable Attribute attr, Tile tile){
+        if(attr == null) return 0;
+        return tile.getLinkedTilesAs(this, tempTiles)
+                .sumf(other -> !floating && other.floor().isDeep() ? 0 : other.floor().attributes.get(attr));
+    }
     public TextureRegion getDisplayIcon(Tile tile){
         return tile.build == null ? uiIcon : tile.build.getDisplayIcon();
     }
@@ -546,7 +551,7 @@ public class Block extends UnlockableContent implements Senseable{
             }
         }
 
-        if(requirements.length > 0){
+        if(canBeBuilt() && requirements.length > 0){
             stats.add(Stat.buildTime, buildCost / 60, StatUnit.seconds);
             stats.add(Stat.buildCost, StatValues.items(false, requirements));
         }
@@ -720,7 +725,12 @@ public class Block extends UnlockableContent implements Senseable{
 
     public void drawPlan(BuildPlan plan, Eachable<BuildPlan> list, boolean valid, float alpha){
         Draw.reset();
-        Draw.mixcol(!valid ? Pal.breakInvalid : Color.white, (!valid ? 0.4f : 0.24f) + Mathf.absin(Time.globalTime, 6f, 0.28f));
+        if (!valid)  Draw.mixcol(Pal.breakInvalid, 0.4f + Mathf.absin(Time.globalTime, 6f, 0.28f));
+        else {
+            if (player.unit().within(plan.x * tilesize,plan.y * tilesize,player.unit().type.buildRange))
+                Draw.mixcol(Color.white, 0.24f + Mathf.absin(Time.globalTime, 6f, 0.28f));
+            else Draw.mixcol(Color.valueOf("#FFE4B5"), 0.33f + Mathf.absin(Time.globalTime, 6f, 0.28f));
+        }
         Draw.alpha(alpha);
         float prevScale = Draw.scl;
         Draw.scl *= plan.animScale;
@@ -907,7 +917,7 @@ public class Block extends UnlockableContent implements Senseable{
     }
 
     public boolean isPlaceable(){
-        return isVisible() && (!state.rules.isBanned(this) || state.rules.editor) && supportsEnv(state.rules.env);
+        return AdvanceToolTable.allBlocksReveal || isVisible() && (!state.rules.isBanned(this) || state.rules.editor) && supportsEnv(state.rules.env);
     }
 
     /** @return whether this block supports a specific environment. */
diff --git a/core/src/mindustry/world/Build.java b/core/src/mindustry/world/Build.java
index a47363df2f463338875a2937dfeffdd0411d492a..03fd8c4d74637c02a3a12353ec35e8c044ee779f 100644
--- a/core/src/mindustry/world/Build.java
+++ b/core/src/mindustry/world/Build.java
@@ -14,7 +14,10 @@ import mindustry.game.Teams.*;
 import mindustry.gen.*;
 import mindustry.world.blocks.*;
 import mindustry.world.blocks.ConstructBlock.*;
+import mindustry.world.blocks.environment.Floor;
+import mindustry.world.blocks.environment.OverlayFloor;
 import mindustry.world.blocks.storage.CoreBlock.*;
+import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
 
@@ -73,6 +76,36 @@ public class Build{
             return;
         }
 
+        if(AdvanceToolTable.worldCreator){
+            Tile tile = world.tile(x, y);
+            if(tile == null) return;
+            if(result == Blocks.cliff) {
+                int rotationb = 0;
+                for(int i = 0; i < 8; i++){
+                    Tile other = world.tiles.get(tile.x + Geometry.d8[i].x, tile.y + Geometry.d8[i].y);
+                    if(other != null && !other.floor().hasSurface()){
+                        rotationb |= (1 << i);
+                    }
+                }
+
+                if(rotationb != 0){
+                    tile.setBlock(Blocks.cliff);
+                }
+
+                tile.data = (byte)rotationb;
+                return;
+            };
+            if(result instanceof OverlayFloor){
+                tile.setOverlay(result);
+                return;
+            }
+            if(result instanceof Floor floor){
+                tile.setFloor(floor);
+                pathfinder.updateTile(tile);
+                return;
+            }
+        }
+
         Tile tile = world.tile(x, y);
 
         //just in case
@@ -165,6 +198,22 @@ public class Build{
     /** Returns whether a tile can be placed at this location by this team. */
     public static boolean validPlace(Block type, Team team, int x, int y, int rotation, boolean checkVisible){
         //the wave team can build whatever they want as long as it's visible - banned blocks are not applicable
+
+        if(AdvanceToolTable.forcePlacement){
+            Tile tile = world.tile(x, y);
+            return tile != null;
+        }
+
+        if (AdvanceToolTable.worldCreator) {
+            Tile tile = world.tile(x, y);
+            if (tile == null) return false;
+            if (type instanceof OverlayFloor of) {
+                return !(tile.overlay == of);
+            }
+            if (type instanceof Floor f) {
+                return !(tile.floor == f);
+            }
+        }
         if(type == null || (checkVisible && (!type.environmentBuildable() || (!type.isPlaceable() && !(state.rules.waves && team == state.rules.waveTeam && type.isVisible()))))){
             return false;
         }
@@ -294,6 +343,7 @@ public class Build{
     /** @return whether the tile at this position is breakable by this team */
     public static boolean validBreak(Team team, int x, int y){
         Tile tile = world.tile(x, y);
+        if(AdvanceToolTable.worldCreator && tile.block() != Blocks.air) return true;
         return tile != null && tile.block() != Blocks.air && (tile.block().canBreak(tile) && (tile.breakable() || state.rules.allowEnvironmentDeconstruct)) && tile.interactable(team);
     }
 }
diff --git a/core/src/mindustry/world/blocks/ConstructBlock.java b/core/src/mindustry/world/blocks/ConstructBlock.java
index f45822964a30770bc15e4865429ef7749b4ce620..61425f62a03c91b5a6bc88d18a35de566bb2cb5e 100644
--- a/core/src/mindustry/world/blocks/ConstructBlock.java
+++ b/core/src/mindustry/world/blocks/ConstructBlock.java
@@ -3,14 +3,17 @@ package mindustry.world.blocks;
 import arc.*;
 import arc.Graphics.*;
 import arc.Graphics.Cursor.*;
+import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
+import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
 import arc.util.io.*;
 import mindustry.*;
 import mindustry.annotations.Annotations.*;
 import mindustry.content.*;
+import mindustry.core.*;
 import mindustry.entities.*;
 import mindustry.entities.units.*;
 import mindustry.game.EventType.*;
@@ -23,6 +26,7 @@ import mindustry.world.*;
 import mindustry.world.blocks.environment.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
 import mindustry.world.modules.*;
+import mindustryX.features.func.*;
 
 import java.util.*;
 
@@ -125,7 +129,7 @@ public class ConstructBlock extends Block{
     static float calcPitch(boolean up){
         if(Time.timeSinceMillis(lastTime) < 16 * 30){
             lastTime = Time.millis();
-            pitchSeq ++;
+            pitchSeq++;
             if(pitchSeq > 30){
                 pitchSeq = 0;
             }
@@ -168,6 +172,40 @@ public class ConstructBlock extends Block{
         private @Nullable float[] totalAccumulator;
         private @Nullable int[] itemsLeft;
 
+        @Override
+        public void drawSelect(){
+            if(team.core() == null){
+                return;
+            }
+
+            // BlockUnit之上
+            Draw.z(Layer.flyingUnit + 0.1f);
+
+            float scl = block.size / 4f;
+            float buildHitSize = hitSize();
+
+            // 显示建造进度
+            var pos = Tmp.v1.set(this).add(0, buildHitSize / 2f);//顶部
+            FuncX.drawText(pos, Strings.fixed(progress * 100, 2) + "%", scl, Pal.accent, Align.bottom);
+
+            // 显示物品需求
+            StringBuilder requirements = new StringBuilder();
+            for(int i = 0; i < current.requirements.length; i++){
+                ItemStack stack = current.requirements[i];
+                float consumeAmount = state.rules.buildCostMultiplier * stack.amount;
+                int coreAmount = team.core().items.get(stack.item);
+
+                int investItem = (int)(progress * consumeAmount);
+                int needItem = (int)(consumeAmount) - investItem;
+                boolean hasItem = coreAmount >= needItem;
+
+                if(i != 0) requirements.append('\n');
+                requirements.append(stack.item.emoji()).append(hasItem ? "[#ffd37f]" : "[#e55454]").append(investItem).append("/").append(needItem).append("/").append(UI.formatAmount(coreAmount)).append("[]");
+            }
+            pos.set(this).add(-buildHitSize / 2f, -buildHitSize / 2f);//左下角
+            FuncX.drawText(pos, requirements.toString(), scl, Color.white, Align.bottomLeft);
+        }
+
         @Override
         public String getDisplayName(){
             return Core.bundle.format("block.constructing", current.localizedName);
@@ -246,7 +284,7 @@ public class ConstructBlock extends Block{
 
                     Draw.rect(region, x, y, current.rotate && (noOverrides || current.regionRotated2 == i || current.regionRotated1 == i) ? rotdeg() : 0);
                     Draw.flush();
-                    i ++;
+                    i++;
                 }
 
                 Draw.color();
diff --git a/core/src/mindustry/world/blocks/ItemSelection.java b/core/src/mindustry/world/blocks/ItemSelection.java
index 483ba2813465888e23bbc60bd5bada94d237897c..930cc3cd4585ccaf969f57a59607be5372278e3a 100644
--- a/core/src/mindustry/world/blocks/ItemSelection.java
+++ b/core/src/mindustry/world/blocks/ItemSelection.java
@@ -12,6 +12,7 @@ import mindustry.gen.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.*;
+import mindustryX.features.ui.*;
 
 import static mindustry.Vars.*;
 
@@ -65,7 +66,7 @@ public class ItemSelection{
 
             Seq<T> list = items.select(u -> (text.isEmpty() || u.localizedName.toLowerCase().contains(text.toLowerCase())));
             for(T item : list){
-                if(!item.unlockedNow() || (item instanceof Item checkVisible && state.rules.hiddenBuildItems.contains(checkVisible)) || item.isHidden()) continue;
+                if(!AdvanceToolTable.allBlocksReveal && (!item.unlockedNow() || (item instanceof Item checkVisible && state.rules.hiddenBuildItems.contains(checkVisible)) || item.isHidden())) continue;
 
                 ImageButton button = cont.button(Tex.whiteui, Styles.clearNoneTogglei, Mathf.clamp(item.selectionSize, 0f, 40f), () -> {
                     if(closeSelect) control.input.config.hideConfig();
diff --git a/core/src/mindustry/world/blocks/defense/ForceProjector.java b/core/src/mindustry/world/blocks/defense/ForceProjector.java
index 5cc4088121fd85ccb4971465494b2f00ee59a878..b60cb85af6bba587c027b93c2affa527d6d32334 100644
--- a/core/src/mindustry/world/blocks/defense/ForceProjector.java
+++ b/core/src/mindustry/world/blocks/defense/ForceProjector.java
@@ -1,6 +1,7 @@
 package mindustry.world.blocks.defense;
 
 import arc.*;
+import arc.Core;
 import arc.func.*;
 import arc.graphics.*;
 import arc.graphics.g2d.*;
@@ -124,6 +125,9 @@ public class ForceProjector extends Block{
         Draw.color(player.team().color);
         Lines.stroke(1f);
         Lines.poly(x * tilesize + offset, y * tilesize + offset, sides, radius, shieldRotation);
+        Draw.color(player.team().color);
+        Lines.stroke(1f);
+        Lines.poly(x * tilesize + offset, y * tilesize + offset, sides, radius+phaseRadiusBoost, shieldRotation);
         Draw.color();
     }
 
diff --git a/core/src/mindustry/world/blocks/defense/MendProjector.java b/core/src/mindustry/world/blocks/defense/MendProjector.java
index f52a5307bdd8c79fbccb82b7ff74dc856d615edb..e4016bff4dc6ba33e9debe56dc871c622527c03d 100644
--- a/core/src/mindustry/world/blocks/defense/MendProjector.java
+++ b/core/src/mindustry/world/blocks/defense/MendProjector.java
@@ -1,5 +1,6 @@
 package mindustry.world.blocks.defense;
 
+import arc.*;
 import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
@@ -21,7 +22,7 @@ import static mindustry.Vars.*;
 public class MendProjector extends Block{
     public final int timerUse = timers++;
     public Color baseColor = Color.valueOf("84f491");
-    public Color phaseColor = baseColor;
+    public Color phaseColor = Color.valueOf("ffd59e");
     public @Load("@-top") TextureRegion topRegion;
     public float reload = 250f;
     public float range = 60f;
@@ -80,6 +81,10 @@ public class MendProjector extends Block{
         
         Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range, baseColor);
 
+        indexer.eachBlock(player.team(), x * tilesize + offset, y * tilesize + offset, range + phaseRangeBoost, other -> true, other -> Drawf.selected(other, Tmp.c1.set(phaseColor).a(Mathf.absin(4f, 1f))));
+
+        Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range + phaseRangeBoost, phaseColor);
+
         indexer.eachBlock(player.team(), x * tilesize + offset, y * tilesize + offset, range, other -> true, other -> Drawf.selected(other, Tmp.c1.set(baseColor).a(Mathf.absin(4f, 1f))));
     }
 
@@ -136,6 +141,15 @@ public class MendProjector extends Block{
         public void draw(){
             super.draw();
 
+            float realRange = range + phaseHeat * phaseRangeBoost;
+            if(status() == BlockStatus.active && (float)Core.settings.getInt("mend_zone") > 2f){
+                if (phaseHeat>0.2){Draw.color(Color.valueOf("00ff55"), (float)Core.settings.getInt("mend_zone") / 100f);}
+                else {Draw.color(Color.valueOf("66ff99"),(float)Core.settings.getInt("mend_zone") / 100f);}
+
+                Lines.dashCircle(x, y, realRange);
+            }
+
+
             float f = 1f - (Time.time / 100f) % 1f;
 
             Draw.color(baseColor, phaseColor, phaseHeat);
diff --git a/core/src/mindustry/world/blocks/defense/OverdriveProjector.java b/core/src/mindustry/world/blocks/defense/OverdriveProjector.java
index 11cd57fb65dcac2eb118cd7d584dd83be20b7c0f..f47ac3f5ecb8f64caf2d1a50910a60fa7cf8c98a 100644
--- a/core/src/mindustry/world/blocks/defense/OverdriveProjector.java
+++ b/core/src/mindustry/world/blocks/defense/OverdriveProjector.java
@@ -1,6 +1,5 @@
 package mindustry.world.blocks.defense;
 
-import arc.*;
 import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
@@ -57,6 +56,12 @@ public class OverdriveProjector extends Block{
         super.drawPlace(x, y, rotation, valid);
 
         Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range, baseColor);
+        if (hasBoost){
+            Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range + phaseRangeBoost, phaseColor);
+
+            indexer.eachBlock(player.team(), x * tilesize + offset, y * tilesize + offset, range + phaseRangeBoost, other -> other.block.canOverdrive, other -> Drawf.selected(other, Tmp.c1.set(phaseColor).a(Mathf.absin(4f, 1f))));
+        }
+
 
         indexer.eachBlock(player.team(), x * tilesize + offset, y * tilesize + offset, range, other -> other.block.canOverdrive, other -> Drawf.selected(other, Tmp.c1.set(baseColor).a(Mathf.absin(4f, 1f))));
     }
diff --git a/core/src/mindustry/world/blocks/defense/turrets/BaseTurret.java b/core/src/mindustry/world/blocks/defense/turrets/BaseTurret.java
index eced3dc7581a4916970634e600d0f5cd86f6ee7e..58e315a6d9ec8c4c32df8a8220a9ccbb564e862d 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/BaseTurret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/BaseTurret.java
@@ -14,6 +14,7 @@ import mindustry.world.*;
 import mindustry.world.blocks.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import static mindustry.Vars.*;
 
@@ -77,6 +78,8 @@ public class BaseTurret extends Block{
         if(fogRadiusMultiplier < 0.99f && state.rules.fog){
             Drawf.dashCircle(x * tilesize + offset, y * tilesize + offset, range * fogRadiusMultiplier, Pal.lightishGray);
         }
+        if(Core.settings.getBool("arcTurretPlacementItem"))
+            ArcBuilds.turretPlaceDraw(x * tilesize + offset, y * tilesize + offset, this);
     }
 
     @Override
@@ -101,7 +104,7 @@ public class BaseTurret extends Block{
 
         @Override
         public void drawSelect(){
-            Drawf.dashCircle(x, y, range(), team.color);
+            drawPlace(tileX(), tileY(), 0, true);
         }
 
         public float estimateDps(){
diff --git a/core/src/mindustry/world/blocks/defense/turrets/ReloadTurret.java b/core/src/mindustry/world/blocks/defense/turrets/ReloadTurret.java
index 92038694598090f098af6ac10f41c286e195e0d7..d57dc74d1128471424071bb23bfb063243f8f70b 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/ReloadTurret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/ReloadTurret.java
@@ -1,9 +1,13 @@
 package mindustry.world.blocks.defense.turrets;
 
+import arc.Core;
 import arc.math.*;
 import arc.struct.*;
 import arc.util.*;
+import arc.scene.ui.layout.Table;
 import mindustry.type.*;
+import mindustry.graphics.Pal;
+import mindustry.ui.Bar;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
 
@@ -60,5 +64,14 @@ public class ReloadTurret extends BaseTurret{
         protected float baseReloadSpeed(){
             return efficiency;
         }
+
+        @Override
+        public void displayBars(Table bars){
+            super.displayBars(bars);
+            //bar for shoot cd
+            bars.add(new Bar(() -> Core.bundle.format("bar.reloadDetail", (int)(reloadCounter * 100 / reload)), () -> Pal.ammo, () -> (float)(reloadCounter / reload)));
+            bars.row();
+        }
+
     }
 }
diff --git a/core/src/mindustry/world/blocks/defense/turrets/Turret.java b/core/src/mindustry/world/blocks/defense/turrets/Turret.java
index cf350df9ea21f3654672c99a70c5c9f2ea439413..635f5feb9aebb2a40508919200d028d7daeadadf 100644
--- a/core/src/mindustry/world/blocks/defense/turrets/Turret.java
+++ b/core/src/mindustry/world/blocks/defense/turrets/Turret.java
@@ -7,6 +7,7 @@ import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
 import arc.math.geom.*;
+import arc.scene.ui.layout.Table;
 import arc.struct.*;
 import arc.util.*;
 import arc.util.io.*;
@@ -361,6 +362,18 @@ public class Turret extends ReloadTurret{
             drawer.draw(this);
         }
 
+        //show shoot target line
+        @Override
+        public void drawSelect(){
+            super.drawSelect();
+            if(!targetPos.isZero() && dst(targetPos) < range * 5){
+                Lines.stroke(1f);
+                Lines.dashLine(x, y, targetPos.x, targetPos.y, (int)(Mathf.len(targetPos.x - x, targetPos.y - y) / 8));
+                Lines.dashCircle(targetPos.x, targetPos.y, 8);
+                Draw.reset();
+            }
+        }
+
         @Override
         public void updateTile(){
             if(!validateTarget()) target = null;
@@ -678,6 +691,14 @@ public class Turret extends ReloadTurret{
             rotation = oldRot;
             reloadCounter = oldReload;
         }
+
+        @Override
+        public void displayBars(Table bars) {
+            super.displayBars(bars);
+            if (minWarmup > 0f) {
+                bars.add(new Bar(() -> Core.bundle.format("bar.warmupDetail", (int)(shootWarmup * 100 / minWarmup)), () -> Pal.ammo, () -> shootWarmup / minWarmup)).row();
+            }
+        }
     }
 
     public static class BulletEntry{
diff --git a/core/src/mindustry/world/blocks/production/Drill.java b/core/src/mindustry/world/blocks/production/Drill.java
index f5c6656ea21eedfc2bcb65edcf271bfdc49469eb..97b8404dba179b441685c2361fd1c601a5e0f214 100644
--- a/core/src/mindustry/world/blocks/production/Drill.java
+++ b/core/src/mindustry/world/blocks/production/Drill.java
@@ -18,7 +18,6 @@ import mindustry.logic.*;
 import mindustry.type.*;
 import mindustry.ui.*;
 import mindustry.world.*;
-import mindustry.world.blocks.environment.*;
 import mindustry.world.consumers.*;
 import mindustry.world.meta.*;
 import mindustryX.features.*;
@@ -146,12 +145,12 @@ public class Drill extends Block{
         countOre(tile);
 
         if(returnItem != null){
-            float width = drawPlaceText(Core.bundle.formatFloat("bar.drillspeed", 60f / getDrillTime(returnItem) * returnCount, 2), x, y, valid);
-            float dx = x * tilesize + offset - width/2f - 4f, dy = y * tilesize + offset + size * tilesize / 2f + 5, s = iconSmall / 4f;
-            Draw.mixcol(Color.darkGray, 1f);
-            Draw.rect(returnItem.fullIcon, dx, dy - 1, s, s);
-            Draw.reset();
-            Draw.rect(returnItem.fullIcon, dx, dy, s, s);
+            //MDTX ARC: 改变挖掘速度显示, 增加冷却加成速度.
+            float speed = 60f / getDrillTime(returnItem) * returnCount;
+            String msg = liquidBoostIntensity > 1
+            ? Strings.format("@ [white]@@[] @[white]([cyan]@[])", Iconc.production, returnItem.emoji(), returnItem.localizedName, Strings.autoFixed(speed, 2), Strings.autoFixed(speed * liquidBoostIntensity * liquidBoostIntensity, 2))
+            : Strings.format("@ [white]@@[] @", Iconc.production, returnItem.emoji(), returnItem.localizedName, Strings.autoFixed(speed, 2));
+            drawPlaceText(msg, x, y, valid);
 
             if(drawMineItem){
                 Draw.color(returnItem.color);
@@ -162,7 +161,10 @@ public class Drill extends Block{
             Tile to = tile.getLinkedTilesAs(this, tempTiles).find(t -> t.drop() != null && (t.drop().hardness > tier || t.drop() == blockedItem));
             Item item = to == null ? null : to.drop();
             if(item != null){
-                drawPlaceText(Core.bundle.get("bar.drilltierreq"), x, y, valid);
+                if (item == blockedItem) {
+                    drawPlaceText(Core.bundle.format("bar.drillcantmine"), x, y, valid);
+                }
+                else drawPlaceText(Core.bundle.format("bar.drilltierreq", item.hardness, tier), x, y, valid);
             }
         }
     }
@@ -192,6 +194,11 @@ public class Drill extends Block{
         return new TextureRegion[]{region, rotatorRegion, topRegion};
     }
 
+    public int countOreArc(Tile tile){
+        countOre(tile);
+        return returnCount;
+    }
+
     protected void countOre(Tile tile){
         returnItem = null;
         returnCount = 0;
diff --git a/core/src/mindustry/world/blocks/production/GenericCrafter.java b/core/src/mindustry/world/blocks/production/GenericCrafter.java
index a55bc18a055c74d4e7de3332bd1315beb3c42a63..16ab256b1c5d8ac6c722a9c406dd2b53a480e49a 100644
--- a/core/src/mindustry/world/blocks/production/GenericCrafter.java
+++ b/core/src/mindustry/world/blocks/production/GenericCrafter.java
@@ -1,5 +1,8 @@
 package mindustry.world.blocks.production;
 
+
+import arc.*;
+import arc.scene.ui.layout.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
 import arc.math.geom.*;
@@ -12,6 +15,8 @@ import mindustry.entities.units.*;
 import mindustry.gen.*;
 import mindustry.logic.*;
 import mindustry.type.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
 import mindustry.world.*;
 import mindustry.world.blocks.liquid.Conduit.*;
 import mindustry.world.draw.*;
@@ -358,5 +363,29 @@ public class GenericCrafter extends Block{
             warmup = read.f();
             if(legacyReadWarmup) read.f();
         }
+
+        @Override
+        public void displayBars(Table bars){
+            super.displayBars(bars);
+            //bar for shoot cd
+            bars.add(new Bar(() -> Iconc.crafting + " " + Strings.fixed(progress * 100f, 0)  + " %" + Calwavetimeremain(progress,getProgressIncrease(craftTime)*timeScale*60 / Time.delta),
+                    () -> Pal.ammo, () -> progress));
+            bars.row();
+        }
+    }
+    private String Calwavetimeremain(float progress,float ProgressIncrease){
+        if(ProgressIncrease == 0f || 1 / ProgressIncrease < 240f){
+            return "";
+        }
+        float time = (1-progress)/ProgressIncrease;
+
+        String wavetimeremain = " [orange]~";
+        int m = ((int)time) / 60;
+        if (m==0){
+            return "";
+        }
+        wavetimeremain += String.valueOf(m) ;
+        wavetimeremain += "min";
+        return wavetimeremain;
     }
 }
diff --git a/core/src/mindustry/world/blocks/storage/CoreBlock.java b/core/src/mindustry/world/blocks/storage/CoreBlock.java
index c3d50f69d72df5f5e4d30a1e99d1bf7a78ebc627..92495f3bb3497c162b1b5cae2bc3b6b8b4b26061 100644
--- a/core/src/mindustry/world/blocks/storage/CoreBlock.java
+++ b/core/src/mindustry/world/blocks/storage/CoreBlock.java
@@ -90,6 +90,7 @@ public class CoreBlock extends StorageBlock{
         player.set(core);
 
         if(!net.client()){
+            player.team(tile.team());
             Unit unit = spawnType.create(tile.team());
             unit.set(core);
             unit.rotation(90f);
@@ -712,6 +713,14 @@ public class CoreBlock extends StorageBlock{
                 outline.get(core);
                 core.proximity.each(storage -> storage.items == items, outline);
             });
+            if(state.isCampaign()){
+                Draw.z(Layer.blockOver);
+                float t = turnDuration - Universe.turnCounter;
+                String min = Strings.fixed(Mathf.floor(t / 60f / 60f), 0);
+                float s = Mathf.floor(t / 60f % 60f);
+                String sec = (s < 10f ? "0" : "") + Strings.fixed(s, 0);
+                drawPlaceText(("资源接收  "+ min+":"+sec), tileX(), tileY(), true);
+            }
             Draw.reset();
         }
 
diff --git a/core/src/mindustryX/Hooks.java b/core/src/mindustryX/Hooks.java
index f323267b874868d3c8c05919ccc1ea92821f4918..f6449229108ed927d93863741ccc6dbd7fd6b3d7 100644
--- a/core/src/mindustryX/Hooks.java
+++ b/core/src/mindustryX/Hooks.java
@@ -8,12 +8,11 @@ import mindustry.gen.*;
 import mindustry.input.*;
 import mindustryX.features.*;
 import mindustryX.features.Settings;
+import mindustryX.features.ui.*;
 
 import java.net.*;
 import java.util.*;
 
-import static arc.Core.*;
-
 public class Hooks implements ApplicationListener{
     /** invoke before `Vars.init`. Note that may be executed from `Vars.loadAsync` */
     public static void beforeInit(){
@@ -58,6 +57,14 @@ public class Hooks implements ApplicationListener{
         if(message == null) return null;
         if(Vars.ui != null){
             if(MarkerType.resolveMessage(message)) return message;
+            try{
+                ArcMessageDialog.resolveMsg(message, sender);
+                if(sender != null){
+                    message = (sender.unit().isNull() ? Iconc.alphaaaa : sender.unit().type.emoji()) + " " + message;
+                }
+            }catch(Exception e){
+                Log.err(e);
+            }
         }
         return message;
     }
@@ -78,8 +85,18 @@ public class Hooks implements ApplicationListener{
         if(Core.input.keyTap(Binding.point)){
             MarkerType.selected.markWithMessage(Core.input.mouseWorld());
         }
-        if(input.keyTap(Binding.toggle_block_render)){
-            settings.put("blockRenderLevel", (RenderExt.blockRenderLevel + 1) % 3);
+        if(Core.input.keyTap(Binding.toggle_block_render)){
+            Core.settings.put("blockRenderLevel", (RenderExt.blockRenderLevel + 1) % 3);
+        }
+        if(Core.input.keyTap(Binding.arcScanMode)){
+            ArcScanMode.enabled = !ArcScanMode.enabled;
+        }
+        if(Core.input.keyTap(Binding.showRTSAi)){
+            Core.settings.put("alwaysShowUnitRTSAi", !Core.settings.getBool("alwaysShowUnitRTSAi"));
+        }
+        if(Core.input.keyTap(Binding.superUnitEffect)){
+            int level = Core.settings.getInt("superUnitEffect");
+            Core.settings.put("superUnitEffect", (level + 1) % 3);
         }
     }
 
diff --git a/core/src/mindustryX/features/ArcBuilds.java b/core/src/mindustryX/features/ArcBuilds.java
new file mode 100644
index 0000000000000000000000000000000000000000..58cfacb6c8f3a89dd1bb476155231bac11344464
--- /dev/null
+++ b/core/src/mindustryX/features/ArcBuilds.java
@@ -0,0 +1,160 @@
+package mindustryX.features;
+
+import arc.*;
+import arc.graphics.g2d.*;
+import arc.math.*;
+import arc.math.geom.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.ctype.*;
+import mindustry.entities.bullet.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.type.*;
+import mindustry.world.blocks.defense.turrets.*;
+
+import static mindustry.Vars.*;
+
+//move from mindustry.arcModule.draw.ARCBuilds
+public class ArcBuilds{
+    private static boolean targetAir = false, targetGround = false, canShoot = false;
+    private static boolean turretForceShowRange = false;
+    private static int turretShowRange = 0, turretAlertRange;
+    private static boolean showTurretAmmo = false, showTurretAmmoAmount = false;
+    private static boolean blockWeaponTargetLine = false, blockWeaponTargetLineWhenIdle = false;
+
+    static{
+        // 减少性能开销
+        Events.run(EventType.Trigger.update, () -> {
+            turretForceShowRange = Core.settings.getBool("turretForceShowRange");
+            turretShowRange = Core.settings.getInt("turretShowRange");
+
+            turretAlertRange = Core.settings.getInt("turretAlertRange") * tilesize;
+
+            showTurretAmmo = Core.settings.getBool("showTurretAmmo");
+            showTurretAmmoAmount = Core.settings.getBool("showTurretAmmoAmount");
+
+            blockWeaponTargetLine = Core.settings.getBool("blockWeaponTargetLine");
+            blockWeaponTargetLineWhenIdle = Core.settings.getBool("blockWeaponTargetLineWhenIdle");
+        });
+    }
+
+    private static void drawRange(BaseTurret.BaseTurretBuild build){
+        Draw.z(Layer.turret - 0.8f);
+        //Draw.color(build.team.color, 0.05f);
+        //Fill.circle(build.x, build.y, build.range());
+        Draw.color(build.team.color, 0.6f);
+        Lines.circle(build.x, build.y, build.range());
+        Draw.reset();
+    }
+
+    public static void arcTurret(BaseTurret.BaseTurretBuild build){
+        if(build == null || !(build.team == player.team() || RenderExt.showOtherInfo)) return;
+        Draw.z(Layer.turret);
+
+        Vec2 targetPos = Vec2.ZERO;
+        if(build.block instanceof Turret t){
+            targetAir = t.targetAir;
+            targetGround = t.targetGround;
+            targetPos = ((Turret.TurretBuild)build).targetPos;
+            canShoot = ((Turret.TurretBuild)build).hasAmmo();
+        }else if(build.block instanceof TractorBeamTurret t){
+            targetAir = t.targetAir;
+            targetGround = t.targetGround;
+            Unit target = ((TractorBeamTurret.TractorBeamBuild)build).target;
+            if(target != null){
+                targetPos = Tmp.v1.set(target.x, target.y);
+            }
+            canShoot = build.potentialEfficiency > 0;
+        }
+        if(build instanceof PowerTurret.PowerTurretBuild){
+            canShoot = build.efficiency > 0;
+        }
+
+        if(turretForceShowRange || canShoot){
+            if((turretShowRange == 3 || (turretShowRange == 2 && targetAir) || (turretShowRange == 1 && targetGround)))
+                drawRange(build);
+            else if(turretAlertRange > 0 && build.team != player.team()){
+                boolean canHitPlayer = !player.unit().isNull() && player.unit().hittable() && (player.unit().isFlying() ? targetAir : targetGround)
+                && build.within(player.unit().x, player.unit().y, build.range() + turretAlertRange);
+                boolean canHitMouse = build.within(Core.input.mouseWorldX(), Core.input.mouseWorldY(), build.range() + turretAlertRange);
+                boolean canHitCommand = control.input.commandMode && ((ArcUnits.selectedUnitsFlyer && targetAir) || (ArcUnits.selectedUnitsLand && targetGround));
+                boolean canHitPlans = (control.input.block != null || control.input.selectPlans.size > 0) && targetGround;
+                if(canHitPlayer || (canHitMouse && (canHitCommand || canHitPlans))) drawRange(build);
+            }
+
+            if(showTurretAmmo && build instanceof ItemTurret.ItemTurretBuild it && it.ammo.any()){
+                //lc参考miner代码
+                ItemTurret.ItemEntry entry = (ItemTurret.ItemEntry)it.ammo.peek();
+                Item lastAmmo = entry.item;
+
+                Draw.z(Layer.turret + 0.1f);
+
+                float size = Math.max(4f, build.block.size * tilesize / 2.5f);
+                float ammoX = build.x - (build.block.size * tilesize / 2.0F) + (size / 2);
+                float ammoY = build.y - (build.block.size * tilesize / 2.0F) + (size / 2);
+
+                Draw.rect(lastAmmo.uiIcon, ammoX, ammoY, size, size);
+
+                float leftAmmo = Mathf.lerp(0, 1, Math.min(1f, (float)entry.amount / ((ItemTurret)it.block).maxAmmo));
+                if(leftAmmo < 0.75f && showTurretAmmoAmount){
+                    Draw.alpha(0.5f);
+                    Draw.color(lastAmmo.color);
+                    Lines.stroke(Lines.getStroke() * build.block.size * 0.5f);
+                    Lines.arc(ammoX, ammoY, size * 0.5f, leftAmmo);
+                }
+
+                Draw.reset();
+            }
+            if(targetPos.x != 0 && targetPos.y != 0 && blockWeaponTargetLine && Mathf.len(targetPos.x - build.x, targetPos.y - build.y) <= 1500f){
+                if(!(build instanceof Turret.TurretBuild) || ((Turret.TurretBuild)build).isShooting() || ((Turret.TurretBuild)build).isControlled()){
+                    Draw.color(1f, 0.2f, 0.2f, 0.8f);
+                    Lines.stroke(1.5f);
+                    Lines.line(build.x, build.y, targetPos.x, targetPos.y);
+                    Lines.dashCircle(targetPos.x, targetPos.y, 8);
+                }else if(blockWeaponTargetLineWhenIdle){
+                    Draw.color(1f, 1f, 1f, 0.3f);
+                    Lines.stroke(1.5f);
+                    Lines.line(build.x, build.y, targetPos.x, targetPos.y);
+                    Lines.dashCircle(targetPos.x, targetPos.y, 8);
+                }
+            }
+        }
+    }
+
+    public static void turretPlaceDraw(float x, float y, BaseTurret block){
+        float iconSize = 6f + 2f * block.size, range = block.range;
+        ObjectMap<? extends UnlockableContent, BulletType> ammoTypes;
+        if(block instanceof ContinuousLiquidTurret t){
+            ammoTypes = t.ammoTypes;
+        }else if(block instanceof LiquidTurret t){
+            ammoTypes = t.ammoTypes;
+        }else if(block instanceof ItemTurret t){
+            ammoTypes = t.ammoTypes;
+        }else if(block instanceof PowerTurret){
+            turretBulletDraw(x, y, Icon.power.getRegion(), iconSize, range, 0f);
+            return;
+        }else return;
+
+        int drawIndex = 0;
+        for(var e : ammoTypes.entries()){
+            var item = e.key;
+            var bulletType = e.value;
+            drawIndex += 1;
+            if(!item.unlockedNow()) return;
+            if(bulletType.rangeChange > 0) Drawf.dashCircle(x, y, range + bulletType.rangeChange, Pal.placing);
+            turretBulletDraw(x, y, item.uiIcon, iconSize, range + bulletType.rangeChange, (float)drawIndex / ammoTypes.size);
+        }
+    }
+
+    private static void turretBulletDraw(float x, float y, TextureRegion icon, float iconSize, float range, float rotOffset){
+        for(int i = 0; i < 4; i++){
+            float rot = (i + rotOffset) * 90f + Time.time * 0.5f;
+            Draw.rect(icon,
+            x + (Mathf.sin((float)Math.toRadians(rot)) * (range )),
+            y + (Mathf.cos((float)Math.toRadians(rot)) * (range )),
+            iconSize, iconSize, -rot);
+        }
+    }
+}
diff --git a/core/src/mindustryX/features/ArcOld.java b/core/src/mindustryX/features/ArcOld.java
index 855c5dad204db7796043e9c9c159a3c39d9795a3..459ffcffbedfcccafd9bc77101cb8af7c8dacf2b 100644
--- a/core/src/mindustryX/features/ArcOld.java
+++ b/core/src/mindustryX/features/ArcOld.java
@@ -1,15 +1,20 @@
 package mindustryX.features;
 
+import arc.*;
 import arc.func.*;
 import arc.graphics.*;
+import arc.graphics.g2d.*;
 import arc.struct.*;
 import arc.util.*;
+import mindustry.ctype.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
+import mindustry.world.*;
 import mindustryX.features.Settings.*;
 import mindustryX.features.ui.*;
 
 import static arc.Core.settings;
+import static arc.graphics.Color.RGBtoHSV;
 import static mindustry.Vars.*;
 
 public class ArcOld{
@@ -233,4 +238,41 @@ public class ArcOld{
             c.checkPref("developMode", false);
         }));
     }
+
+    public static void colorizeContent(){
+        if(!settings.getBool("colorizedContent")) return;
+        content.items().each(c -> colorizeContent(c, c.color));
+        content.liquids().each(c -> colorizeContent(c, c.color));
+        content.statusEffects().each(c -> colorizeContent(c, c.color));
+        content.planets().each(c -> colorizeContent(c, c.atmosphereColor));
+        content.blocks().each(c -> {
+            if(c.hasColor) colorizeContent(c, blockColor(c));
+            else if(c.itemDrop != null) colorizeContent(c, c.itemDrop.color);
+        });
+    }
+
+    private static void colorizeContent(UnlockableContent c, Color color){
+        c.localizedName = "[#" + color + "]" + c.localizedName + "[]";
+    }
+
+    private static Color blockColor(Block block){
+        Color bc = new Color(0, 0, 0, 1);
+        Color bestColor = new Color(0, 0, 0, 1);
+        int highestS = 0;
+        if(!block.synthetic()){
+            PixmapRegion image = Core.atlas.getPixmap(block.fullIcon);
+            for(int x = 0; x < image.width; x++)
+                for(int y = 0; y < image.height; y++){
+                    bc.set(image.get(x, y));
+                    int s = RGBtoHSV(bc)[1] * RGBtoHSV(bc)[1] + RGBtoHSV(bc)[2] + RGBtoHSV(bc)[2];
+                    if(s > highestS){
+                        highestS = s;
+                        bestColor = bc;
+                    }
+                }
+        }else{
+            return block.mapColor.cpy().mul(1.2f);
+        }
+        return bestColor;
+    }
 }
diff --git a/core/src/mindustryX/features/ArcRadar.java b/core/src/mindustryX/features/ArcRadar.java
new file mode 100644
index 0000000000000000000000000000000000000000..21abee2343532b732130d2209137a6c064d8ea70
--- /dev/null
+++ b/core/src/mindustryX/features/ArcRadar.java
@@ -0,0 +1,239 @@
+package mindustryX.features;
+
+import arc.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.math.*;
+import arc.scene.event.*;
+import arc.scene.ui.layout.*;
+import arc.util.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.input.*;
+import mindustry.ui.*;
+import mindustry.world.*;
+import mindustry.world.blocks.storage.*;
+import mindustryX.features.func.*;
+
+import static mindustry.Vars.*;
+
+//move from mindustry.arcModule.toolpack.arcScanner
+public class ArcRadar{
+    /** 基础缩放倍率，最重要的参数 */
+    private static final float ratio = 10f;
+    private static final float unitSize = 0.1f;
+    private static final float markerSize = 15f * tilesize;
+    /** 范围倍率 */
+    private static final int basicRadarCir = 25;
+    private static final Table t = new Table(Styles.black3);
+    public static boolean mobileRadar = false;
+    /** 真实大小 */
+    private static float rRatio;
+    private static float rMarkerSize;
+    /** 每多少范围一个雷达圈 */
+    private static float radarCir = 25f;
+    /** 默认扫描时间，仅用于特效 */
+    private static float scanTime = 5;
+    /** 当前扫描的百分比 */
+    private static float scanRate = 0;
+    /** 扫描线旋转倍率 */
+    private static final float scanSpeed = -0.02f;
+    /** 实际扫描范围，不是参数 */
+    private static float curScanRange = 0;
+    private static float expandRate = 1f;
+    private static float time = 0;
+
+    static{
+        t.touchable = Touchable.disabled;
+        t.margin(8f).add(">> 雷达扫描中 <<").color(Pal.accent).style(Styles.outlineLabel).labelAlign(Align.center);
+        t.visible = false;
+        t.update(() -> t.setPosition(Core.graphics.getWidth() / 2f, Core.graphics.getHeight() * 0.1f, Align.center));
+        t.pack();
+        t.act(0.1f);
+        t.update(() -> t.visible = t.visible && state.isPlaying());
+
+        Core.scene.add(t);
+
+        Events.on(EventType.WorldLoadEvent.class, event -> scanTime = Math.max(Mathf.dst(world.width(), world.height()) / 20f, 7.5f));
+    }
+
+    public static void drawScanner(){
+        if(Core.settings.getInt("radarMode") == 0) return;
+        float extendSpd = Core.settings.getInt("radarMode") * 0.2f;
+        Draw.reset();
+
+        if(mobile){
+            if(extendSpd >= 6){
+                t.visible = mobileRadar;
+                scanRate = t.visible ? 1f : 0f;
+            }else{
+                if(mobileRadar){
+                    t.visible = true;
+                    if(scanRate < 1f) scanRate = Math.min(scanRate + 1 / 60f / scanTime * extendSpd, 1f);
+                }else{
+                    t.visible = false;
+                    if(scanRate > 0f) scanRate = Math.max(scanRate - 3 / 60f / scanTime * extendSpd, 0f);
+                }
+            }
+        }else{
+            if(extendSpd >= 6){
+                if(Core.input.keyDown(Binding.arcDetail) && Time.time - time > 60f){
+                    time = Time.time;
+                    t.visible = !t.visible;
+                    scanRate = t.visible ? 1f : 0f;
+                }
+            }else{
+                if(Core.input.keyDown(Binding.arcDetail)){
+                    t.visible = true;
+                    if(scanRate < 1f) scanRate = Math.min(scanRate + 1 / 60f / scanTime * extendSpd, 1f);
+                }else{
+                    t.visible = false;
+                    if(scanRate > 0f) scanRate = Math.max(scanRate - 3 / 60f / scanTime * extendSpd, 0f);
+                }
+            }
+        }
+
+        if(scanRate <= 0) return;
+
+        float playerToBorder = Math.max(Math.max(Math.max(Mathf.dst(player.tileX(), player.tileY()), Mathf.dst(world.width() - player.tileX(), player.tileY())), Mathf.dst(world.width() - player.tileX(), world.height() - player.tileY())), Mathf.dst(player.tileX(), world.height() - player.tileY()));
+        float worldSize = Math.min(playerToBorder, (int)(Mathf.dst(world.width(), world.height()) / radarCir) * radarCir);
+
+        float playerSize = Math.min(world.width(), world.height()) * tilesize * 0.03f;
+
+        /* 整体缩放倍率，最重要的可调参数 */
+        float sizeRate = Core.settings.getInt("radarSize") == 0 ? 1f : Core.settings.getInt("radarSize") * 0.1f / renderer.getScale();
+        sizeRate *= Math.min(Core.scene.getHeight() / (world.height() * tilesize), Core.scene.getWidth() / (world.width() * tilesize)) * 2f;
+        rRatio = ratio / sizeRate;
+        float rUnitSize = unitSize * sizeRate;
+        rMarkerSize = markerSize * sizeRate;
+
+
+        expandRate = worldSize / basicRadarCir / 10 + 1;
+        radarCir = (int)expandRate * basicRadarCir;  //地图越大，radar间隔越大。此处选择最多10圈
+        curScanRange = worldSize * tilesize * scanRate;
+
+        expandRate *= sizeRate;
+
+        for(int i = 1; i < curScanRange / radarCir / tilesize + 1; i++){
+            Draw.color(player.team().color, 0.45f);
+            Lines.stroke(expandRate * 0.75f);
+            Lines.circle(player.x, player.y, (radarCir * i * tilesize) / rRatio);
+            float cirRatio = (radarCir * i * tilesize) / rRatio + 2f;
+            FuncX.drawText(Tmp.v1.trns(30, cirRatio).add(player), i * (int)radarCir + "", 1.25f * expandRate, Pal.accent);
+            FuncX.drawText(Tmp.v1.trns(150, cirRatio).add(player), i * (int)radarCir + "", 1.25f * expandRate, Pal.accent);
+            FuncX.drawText(Tmp.v1.trns(270, cirRatio).add(player), i * (int)radarCir + "", 1.25f * expandRate, Pal.accent);
+        }
+
+        if(scanRate < 1f){
+            Draw.color(player.team().color, 0.8f);
+            Lines.stroke(expandRate);
+            Lines.circle(player.x, player.y, curScanRange / rRatio);
+            Draw.color(player.team().color, 0.1f);
+            Fill.circle(player.x, player.y, curScanRange / rRatio);
+        }else{
+            curScanRange = (int)(curScanRange / radarCir / tilesize + 1) * radarCir * tilesize;
+
+            Draw.color(player.team().color, 0.1f);
+            Fill.circle(player.x, player.y, curScanRange / rRatio);
+
+            Draw.color(player.team().color, 0.6f);
+            float curve = Mathf.curve(Time.time % 360f, 120f, 360f);
+            Lines.stroke(expandRate * 1.5f);
+            Lines.circle(player.x, player.y, curScanRange / rRatio);
+            Lines.stroke(expandRate * 1.5f);
+            Lines.circle(player.x, player.y, curScanRange * Interp.pow3Out.apply(curve) / rRatio);
+            Lines.stroke(expandRate * 1.5f);
+
+            Draw.color(player.team().color, 0.1f);
+            Fill.rect(player.x - player.x / rRatio + world.width() * tilesize / rRatio / 2, player.y - player.y / rRatio + world.height() * tilesize / rRatio / 2, world.width() * tilesize / rRatio, world.height() * tilesize / rRatio);
+            Draw.color(player.team().color, 0.85f);
+            Lines.rect(player.x - player.x / rRatio, player.y - player.y / rRatio, world.width() * tilesize / rRatio, world.height() * tilesize / rRatio);
+        }
+
+        Draw.color(player.team().color, 0.8f);
+        Lines.line(player.x, player.y, player.x + curScanRange * Mathf.cos(Time.time * scanSpeed) / rRatio, player.y + curScanRange * Mathf.sin(Time.time * scanSpeed) / rRatio);
+        Draw.reset();
+
+        // 出怪点
+        if(spawner.countSpawns() < 25 && !state.rules.pvp){
+            for(Tile tile : spawner.getSpawns()){
+                if(scanRate < 1f && Mathf.dst(tile.worldx() - player.x, tile.worldy() - player.y) > curScanRange)
+                    continue;
+
+                Draw.color(state.rules.waveTeam.color, 1f);
+                arcDrawNearby(Icon.units.getRegion(), tile, Math.max(6 * expandRate, state.rules.dropZoneRadius / rRatio / 2), state.rules.waveTeam.color);
+
+                float curve = Mathf.curve(Time.time % 200f, 60f, 200f);
+                Draw.color(state.rules.waveTeam.color, 1f);
+                Lines.stroke(expandRate);
+                Lines.circle(transX(tile.worldx()), transY(tile.worldy()), state.rules.dropZoneRadius * Interp.pow3Out.apply(curve) / rRatio);
+                Draw.color(state.rules.waveTeam.color, 0.5f);
+                Lines.stroke(expandRate * 0.8f);
+                Lines.dashCircle(transX(tile.worldx()), transY(tile.worldy()), state.rules.dropZoneRadius / rRatio);
+            }
+        }
+        //绘制核心
+        for(Team team : Team.all){
+            for(CoreBlock.CoreBuild core : team.cores()){
+                if(state.rules.pvp && core.inFogTo(player.team())) continue;
+                if(scanRate < 1f && Mathf.dst(core.x - player.x, core.y - player.y) > curScanRange) continue;
+                Draw.color(core.team.color, 1f);
+                Draw.rect(core.block.fullIcon, transX(core.tile.worldx()), transY(core.tile.worldy()), 4 * expandRate, 4 * expandRate);
+
+            }
+        }
+        //绘制搜索的方块
+        for(Building build : UIExt.advanceBuildTool.buildingSeq){
+            if(scanRate < 1f && Mathf.dst(build.x - player.x, build.y - player.y) > curScanRange) continue;
+            Draw.color(build.team.color, 1f);
+            Draw.rect(build.block.fullIcon, transX(build.tile.worldx()), transY(build.tile.worldy()), 4 * expandRate, 4 * expandRate);
+        }
+        //绘制单位
+        for(Unit unit : Groups.unit){
+            if(scanRate < 1f && Mathf.dst(unit.x - player.x, unit.y - player.y) > curScanRange) continue;
+            Draw.color(unit.team.color, 0.6f);
+            Fill.circle(transX(unit.x), transY(unit.y), unit.hitSize * rUnitSize);
+        }
+        //绘制玩家
+        for(Player unit : Groups.player){
+            if(player.dead() || player.unit().health <= 0) continue;
+            if(scanRate < 1f && Mathf.dst(unit.x - player.x, unit.y - player.y) > curScanRange) continue;
+
+            Draw.color(unit.team().color, 0.9f);
+
+            float angle = unit.unit().rotation * Mathf.degreesToRadians;
+            Fill.tri(transX(unit.x + Mathf.cos(angle) * playerSize), transY(unit.y + Mathf.sin(angle) * playerSize),
+            transX(unit.x + Mathf.cos(angle + Mathf.PI * 2 / 3) * playerSize * 0.75f), transY(unit.y + Mathf.sin(angle + Mathf.PI * 2 / 3) * playerSize * 0.75f),
+            transX(unit.x + Mathf.cos(angle + Mathf.PI * 4 / 3) * playerSize * 0.75f), transY(unit.y + Mathf.sin(angle + Mathf.PI * 4 / 3) * playerSize * 0.75f));
+        }
+        //绘制arc标记
+        MarkerType.eachActive(a -> {
+            Draw.color(a.color);
+            Lines.stroke(expandRate * (1 - (Time.time % 180 + 30) / 210));
+
+            Lines.circle(transX(a.x), transY(a.y), rMarkerSize / rRatio * (Time.time % 180) / 180);
+            Lines.stroke(expandRate);
+            Lines.circle(transX(a.x), transY(a.y), rMarkerSize / rRatio);
+            Lines.arc(transX(a.x), transY(a.y), (rMarkerSize - expandRate) / rRatio, 1 - (Time.time - a.time) / MarkerType.retainTime);
+            Draw.reset();
+        });
+    }
+
+    public static void arcDrawNearby(TextureRegion region, Tile tile, float size, Color color){
+        float range = Mathf.dst(tile.worldy() - player.y, tile.worldx() - player.x);
+        if(range > curScanRange) return;
+        float nx = player.x + (tile.worldx() - player.x) / rRatio;
+        float ny = player.y + (tile.worldy() - player.y) / rRatio;
+        Draw.rect(region, nx, ny, size, size);
+    }
+
+    private static float transX(float x){
+        return player.x + (x - player.x) / rRatio;
+    }
+
+    private static float transY(float y){
+        return player.y + (y - player.y) / rRatio;
+    }
+
+}
diff --git a/core/src/mindustryX/features/ArcUnits.java b/core/src/mindustryX/features/ArcUnits.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b05b8fbce42092593a7dd4b177e73a69eedfc43
--- /dev/null
+++ b/core/src/mindustryX/features/ArcUnits.java
@@ -0,0 +1,346 @@
+package mindustryX.features;
+
+import arc.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.math.*;
+import arc.util.*;
+import mindustry.ai.types.*;
+import mindustry.entities.units.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.world.blocks.payloads.*;
+
+import static arc.graphics.g2d.Draw.color;
+import static arc.graphics.g2d.Lines.*;
+import static mindustry.Vars.*;
+
+//move from mindustry.arcModule.draw.ARCUnits
+public class ArcUnits{
+    private static final int maxBuildPlans = 100;
+    private static boolean alwaysShowPlayerUnit, alwaysShowUnitRTSAi, unitHealthBar, unitLogicMoveLine, unitLogicTimerBars, unithitbox, unitBuildPlan;
+    private static float defaultUnitTrans, unitDrawMinHealth, unitBarDrawMinHealth;
+    private static float unitWeaponRange, unitWeaponRangeAlpha;
+    public static boolean selectedUnitsFlyer, selectedUnitsLand;
+    public static boolean unitWeaponTargetLine, unitItemCarried;
+
+    private static float curStroke;
+    private static int unitTargetType, superUnitEffect;
+    private static boolean arcBuildInfo;
+
+    static{
+        // 减少性能开销
+        Events.run(EventType.Trigger.update, () -> {
+            alwaysShowPlayerUnit = Core.settings.getBool("alwaysShowPlayerUnit");
+            alwaysShowUnitRTSAi = Core.settings.getBool("alwaysShowUnitRTSAi");
+            unitHealthBar = Core.settings.getBool("unitHealthBar");
+            unitLogicMoveLine = Core.settings.getBool("unitLogicMoveLine");
+            unitLogicTimerBars = Core.settings.getBool("unitLogicTimerBars");
+            unithitbox = Core.settings.getBool("unithitbox");
+            unitBuildPlan = Core.settings.getBool("unitbuildplan");
+
+            defaultUnitTrans = RenderExt.unitHide ? 0 : Core.settings.getInt("unitTransparency") / 100f;
+            unitDrawMinHealth = Core.settings.getInt("unitDrawMinHealth");
+            unitBarDrawMinHealth = Core.settings.getInt("unitBarDrawMinHealth");
+
+            unitWeaponRange = Core.settings.getInt("unitWeaponRange") * tilesize;
+            unitWeaponRangeAlpha = Core.settings.getInt("unitWeaponRangeAlpha") / 100f;
+
+            selectedUnitsFlyer = control.input.selectedUnits.contains(Flyingc::isFlying);
+            selectedUnitsLand = control.input.selectedUnits.contains(unit -> !unit.isFlying());
+
+            curStroke = (float)Core.settings.getInt("playerEffectCurStroke") / 10f;
+            unitTargetType = Core.settings.getInt("unitTargetType");
+            superUnitEffect = Core.settings.getInt("superUnitEffect");
+            arcBuildInfo = Core.settings.getBool("arcBuildInfo");
+
+            unitWeaponTargetLine = Core.settings.getBool("unitWeaponTargetLine");
+            unitItemCarried = Core.settings.getBool("unitItemCarried");
+        });
+    }
+
+    public static float drawARCUnits(Unit unit){
+        if(unit.controller() instanceof Player){
+            drawPlayerEffect(unit);
+            if(alwaysShowPlayerUnit){
+                drawUnitBar(unit);
+                return 1f;
+            }
+        }
+        if(defaultUnitTrans == 0 || (unit.maxHealth + unit.shield) < unitDrawMinHealth) return 0f;
+        if((unit.maxHealth + unit.shield) >= unitBarDrawMinHealth) drawUnitBar(unit);
+        return defaultUnitTrans;
+    }
+
+    private static void drawUnitBar(Unit unit){
+        Draw.z(Draw.z() + 0.1f);
+        if(unit.team() == player.team() || RenderExt.showOtherInfo){
+            drawWeaponRange(unit);
+            drawRTSAI(unit);
+            drawHealthBar(unit);
+            drawLogic(unit);
+            drawBuildPlan(unit);
+        }
+        drawHitBox(unit);
+    }
+
+    private static void drawPlayerEffect(Unit unit){
+        Color effectColor = unit.controller() == player ? RenderExt.playerEffectColor : unit.team.color;
+
+        boolean drawCircle = (unit.controller() == player && superUnitEffect != 0) || (unit.controller() instanceof Player && superUnitEffect == 2);
+        if(drawCircle){
+            // 射程圈
+            Lines.stroke(Lines.getStroke() * curStroke);
+
+            Draw.z(Layer.effect - 2f);
+            Draw.color(effectColor);
+
+            Tmp.v1.trns(unit.rotation - 90, unit.x, unit.y).add(unit.x, unit.y);
+
+            if(curStroke > 0){
+                for(int i = 0; i < 5; i++){
+                    float rot = unit.rotation + i * 360f / 5 + Time.time * 0.5f;
+                    Lines.arc(unit.x, unit.y, unit.type.maxRange, 0.14f, rot, (int)(50 + unit.type.maxRange / 10));
+                }
+            }
+        }
+        // 武器圈
+        if(unitTargetType > 0){
+            Draw.z(Layer.effect);
+            Draw.color(effectColor, 0.8f);
+            Lines.stroke(1f);
+            Lines.line(unit.x, unit.y, unit.aimX, unit.aimY);
+            switch(unitTargetType){
+                case 1:
+                    Lines.dashCircle(unit.aimX, unit.aimY, 8);
+                    break;
+                case 2:
+                    Drawf.target(unit.aimX, unit.aimY, 6f, 0.7f, effectColor);
+                    break;
+                case 3:
+                    Drawf.target2(unit.aimX, unit.aimY, 6f, 0.7f, effectColor);
+                    break;
+                case 4:
+                    Drawf.targetc(unit.aimX, unit.aimY, 6f, 0.7f, effectColor);
+                    break;
+                case 5:
+                    Drawf.targetd(unit.aimX, unit.aimY, 6f, 0.7f, effectColor);
+                    break;
+            }
+        }
+
+        //玩家专属特效
+        if(unit.controller() == player){
+            detailBuildMode();
+        }
+    }
+
+    private static void drawWeaponRange(Unit unit){
+        if(unitWeaponRange == 0 || unitWeaponRangeAlpha == 0) return;
+        if(unitWeaponRange == 30){
+            drawWeaponRange(unit, unitWeaponRangeAlpha);
+        }else if(unit.team != player.team()){
+            boolean canHitPlayer = !player.unit().isNull() && player.unit().hittable() && (player.unit().isFlying() ? unit.type.targetAir : unit.type.targetGround)
+            && unit.within(player.unit().x, player.unit().y, unit.type.maxRange + unitWeaponRange);
+            boolean canHitCommand = control.input.commandMode && ((selectedUnitsFlyer && unit.type.targetAir) || (selectedUnitsLand && unit.type.targetGround));
+            boolean canHitPlans = (control.input.block != null || control.input.selectPlans.size > 0) && unit.type.targetGround;
+            boolean canHitMouse = unit.within(Core.input.mouseWorldX(), Core.input.mouseWorldY(), unit.type.maxRange + unitWeaponRange);
+            if(canHitPlayer || (canHitMouse && (canHitCommand || canHitPlans)))
+                drawWeaponRange(unit, unitWeaponRangeAlpha);
+        }
+    }
+
+    private static void drawWeaponRange(Unit unit, float alpha){
+        Draw.color(unit.team.color);
+        Draw.alpha(alpha);
+        Lines.dashCircle(unit.x, unit.y, unit.type.maxRange);
+        Draw.reset();
+    }
+
+    private static void drawRTSAI(Unit unit){
+        if(!control.input.commandMode && alwaysShowUnitRTSAi && unit.isCommandable() && unit.command().command != null){
+            Draw.z(Layer.effect);
+            CommandAI ai = unit.command();
+            if(ai.attackTarget != null){
+                Draw.color(unit.team.color);
+                if(ai.targetPos != null)
+                    Drawf.limitLineColor(unit, ai.attackTarget, unit.hitSize / 2f, 3.5f, unit.team.color);
+                Drawf.target(ai.attackTarget.getX(), ai.attackTarget.getY(), 6f, unit.team.color);
+            }else if(ai.targetPos != null){
+                Draw.color(unit.team.color);
+                Drawf.limitLineColor(unit, ai.targetPos, unit.hitSize / 2f, 3.5f, unit.team.color);
+                Draw.color(unit.team.color);
+                Drawf.square(ai.targetPos.getX(), ai.targetPos.getY(), 3.5f, unit.team.color);
+            }
+            Draw.reset();
+        }
+    }
+
+    private static void drawHealthBar(Unit unit){
+        if(!unitHealthBar) return;
+        Draw.z(Layer.shields + 6f);
+        float y_corr = 0f;
+        if(unit.hitSize < 30f && unit.hitSize > 20f && unit.controller().isBeingControlled(player.unit())) y_corr = 2f;
+        if(unit.health < unit.maxHealth){
+            Draw.reset();
+            Lines.stroke(4f);
+            Draw.color(unit.team.color, 0.5f);
+            Lines.line(unit.x - unit.hitSize() * 0.6f, unit.y + (unit.hitSize() / 2f) + y_corr, unit.x + unit.hitSize() * 0.6f, unit.y + (unit.hitSize() / 2f) + y_corr);
+            Lines.stroke(2f);
+            Draw.color(Pal.health, 0.8f);
+            Lines.line(
+            unit.x - unit.hitSize() * 0.6f, unit.y + (unit.hitSize() / 2f) + y_corr,
+            unit.x + unit.hitSize() * (Math.min(Mathf.maxZero(unit.health), unit.maxHealth) * 1.2f / unit.maxHealth - 0.6f), unit.y + (unit.hitSize() / 2f) + y_corr);
+            Lines.stroke(2f);
+        }
+        if(unit.shield > 0 && unit.shield < 1e20){
+            for(int didgt = 1; didgt <= Mathf.digits((int)(unit.shield / unit.maxHealth)) + 1; didgt++){
+                Draw.color(Pal.shield, 0.8f);
+                float shieldAmountScale = unit.shield / (unit.maxHealth * Mathf.pow(10f, (float)didgt - 1f));
+                if(didgt > 1){
+                    Lines.line(unit.x - unit.hitSize() * 0.6f,
+                    unit.y + (unit.hitSize() / 2f) + (float)didgt * 2f + y_corr,
+                    unit.x + unit.hitSize() * ((Mathf.ceil((shieldAmountScale - Mathf.floor(shieldAmountScale)) * 10f) - 1f + 0.0001f) * 1.2f * (1f / 9f) - 0.6f),
+                    unit.y + (unit.hitSize() / 2f) + (float)didgt * 2f + y_corr);
+                    //(s-1)*(1/9)because line(0) will draw length of 1
+                }else{
+                    Lines.line(unit.x - unit.hitSize() * 0.6f,
+                    unit.y + (unit.hitSize() / 2f) + (float)didgt * 2f + y_corr,
+                    unit.x + unit.hitSize() * ((shieldAmountScale - Mathf.floor(shieldAmountScale) - 0.001f) * 1.2f - 0.6f),
+                    unit.y + (unit.hitSize() / 2f) + (float)didgt * 2f + y_corr);
+                }
+            }
+        }
+        Draw.reset();
+
+        float index = 0f;
+        float iconSize = 4f;
+        int iconColumns = Math.max((int)(unit.hitSize() / (iconSize + 1f)), 4);
+        float iconWidth = Math.min(unit.hitSize() / iconColumns, iconSize + 1f);
+        for(var entry : unit.statuses()){
+            Draw.rect(entry.effect.uiIcon,
+            unit.x - unit.hitSize() * 0.6f + iconWidth * (index % iconColumns),
+            unit.y + (unit.hitSize() / 2f) + 3f + iconSize * Mathf.floor(index / iconColumns),
+            iconSize, iconSize);
+            index++;
+        }
+
+        index = 0f;
+        if(unit instanceof Payloadc payload && payload.payloads().any()){
+            for(Payload p : payload.payloads()){
+                Draw.rect(p.icon(),
+                unit.x - unit.hitSize() * 0.6f + 0.5f * iconSize * index,
+                unit.y + (unit.hitSize() / 2f) - 4f,
+                4f, 4f);
+                index++;
+            }
+        }
+        Draw.reset();
+    }
+
+    private static void drawLogic(Unit unit){
+        if(unit.controller() instanceof LogicAI logicai){
+            if(unitLogicMoveLine && Mathf.len(logicai.moveX - unit.x, logicai.moveY - unit.y) <= 1200f){
+                Lines.stroke(1f);
+                Draw.color(0.2f, 0.2f, 1f, 0.9f);
+                Lines.dashLine(unit.x, unit.y, logicai.moveX, logicai.moveY, (int)(Mathf.len(logicai.moveX - unit.x, logicai.moveY - unit.y) / 8));
+                Lines.dashCircle(logicai.moveX, logicai.moveY, logicai.moveRad);
+                Draw.reset();
+            }
+            if(unitLogicTimerBars){
+                Lines.stroke(2f);
+                Draw.color(Pal.heal);
+                Lines.line(unit.x - (unit.hitSize() / 2f), unit.y - (unit.hitSize() / 2f), unit.x - (unit.hitSize() / 2f), unit.y + unit.hitSize() * (logicai.controlTimer / LogicAI.logicControlTimeout - 0.5f));
+                Draw.reset();
+            }
+        }
+    }
+
+    private static void drawBuildPlan(Unit unit){
+        if(unitBuildPlan && !unit.plans().isEmpty()){
+            int counter = 0;
+            if(unit != player.unit()){
+                for(BuildPlan b : unit.plans()){
+                    unit.drawPlan(b, 0.5f);
+                    counter += 1;
+                    if(counter >= maxBuildPlans) break;
+                }
+            }
+            counter = 0;
+            Draw.color(Pal.gray);
+            Lines.stroke(2f);
+            float x = unit.x, y = unit.y, s = unit.hitSize / 2f;
+            for(BuildPlan b : unit.plans()){
+                Tmp.v2.trns(Angles.angle(x, y, b.drawx(), b.drawy()), s);
+                Tmp.v3.trns(Angles.angle(x, y, b.drawx(), b.drawy()), b.block.size * 2f);
+                Lines.circle(b.drawx(), b.drawy(), b.block.size * 2f);
+                Lines.line(x + Tmp.v2.x, y + Tmp.v2.y, b.drawx() - Tmp.v3.x, b.drawy() - Tmp.v3.y);
+                x = b.drawx();
+                y = b.drawy();
+                s = b.block.size * 2f;
+                counter += 1;
+                if(counter >= maxBuildPlans) break;
+            }
+
+            counter = 0;
+            Draw.color(unit.team.color);
+            Lines.stroke(0.75f);
+            x = unit.x;
+            y = unit.y;
+            s = unit.hitSize / 2f;
+            for(BuildPlan b : unit.plans()){
+                Tmp.v2.trns(Angles.angle(x, y, b.drawx(), b.drawy()), s);
+                Tmp.v3.trns(Angles.angle(x, y, b.drawx(), b.drawy()), b.block.size * 2f);
+                Lines.circle(b.drawx(), b.drawy(), b.block.size * 2f);
+                Draw.color(unit.team.color);
+                Lines.line(x + Tmp.v2.x, y + Tmp.v2.y, b.drawx() - Tmp.v3.x, b.drawy() - Tmp.v3.y);
+                x = b.drawx();
+                y = b.drawy();
+                s = b.block.size * 2f;
+                counter += 1;
+                if(counter >= maxBuildPlans) break;
+            }
+            Draw.reset();
+        }
+    }
+
+    private static void drawHitBox(Unit unit){
+        if(unithitbox){
+            Draw.color(unit.team.color, 0.5f);
+            Lines.circle(unit.x, unit.y, unit.hitSize / 2f);
+            Draw.reset();
+        }
+    }
+
+    private static void detailBuildMode(){
+        if(!arcBuildInfo) return;
+        if(control.input.droppingItem){
+            Color color = player.within(Core.input.mouseWorld(control.input.getMouseX(), control.input.getMouseY()), itemTransferRange) ? Color.gold : Color.red;
+            drawNSideRegion(player.unit().x, player.unit().y, 3, player.unit().type.buildRange, player.unit().rotation, color, 0.25f, player.unit().stack.item.uiIcon, false);
+        }else if(control.input.isBuilding || control.input.selectedBlock() || !player.unit().plans().isEmpty()){
+            drawNSideRegion(player.unit().x, player.unit().y, 3, player.unit().type.buildRange, player.unit().rotation, Pal.heal, 0.25f, Icon.wrench.getRegion(), true);
+        }
+    }
+
+    public static void drawNSideRegion(float x, float y, int n, float range, float rotation, Color color, float fraction, TextureRegion region, boolean regionColor){
+        Draw.z(Layer.effect - 2f);
+        color(color);
+
+        stroke(2f);
+
+        for(int i = 0; i < n; i++){
+            float frac = 360f * (1 - fraction * n) / n / 2;
+            float rot = rotation + i * 360f / n + frac;
+            if(!regionColor){
+                color(color);
+                arc(x, y, range, 0.25f, rot, (int)(50 + range / 10));
+                color();
+            }else{
+                arc(x, y, range, 0.25f, rot, (int)(50 + range / 10));
+            }
+            Draw.rect(region, x + range * Mathf.cos((float)Math.toRadians(rot - frac)), y + range * Mathf.sin((float)Math.toRadians(rot - frac)), 12f, 12f);
+        }
+        Draw.reset();
+    }
+}
diff --git a/core/src/mindustryX/features/ArcWaveSpawner.java b/core/src/mindustryX/features/ArcWaveSpawner.java
new file mode 100644
index 0000000000000000000000000000000000000000..ef4e313c601ad1ce64355761f420ef4173e5f766
--- /dev/null
+++ b/core/src/mindustryX/features/ArcWaveSpawner.java
@@ -0,0 +1,258 @@
+package mindustryX.features;
+
+import arc.*;
+import arc.func.*;
+import arc.graphics.*;
+import arc.graphics.g2d.*;
+import arc.math.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.content.*;
+import mindustry.core.*;
+import mindustry.game.*;
+import mindustry.world.*;
+import mindustryX.features.ui.*;
+
+import static mindustry.Vars.*;
+
+//move from mindustry.arcModule.toolpack.arcWaveSpawner
+public class ArcWaveSpawner{
+    public static boolean hasFlyer = true;
+
+    public static final float flyerSpawnerRadius = 5f * tilesize;
+
+    static final float spawnerMargin = tilesize * 11f;
+
+    public static final Seq<waveInfo> arcWave = new Seq<>();
+
+    static{
+        Events.on(EventType.WorldLoadEvent.class, event -> {
+            hasFlyer = false;
+            for(SpawnGroup sg : state.rules.spawns){
+                if(sg.type.flying){
+                    hasFlyer = true;
+                    break;
+                }
+            }
+            arcWave.clear();
+            for(int i = 0; i <= calWinWave(); i++){
+                arcWave.add(new waveInfo(i));
+            }
+        });
+    }
+
+    public static void drawSpawner(){
+        if(state.hasSpawns()){
+            Lines.stroke(2f);
+            Draw.color(Color.gray, Color.lightGray, Mathf.absin(Time.time, 8f, 1f));
+
+            if(Core.settings.getBool("alwaysshowdropzone")){
+                Draw.alpha(0.8f);
+                for(Tile tile : spawner.getSpawns()){
+                    arcDashCircling(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius, -flyerSpawnerRadius / state.rules.dropZoneRadius * 0.1f);
+                }
+            }else{
+                for(Tile tile : spawner.getSpawns()){
+                    if(tile.within(player.x, player.y, state.rules.dropZoneRadius + spawnerMargin)){
+                        Draw.alpha(Mathf.clamp(1f - (player.dst(tile) - state.rules.dropZoneRadius) / spawnerMargin));
+                        Lines.dashCircle(tile.worldx(), tile.worldy(), state.rules.dropZoneRadius);
+                    }
+                }
+            }
+            if(hasFlyer && Core.settings.getBool("showFlyerSpawn") && spawner.countSpawns() < 20){
+                for(Tile tile : spawner.getSpawns()){
+                    float angle = Angles.angle(world.width() / 2f, world.height() / 2f, tile.x, tile.y);
+                    float trns = Math.max(world.width(), world.height()) * Mathf.sqrt2 * tilesize;
+                    float spawnX = Mathf.clamp(world.width() * tilesize / 2f + Angles.trnsx(angle, trns), 0, world.width() * tilesize);
+                    float spawnY = Mathf.clamp(world.height() * tilesize / 2f + Angles.trnsy(angle, trns), 0, world.height() * tilesize);
+                    if(Core.settings.getBool("showFlyerSpawnLine")){
+                        Draw.color(Color.red, 0.5f);
+                        Lines.line(tile.worldx(), tile.worldy(), spawnX, spawnY);
+                    }
+                    Draw.color(Color.gray, Color.lightGray, Mathf.absin(Time.time, 8f, 1f));
+                    Draw.alpha(0.8f);
+                    arcDashCircling(spawnX, spawnY, flyerSpawnerRadius, 0.1f);
+
+                    Draw.color();
+                    Draw.alpha(0.5f);
+                    Draw.rect(UnitTypes.zenith.fullIcon, spawnX, spawnY);
+                }
+            }
+            Draw.reset();
+        }
+    }
+
+    public static waveInfo getOrInit(int wave){
+        while(arcWave.size <= wave) arcWave.add(new waveInfo(wave));
+        return arcWave.get(wave);
+    }
+
+    public static int calWinWave(){
+        if(state.rules.winWave >= 1) return state.rules.winWave;
+        int maxwave = 0;
+        for(SpawnGroup group : state.rules.spawns){
+            if(group.end > 99999) continue;
+            maxwave = Math.max(maxwave, group.end);
+        }
+        if(maxwave > 5000) return 200;
+        if(maxwave < 2 && state.rules.waveSpacing > 30f) return (int)(1800000 / state.rules.waveSpacing);
+        return maxwave + 1;
+    }
+
+    public static void arcDashCircling(float x, float y, float radius, float speed){
+        arcDashCircle(x, y, radius, Time.time * speed);
+    }
+
+    public static void arcDashCircle(float x, float y, float radius, float rotation){
+        float scaleFactor = 0.6f;
+        int sides = 10 + (int)(radius * scaleFactor);
+        if(sides % 2 == 1) sides++;
+
+        for(int i = 0; i < sides; i += 2){
+            var v = Tmp.v1;
+            v.set(radius, 0).rotate(360f / sides * i + 90 + rotation);
+            float x1 = v.x, y1 = v.y;
+            v.set(radius, 0).rotate(360f / sides * (i + 1) + 90 + rotation);
+            float x2 = v.x, y2 = v.y;
+            Lines.line(x + x1, y + y1, x + x2, y + y2);
+        }
+    }
+
+    /**
+     * 单一波次详情
+     */
+    public static class waveInfo{
+        public final int waveIndex;
+        public final Seq<waveGroup> groups = new Seq<>();
+
+        public int amount = 0, amountL = 0;
+
+        public float health = 0, effHealth = 0, dps = 0;
+        /**
+         * 临时数据记录
+         */
+        public long healthL = 0, effHealthL = 0, dpsL = 0;
+
+        waveInfo(int waveIndex){
+            this.waveIndex = waveIndex;
+            for(SpawnGroup group : state.rules.spawns){
+                int amount = group.getSpawned(waveIndex);
+                if(amount == 0) continue;
+                groups.add(new waveGroup(waveIndex, group));
+            }
+            initProperty();
+        }
+
+        private void initProperty(){
+            groups.each(group -> {
+                amount += group.amountT;
+                health += group.healthT;
+                effHealth += group.effHealthT;
+                dps += group.dpsT;
+            });
+        }
+
+        public void specLoc(int spawn, Boolf<SpawnGroup> pre){
+            amountL = 0;
+            healthL = 0;
+            effHealthL = 0;
+            dpsL = 0;
+            groups.each(waveGroup -> (spawn == -1 || waveGroup.group.spawn == -1 || waveGroup.group.spawn == spawn) && pre.get(waveGroup.group),
+            group -> {
+                amountL += group.amountT;
+                healthL += group.healthT;
+                effHealthL += group.effHealthT;
+                dpsL += group.dpsT;
+            });
+        }
+
+        public Table proTable(boolean doesRow){
+            if(amountL == 0) return new Table(t -> t.add("该波次没有敌人"));
+            return new Table(t -> {
+                t.add("\uE86D").width(50f);
+                t.add("[accent]" + amountL).growX().padRight(50f);
+                if(doesRow) t.row();
+                t.add("\uE813").width(50f);
+                t.add("[accent]" + UI.formatAmount(healthL)).growX().padRight(50f);
+                if(doesRow) t.row();
+                if(effHealthL != healthL){
+                    t.add("\uE810").width(50f);
+                    t.add("[accent]" + UI.formatAmount(effHealthL)).growX().padRight(50f);
+                    if(doesRow) t.row();
+                }
+                t.add("\uE86E").width(50f);
+                t.add("[accent]" + UI.formatAmount(dpsL)).growX();
+            });
+        }
+
+        public Table unitTable(int spawn, Boolf<SpawnGroup> pre){
+            return unitTable(spawn, pre, 10);
+        }
+
+        public Table unitTable(int spawn, Boolf<SpawnGroup> pre, int perCol){
+            int[] count = new int[1];
+            return new Table(t -> groups.each(waveGroup -> (spawn == -1 || waveGroup.group.spawn == -1 || waveGroup.group.spawn == spawn) && pre.get(waveGroup.group), wg -> {
+                count[0]++;
+                if(count[0] % perCol == 0) t.row();
+                t.table(tt -> {
+                    tt.table(ttt -> {
+                        ttt.image(wg.group.type.uiIcon).size(30);
+                        ttt.add(wg.group.type.typeColor() + wg.amount).fillX();
+                    }).row();
+                    StringBuilder groupInfo = new StringBuilder();
+                    if(wg.shield > 0f)
+                        groupInfo.append(FormatDefault.format(wg.shield));
+                    groupInfo.append("\n[]");
+                    if(wg.group.spawn != -1 && spawn == -1) groupInfo.append("*");
+                    if(wg.group.effect != null && wg.group.effect != StatusEffects.none)
+                        groupInfo.append(wg.group.effect.emoji());
+                    if(wg.group.items != null && wg.group.items.amount > 0)
+                        groupInfo.append(wg.group.items.item.emoji());
+                    if(wg.group.payloads != null && wg.group.payloads.size > 0)
+                        groupInfo.append("\uE87B");
+                    tt.add(groupInfo.toString()).fill();
+                }).height(80f).width(70f);
+
+            }));
+        }
+
+    }
+
+    /**
+     * 一种更为详细的spawnGroup
+     */
+    public static class waveGroup{
+        public final int waveIndex;
+        public final SpawnGroup group;
+        public final int amount;
+        public final int amountT;
+        public final float shield;
+        public final float health;
+        public float effHealth;
+        public float dps;
+        public final float healthT;
+        public final float effHealthT;
+        public final float dpsT;
+
+        public waveGroup(int waveIndex, SpawnGroup group){
+            this.waveIndex = waveIndex;
+            this.group = group;
+            this.amount = group.getSpawned(waveIndex);
+            this.shield = group.getShield(waveIndex);   //盾
+            this.health = (group.type.health + shield) * amount;   //盾+血
+            this.dps = group.type.estimateDps() * amount;
+            this.effHealth = health;
+            if(group.effect != null){
+                this.effHealth *= group.effect.healthMultiplier;
+                this.dps *= group.effect.damageMultiplier * group.effect.reloadMultiplier;
+            }
+
+            int multiplier = group.spawn != -1 || spawner.countSpawns() < 2 ? 1 : spawner.countSpawns();
+            this.amountT = amount * multiplier;
+            this.healthT = health * multiplier;
+            this.effHealthT = effHealth * multiplier;
+            this.dpsT = dps * multiplier;
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/mindustryX/features/MarkerType.java b/core/src/mindustryX/features/MarkerType.java
index c3850e910d6e9d579316734190e891d701681ffb..090c2e958f1d0ca8ad93da2ffd7620acb5d699c3 100644
--- a/core/src/mindustryX/features/MarkerType.java
+++ b/core/src/mindustryX/features/MarkerType.java
@@ -6,16 +6,17 @@ import arc.graphics.*;
 import arc.graphics.g2d.*;
 import arc.math.*;
 import arc.math.geom.*;
+import arc.scene.ui.layout.*;
 import arc.struct.*;
 import arc.util.*;
 import mindustry.*;
-import mindustry.arcModule.*;
-import mindustry.arcModule.ui.dialogs.*;
 import mindustry.entities.*;
 import mindustry.game.EventType.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
+import mindustryX.features.func.*;
 import mindustryX.features.ui.*;
+import mindustryX.features.ui.ArcMessageDialog.*;
 
 import java.util.regex.*;
 
@@ -155,7 +156,7 @@ public class MarkerType{
         var exists = (MarkElement)Groups.draw.find(it -> it instanceof MarkElement e && e.message == null && e.within(pos.scl(tilesize), 2 * tilesize));
         last = exists != null ? exists : type.at(pos.scl(tilesize));
         last.message = text;
-        MessageDialog.addMsg(new MessageDialog.advanceMsg(MessageDialog.arcMsgType.markLoc, text, pos));
+        ArcMessageDialog.addMsg(new Msg(Type.markLoc, text, pos));
         return true;
     }
 
@@ -199,9 +200,10 @@ public class MarkerType{
         @Override
         public void draw(){
             super.draw();
+            Draw.z(Layer.overlayUI);
             showArrow();
             if(message != null)
-                WorldLabel.drawAt(message, x, y, Layer.overlayUI, WorldLabel.flagOutline, 1);
+                FuncX.drawText(this, message);
         }
 
         private void showArrow(){
@@ -209,7 +211,7 @@ public class MarkerType{
             Drawf.arrow(player.x, player.y, x, y, 5f * tilesize, 4f, color);
 
             var p = Tmp.v1.set(this).sub(player).limit(4.5f * tilesize).add(player);
-            DrawUtilities.drawText((int)(dst(player) / 8) + "", 0.2f, p.x, p.y, color, Align.center);
+            FuncX.drawText(p, (int)(dst(player) / 8) + "", Scl.scl(1.25f), color);
         }
     }
 }
diff --git a/core/src/mindustryX/features/PicToMindustry.java b/core/src/mindustryX/features/PicToMindustry.java
new file mode 100644
index 0000000000000000000000000000000000000000..b3bf32d2d3da28f6adc38c56ea3d24404ace7d26
--- /dev/null
+++ b/core/src/mindustryX/features/PicToMindustry.java
@@ -0,0 +1,343 @@
+package mindustryX.features;
+
+import arc.*;
+import arc.files.*;
+import arc.graphics.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.*;
+import mindustry.content.*;
+import mindustry.game.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustry.world.blocks.distribution.*;
+import mindustry.world.blocks.logic.*;
+import mindustry.world.blocks.logic.CanvasBlock.*;
+
+import static mindustry.Vars.*;
+import static mindustry.content.Blocks.*;
+
+//move from mindustry.arcModule.toolpack.picToMindustry
+public class PicToMindustry{
+    static Pixmap oriImage, image, Cimage;
+    static Integer closest = null;
+    static Table tTable;
+    static Fi originFile;
+
+    static final int[] palette;
+    static final int canvasSize;
+
+    static float scale = 1f;
+    static final float[] scaleList = {0.02f, 0.05f, 0.1f, 0.15f, 0.2f, 0.25f, 0.3f, 0.4f, 0.5f, 0.65f, 0.8f, 1f, 1.25f, 1.5f, 2f, 3f, 5f};
+    static int colorDisFun = 0;
+    static final String[] disFunList = {"基础对比", "平方对比", "LAB"};
+
+    static{
+        CanvasBlock canva = (CanvasBlock)Blocks.canvas;
+        palette = canva.palette;
+        canvasSize = canva.canvasSize;
+    }
+
+    public static void show(){
+        ptDialog().show();
+    }
+
+    public static Dialog ptDialog(){
+        Dialog pt = new BaseDialog("arc-图片转换器");
+        pt.cont.table(t -> {
+            t.add("选择并导入图片，可将其转成画板、像素画或是逻辑画").padBottom(20f).row();
+            t.button("[cyan]选择图片[white](png)", () -> Vars.platform.showFileChooser(false, "png", file -> {
+                try{
+                    originFile = file;
+                    byte[] bytes = file.readBytes();
+                    oriImage = new Pixmap(bytes);
+                    rebuilt();
+                    if(oriImage.width > 500 || oriImage.height > 500)
+                        UIExt.announce("[orange]警告：图片可能过大，请尝试压缩图片", (float)5);
+                }catch(Throwable e){
+                    UIExt.announce("读取图片失败，请尝试更换图片\n" + e);
+                }
+            })).size(240, 50).padBottom(20f).row();
+            t.check("自动保存为蓝图", Core.settings.getBool("autoSavePTM"), ta -> Core.settings.put("autoSavePTM", ta));
+        }).padBottom(20f).row();
+        pt.cont.table(t -> {
+            t.add("缩放: \uE815 ");
+            Label zoom = t.add(String.valueOf(scale)).padRight(20f).get();
+            t.slider(0, scaleList.length - 1, 1, 11, s -> {
+                scale = scaleList[(int)s];
+                zoom.setText(Strings.fixed(scale, 2));
+                rebuilt();
+            }).width(200f);
+        }).padBottom(20f).visible(() -> oriImage != null).row();
+        pt.cont.table(t -> {
+            t.add("色调函数: ");
+            Label zoom = t.add(disFunList[0]).padRight(20f).get();
+            t.slider(0, disFunList.length - 1, 1, 0, s -> {
+                colorDisFun = (int)s;
+                zoom.setText(disFunList[colorDisFun]);
+            }).width(200f);
+        }).padBottom(20f).visible(() -> oriImage != null).row();
+        pt.cont.table(a -> tTable = a);
+        pt.cont.row();
+        pt.cont.button("逻辑画网站 " + Blocks.logicDisplay.emoji(), () -> {
+            String imageUrl = "https://buibiu.github.io/imageToMLogicPage/#/";
+            if(!Core.app.openURI(imageUrl)){
+                ui.showErrorMessage("打开失败，网址已复制到粘贴板\n请自行在阅览器打开");
+                Core.app.setClipboardText(imageUrl);
+            }
+        }).width(200f);
+        pt.addCloseButton();
+        return pt;
+    }
+
+    private static String formatNumber(int number){
+        return formatNumber(number, 1f);
+    }
+
+    private static String formatNumber(int number, float alert){
+        if(number >= 500 * alert) return "[red]" + number + "[]";
+        else if(number >= 200 * alert) return "[orange]" + number + "[]";
+        else return String.valueOf(number);
+    }
+
+    private static void rebuilt(){
+        image = Pixmaps.scale(oriImage, scale);
+        tTable.clear();
+        tTable.table(t -> {
+            t.add("路径").color(Pal.accent).padRight(25f).padBottom(10f);
+            t.button("\uE874", () -> Core.app.setClipboardText(originFile.absolutePath()));
+            t.add(originFile.absolutePath()).padBottom(10f).row();
+
+            t.add("名称").color(Pal.accent).padRight(25f).padBottom(10f);
+            t.button("\uE874", () -> Core.app.setClipboardText(originFile.name()));
+            t.add(originFile.name()).padBottom(10f).row();
+
+            t.add("原始大小").color(Pal.accent).padRight(25f);
+            t.add(formatNumber(oriImage.width) + "\uE815" + formatNumber(oriImage.height));
+        }).padBottom(20f).row();
+        tTable.table(t -> {
+            t.table(tt -> {
+                tt.button("画板 " + canvas.emoji(), Styles.cleart, () -> {
+                    Cimage = image.copy();
+                    create_rbg(palette);
+                    canvasGenerator();
+                }).size(100, 50);
+                tt.add("大小：" + formatNumber(image.width / canvasSize, 0.5f) + "\uE815" + formatNumber(image.height / canvasSize + 1, 0.5f));
+            });
+            t.row();
+            t.table(tt -> {
+                tt.button("画板++ " + canvas.emoji(), Styles.cleart, () -> {
+                    Cimage = image.copy();
+                    canvasPlus(Cimage);
+                    canvasGenerator();
+                }).size(100, 50);
+                tt.add("大小：" + formatNumber(image.width / canvasSize, 0.5f) + "\uE815" + formatNumber(image.height / canvasSize + 1, 0.5f));
+            }).row();
+            t.table(tt -> {
+                tt.button("像素画 " + Blocks.sorter.emoji(), Styles.cleart, () -> {
+                    Cimage = image.copy();
+                    sorterGenerator();
+                }).size(100, 50);
+                tt.add("大小：" + formatNumber(image.width) + "\uE815" + formatNumber(image.height));
+            }).row();
+        });
+    }
+
+    private static float diff_rbg(Integer a, Integer b){
+        int ar = a >> 24 & 0xFF,
+        ag = a >> 16 & 0xFF,
+        ab = a >> 8 & 0xFF;
+        // get in
+        int br = b >> 24 & 0xFF,
+        bg = b >> 16 & 0xFF,
+        bb = b >> 8 & 0xFF;
+        int dr = Math.abs(ar - br),
+        dg = Math.abs(ag - bg),
+        db = Math.abs(ab - bb);
+        switch(colorDisFun){
+            case 1 -> {
+                return dr * dr + dg * dg + db * db;
+            }
+            case 2 -> {
+                float Rmean = (ar + br) / 2f;
+                return (float)Math.sqrt((2 + Rmean / 256) * (dr * dr) + 4 * (dg * dg) + (2 + (255 - Rmean) / 256) * (db * db));
+            }
+            default -> {
+                return dr + dg + db;
+            }
+        }
+    }
+
+    private static void create_rbg(int[] colorBar){
+        for(int x = 0; x < image.width; x++){
+            for(int y = 0; y < image.height; y++){
+                Integer pixel = image.get(x, y);
+                float egg = 1000;
+                for(int other : colorBar){
+                    float h = diff_rbg(pixel, other);
+                    if(h < egg){
+                        closest = other;
+                        egg = h;
+                    }
+                }
+                Cimage.set(x, y, closest);
+            }
+        }
+    }
+
+    private static void canvasGenerator(){
+        int width = Cimage.width / canvasSize, height = Cimage.height / canvasSize + 1;
+        Seq<Schematic.Stile> tiles = new Seq<>();
+        for(int y = 0; y < height; y++){
+            for(int x = 0; x < width; x++){
+                // add canvas to the schematic
+                CanvasBuild build = (CanvasBuild)canvas.newBuilding();
+                // get max 12x12 region of the image
+                Pixmap region = Cimage.crop(x * canvasSize, (height - y - 1) * canvasSize, canvasSize, canvasSize);
+                // convert pixel data of the region
+                byte[] bytes = build.packPixmap(region);
+                Schematic.Stile stile = new Schematic.Stile(canvas, x * 2, y * 2, bytes, (byte)0);
+                tiles.add(stile);
+            }
+        }
+        StringMap tags = new StringMap();
+        tags.put("name", originFile.name());
+        Schematic schem = new Schematic(tiles, tags, width * 2, height * 2);
+        saveSchem(schem, canvas.emoji());
+    }
+
+    private static void saveSchem(Schematic schem, String l){
+        schem.labels.add(l);
+        if(Core.settings.getBool("autoSavePTM")){
+            Vars.schematics.add(schem);
+            String text = "已保存蓝图：" + originFile.name();
+            UIExt.announce(text, (float)10);
+        }
+        if(state.isGame()){
+            Vars.ui.schematics.hide();
+            Vars.control.input.useSchematic(schem);
+        }
+    }
+
+    private static void sorterGenerator(){
+        Seq<Schematic.Stile> tiles = new Seq<>();
+        for(int y = 0; y < image.height; y++){
+            for(int x = 0; x < image.width; x++){
+                if(image.get(x, y) == 0) continue;
+                Sorter.SorterBuild build = (Sorter.SorterBuild)sorter.newBuilding();
+                final float[] closestItem = {99999};
+                int finalX = x;
+                int finalY = y;
+                content.items().each(t -> {
+                    float dst = diff_rbg(t.color.rgba(), image.get(finalX, finalY));
+                    if(dst > closestItem[0]) return;
+                    build.sortItem = t;
+                    closestItem[0] = dst;
+                });
+                Schematic.Stile stile = new Schematic.Stile(sorter, x, image.height - y - 1, build.config(), (byte)0);
+                tiles.add(stile);
+            }
+        }
+        StringMap tags = new StringMap();
+        tags.put("name", originFile.name());
+        Schematic schem = new Schematic(tiles, tags, image.width, image.height);
+        saveSchem(schem, sorter.emoji());
+    }
+
+    private static int trans(RGB c1, RGB c2, int mul){
+        return c1.add(c2.cpy().mul(mul).mv(4)).rgba();
+    }
+
+    private static void canvasPlus(Pixmap image){
+        for(int y = 0; y < image.height; y++){
+            for(int x = 0; x < image.width; x++){
+                RGB pix = new RGB(image.get(x, y));
+                int nearest = findNearestColor(pix);
+                image.set(x, y, nearest);
+                pix.sub(new RGB(nearest));
+                if(x + 1 < image.width){
+                    image.set(x + 1, y, trans(new RGB(image.get(x + 1, y)), pix, 7));
+                }
+                if(y + 1 < image.height){
+                    if(x - 1 > 0){
+                        image.set(x - 1, y + 1, trans(new RGB(image.get(x - 1, y + 1)), pix, 3));
+                    }
+                    image.set(x, y + 1, trans(new RGB(image.get(x, y + 1)), pix, 5));
+                    if(x + 1 < image.width){
+                        image.set(x + 1, y + 1, trans(new RGB(image.get(x + 1, y + 1)), pix, 1));
+                    }
+                }
+            }
+        }
+    }
+
+    private static int findNearestColor(RGB color){
+        int max = 255 * 255 + 255 * 255 + 255 * 255 + 1;
+        int output = 0;
+        for(int i : palette){
+            int delta = color.cpy().sub(new RGB(i)).pow();
+            if(delta < max){
+                max = delta;
+                output = i;
+            }
+        }
+        return output;
+    }
+
+    private static class RGB{
+        int r, g, b;
+
+        RGB(int r, int g, int b){
+            this.r = r;
+            this.g = g;
+            this.b = b;
+        }
+
+        RGB(int rgba){
+            this(rgba >> 24 & 0xff, rgba >> 16 & 0xff, rgba >> 8 & 0xff);
+        }
+
+        public RGB sub(RGB c){
+            r = r - c.r;
+            g = g - c.g;
+            b = b - c.b;
+            return this;
+        }
+
+        public RGB add(RGB c){
+            r = Math.max(Math.min(c.r + r, 255), 0);
+            g = Math.max(Math.min(c.g + g, 255), 0);
+            b = Math.max(Math.min(c.b + b, 255), 0);
+            return this;
+        }
+
+        public RGB mul(int m){
+            r *= m;
+            g *= m;
+            b *= m;
+            return this;
+        }
+
+        public RGB mv(int s){
+            r >>= s;
+            g >>= s;
+            b >>= s;
+            return this;
+        }
+
+        public int pow(){
+            return r * r + g * g + b * b;
+        }
+
+        public int rgba(){
+            return r << 24 | g << 16 | b << 8 | 0xff;
+        }
+
+        public RGB cpy(){
+            return new RGB(r, g, b);
+        }
+    }
+}
diff --git a/core/src/mindustryX/features/RenderExt.java b/core/src/mindustryX/features/RenderExt.java
index b960fb6b877f69bfac4ca0e3a3524ca8660c9897..8d3cab7c602b2dfc1065d88c9d039872f01c486e 100644
--- a/core/src/mindustryX/features/RenderExt.java
+++ b/core/src/mindustryX/features/RenderExt.java
@@ -7,8 +7,8 @@ import arc.math.*;
 import arc.math.geom.*;
 import arc.util.*;
 import mindustry.*;
-import mindustry.arcModule.draw.*;
 import mindustry.entities.*;
+import mindustry.game.*;
 import mindustry.game.EventType.*;
 import mindustry.gen.*;
 import mindustry.graphics.*;
@@ -16,12 +16,14 @@ import mindustry.type.*;
 import mindustry.world.*;
 import mindustry.world.blocks.defense.*;
 import mindustry.world.blocks.defense.turrets.*;
+import mindustry.world.blocks.defense.turrets.BaseTurret.*;
 import mindustry.world.blocks.distribution.MassDriver.*;
 import mindustry.world.blocks.logic.*;
 import mindustry.world.blocks.logic.MessageBlock.*;
 import mindustry.world.blocks.production.Drill.*;
 import mindustry.world.blocks.storage.*;
 import mindustry.world.blocks.units.*;
+import mindustryX.features.func.*;
 
 import static mindustry.Vars.tilesize;
 
@@ -40,6 +42,8 @@ public class RenderExt{
     public static int massDriverLineInterval;
     public static boolean drawBars, drawBarsMend;
     public static float healthBarMinHealth;
+    public static boolean drawBlockDisabled;
+    public static boolean showOtherInfo;
 
     public static boolean unitHide = false;
     public static Color massDriverLineColor = Color.clear;
@@ -79,6 +83,9 @@ public class RenderExt{
             drawBars = Core.settings.getBool("blockBars");
             drawBarsMend = Core.settings.getBool("blockBars_mend");
             healthBarMinHealth = Core.settings.getInt("blockbarminhealth");
+            drawBlockDisabled = Core.settings.getBool("blockdisabled");
+            showOtherInfo = Core.settings.getBool("showOtherTeamState");
+            showOtherInfo |= Vars.player.team().id == 255 || Vars.state.rules.mode() != Gamemode.pvp;
         });
         Events.run(Trigger.draw, RenderExt::draw);
         Events.on(TileChangeEvent.class, RenderExt::onSetBlock);
@@ -104,6 +111,8 @@ public class RenderExt{
             drawMassDriverLine(b);
         if(build != null && drawBars)
             drawBars(build);
+        if(build instanceof BaseTurretBuild turretBuild)
+            ArcBuilds.arcTurret(turretBuild);
     }
 
     private static void placementEffect(float x, float y, float lifetime, float range, Color color){
@@ -192,7 +201,7 @@ public class RenderExt{
         if(buildRatio >= 0){
             drawBar(build, Color.black, Pal.accent, buildRatio);
             String progressT = Strings.format("[stat]@% | @s", (int)(Mathf.clamp(buildRatio, 0f, 1f) * 100), leftTime < 0 ? Iconc.cancel : Strings.fixed(leftTime / (60f * Vars.state.rules.unitBuildSpeed(build.team) * build.timeScale()), 0));
-            WorldLabel.drawAt(progressT, build.x, build.y + build.block.offset * 0.8f - 5f, Draw.z(), WorldLabel.flagOutline, 0.9f);
+            FuncX.drawText(Tmp.v1.set(build).add(0, build.block.offset * 0.8f - 5f), progressT, 0.9f);
         }
     }
 
diff --git a/core/src/mindustryX/features/UIExt.java b/core/src/mindustryX/features/UIExt.java
index 651e6408d6132a194f63fba2613abac62b60aaf1..1962d9b7db710f08cb7050723d2d48270e9c9963 100644
--- a/core/src/mindustryX/features/UIExt.java
+++ b/core/src/mindustryX/features/UIExt.java
@@ -20,6 +20,7 @@ public class UIExt{
     public static TeamSelectDialog teamSelect;
     public static ModsRecommendDialog modsRecommend = new ModsRecommendDialog();
     public static TeamsStatDisplay teamsStatDisplay;
+    public static ArcMessageDialog arcMessageDialog = new ArcMessageDialog();
     public static HudSettingsTable hudSettingsTable = new HudSettingsTable();
     public static AdvanceToolTable advanceToolTable = new AdvanceToolTable();
     public static AdvanceBuildTool advanceBuildTool = new AdvanceBuildTool();
diff --git a/core/src/mindustryX/features/ui/ArcMessageDialog.java b/core/src/mindustryX/features/ui/ArcMessageDialog.java
new file mode 100644
index 0000000000000000000000000000000000000000..14b2cf4fc7e110852f7a0b27a0a6d4996dc9355c
--- /dev/null
+++ b/core/src/mindustryX/features/ui/ArcMessageDialog.java
@@ -0,0 +1,419 @@
+package mindustryX.features.ui;
+
+import arc.*;
+import arc.graphics.*;
+import arc.math.geom.*;
+import arc.scene.ui.*;
+import arc.scene.ui.layout.*;
+import arc.struct.Queue;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.*;
+import mindustry.content.*;
+import mindustry.core.*;
+import mindustry.ctype.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustry.world.blocks.storage.*;
+import mindustryX.features.*;
+
+import java.text.*;
+import java.util.*;
+
+import static mindustry.Vars.*;
+
+//move from mindustry.arcModule.ui.dialogs.MessageDialog
+public class ArcMessageDialog extends BaseDialog{
+    public static final Queue<Msg> msgList = new Queue<>();//队头为新添加的
+    private static int maxMsgRecorded = Math.max(Core.settings.getInt("maxMsgRecorded"), 20);
+    private Table historyTable;
+    private boolean fieldMode = false;
+
+    public ArcMessageDialog(){
+        super("ARC-中央监控室");
+
+        //voiceControl.voiceControlDialog();
+        cont.pane(t -> historyTable = t).maxWidth(1000).scrollX(false);
+
+        addCloseButton();
+        buttons.button("设置", Icon.settings, this::arcMsgSettingTable);
+        buttons.button("导出", Icon.upload, this::exportMsg).name("导出聊天记录");
+
+        buttons.row();
+        buttons.button("清空", Icon.trash, () -> {
+            msgList.clear();
+            build();
+        });
+
+        shown(this::build);
+        onResize(this::build);
+
+        Events.on(EventType.WorldLoadEvent.class, e -> {
+            addMsg(new Msg(Type.eventWorldLoad, "载入地图： " + state.map.name()));
+            addMsg(new Msg(Type.eventWorldLoad, "简介： " + state.map.description()));
+            while(msgList.size >= maxMsgRecorded) msgList.removeLast();
+        });
+
+        Events.on(EventType.WaveEvent.class, e -> {
+            if(state.wavetime < 60f) return;
+            addMsg(new Msg(Type.eventWave, "波次： " + state.wave + " | " + getWaveInfo(state.wave - 1)));
+        });
+
+        Events.on(EventType.BlockDestroyEvent.class, e -> {
+            if(e.tile.build instanceof CoreBlock.CoreBuild)
+                addMsg(new Msg(Type.eventCoreDestory, "核心摧毁： " + "(" + (int)e.tile.x + "," + (int)e.tile.y + ")", new Vec2(e.tile.x * 8, e.tile.y * 8)));
+        });
+    }
+
+    public static void share(String type, String content){
+        UIExt.sendChatMessage("<ARCxMDTX><" + type + ">" + content);
+    }
+
+    public static void shareWaveInfo(int waves){
+        if(!state.rules.waves) return;
+        StringBuilder builder = new StringBuilder();
+        builder.append("标记了第").append(waves).append("波");
+        if(waves < state.wave){
+            builder.append("。");
+        }else{
+            if(waves > state.wave){
+                builder.append("，还有").append(waves - state.wave).append("波");
+            }
+            int timer = (int)(state.wavetime + (waves - state.wave) * state.rules.waveSpacing);
+            builder.append("[[").append(FormatDefault.duration((float)timer / 60)).append("]。");
+        }
+
+        builder.append(getWaveInfo(waves));
+        share("Wave", builder.toString());
+    }
+
+    public static void shareContent(UnlockableContent content, boolean description){
+        StringBuilder builder = new StringBuilder();
+        builder.append("标记了").append(content.localizedName).append(content.emoji());
+        builder.append("(").append(content.name).append(")");
+        if(content.description != null && description){
+            builder.append("。介绍: ").append(content.description);
+        }
+        ArcMessageDialog.share("Content", builder.toString());
+    }
+
+    public static String getWaveInfo(int waves){
+        StringBuilder builder = new StringBuilder();
+        if(state.rules.attackMode){
+            int sum = Math.max(state.teams.present.sum(t -> t.team != player.team() ? t.cores.size : 0), 1) + Vars.spawner.countSpawns();
+            builder.append("包含(×").append(sum).append(")");
+        }else{
+            builder.append("包含(×").append(Vars.spawner.countSpawns()).append("):");
+        }
+        for(SpawnGroup group : state.rules.spawns){
+            if(group.getSpawned(waves - 1) > 0){
+                builder.append((char)Fonts.getUnicode(group.type.name)).append("(");
+                if(group.effect != StatusEffects.invincible && group.effect != StatusEffects.none && group.effect != null){
+                    builder.append((char)Fonts.getUnicode(group.effect.name)).append("|");
+                }
+                if(group.getShield(waves - 1) > 0){
+                    builder.append(FormatDefault.format(group.getShield(waves - 1))).append("|");
+                }
+                builder.append(group.getSpawned(waves - 1)).append(")");
+            }
+        }
+        return builder.toString();
+    }
+
+    void build(){
+        historyTable.clear();
+        historyTable.setWidth(800f);
+        int i = 0;
+        for(var msg : msgList){
+            i++;
+            int id = i;
+            if(!msg.msgType.show) continue;
+            historyTable.table(Tex.whitePane, t -> {
+                t.setColor(msg.msgType.color);
+                t.marginTop(5);
+
+                t.table(Tex.whiteui, tt -> {
+                    tt.color.set(msg.msgType.color);
+
+                    if(msg.msgType == Type.chat)
+                        tt.add(getPlayerName(msg)).style(Styles.outlineLabel).left().width(300f);
+                    else
+                        tt.add(msg.msgType.name).style(Styles.outlineLabel).color(msg.msgType.color).left().width(300f);
+
+                    tt.add(formatTime(msg.time)).style(Styles.outlineLabel).color(msg.msgType.color).left().padLeft(20f).width(100f);
+
+                    if(msg.msgLoc != null){
+                        tt.button("♐： " + (int)(msg.msgLoc.x / tilesize) + "," + (int)(msg.msgLoc.y / tilesize), Styles.logict, () -> {
+                            control.input.panCamera(msg.msgLoc);
+                            MarkerType.mark.at(Tmp.v1.scl(msg.msgLoc.x, msg.msgLoc.y)).color = color;
+                            hide();
+                        }).padLeft(50f).height(24f).width(150f);
+                    }
+
+                    tt.add().growX();
+                    tt.add("    " + id).style(Styles.outlineLabel).color(msg.msgType.color).padRight(10);
+
+                    tt.button(Icon.copy, Styles.logici, () -> {
+                        Core.app.setClipboardText(msg.message);
+                        ui.announce("已导出本条聊天记录");
+                    }).size(24f).padRight(6);
+                    tt.button(Icon.cancel, Styles.logici, () -> {
+                        msgList.remove(msg);
+                        build();
+                    }).size(24f);
+
+                }).growX().height(30);
+
+                t.row();
+
+                t.table(tt -> {
+                    tt.left();
+                    tt.marginLeft(4);
+                    tt.setColor(msg.msgType.color);
+                    if(fieldMode) tt.field(msg.message, Styles.nodeArea, text -> {
+                    }).growX();
+                    else tt.labelWrap(getPlayerMsg(msg)).growX();
+                }).pad(4).padTop(2).growX().grow();
+
+                t.marginBottom(7);
+            }).growX().padBottom(15f).row();
+        }
+    }
+
+    private String getPlayerName(Msg msgElement){
+        int typeStart = msgElement.message.indexOf("[coral][");
+        int typeEnd = msgElement.message.indexOf("[coral]]");
+        if(typeStart == -1 || typeEnd == -1 || typeEnd <= typeStart){
+            return msgElement.msgType.name;
+        }
+
+        return msgElement.message.substring(typeStart + 20, typeEnd);
+    }
+
+    private String getPlayerMsg(Msg msgElement){
+        if(msgElement.msgType != Type.normal) return msgElement.message;
+        int typeStart = msgElement.message.indexOf("[coral][");
+        int typeEnd = msgElement.message.indexOf("[coral]]");
+        if(typeStart == -1 || typeEnd == -1 || typeEnd <= typeStart){
+            return msgElement.message;
+        }
+        return msgElement.message.substring(typeEnd + 9);
+    }
+
+    private void arcMsgSettingTable(){
+        BaseDialog setDialog = new BaseDialog("中央监控室-设置");
+        if(Core.settings.getInt("maxMsgRecorded") == 0) Core.settings.put("maxMsgRecorded", 500);
+
+        setDialog.cont.table(t -> {
+            t.check("信息编辑模式", fieldMode, a -> {
+                fieldMode = a;
+                build();
+            }).left().width(200f).row();
+
+            t.add("调整显示的信息").height(50f).row();
+            t.table(tt -> {
+                tt.button("关闭全部", Styles.cleart, () -> {
+                    for(Type type : Type.values()) type.show = false;
+                }).width(200f).height(50f);
+                tt.button("默认", Styles.cleart, () -> {
+                    for(Type type : Type.values()) type.show = true;
+                    Type.serverTips.show = false;
+                }).width(200f).height(50f);
+            }).row();
+            t.table(Tex.button, tt -> tt.pane(tp -> {
+                for(Type type : Type.values()){
+
+                    CheckBox box = new CheckBox("[#" + type.color.toString() + "]" + type.name);
+
+                    box.update(() -> box.setChecked(type.show));
+                    box.changed(() -> {
+                        type.show = !type.show;
+                        build();
+                    });
+
+                    box.left();
+                    tp.add(box).left().padTop(3f).row();
+                }
+            }).maxHeight(500).width(400f));
+        });
+
+        setDialog.cont.row();
+
+        setDialog.cont.table(t -> {
+            t.add("最大储存聊天记录(过高可能导致卡顿)：");
+            t.field(maxMsgRecorded + "", text -> {
+                int record = Math.min(Math.max(Integer.parseInt(text), 1), 9999);
+                maxMsgRecorded = record;
+                Core.settings.put("maxMsgRecorded", record);
+            }).valid(Strings::canParsePositiveInt).width(200f).get();
+            t.row();
+            t.add("超出限制的聊天记录将在载入地图时清除");
+        });
+
+        setDialog.addCloseButton();
+        setDialog.button("刷新", Icon.refresh, this::build);
+
+        setDialog.show();
+    }
+
+    public String formatTime(Date time){
+        return new SimpleDateFormat("HH:mm:ss", Locale.US).format(time);
+    }
+
+    public static void resolveMsg(String message, @Nullable Player sender){
+        Type type = resolveMarkType(message);
+        if(type == null) type = resolveServerType(message);
+        if(type == null) type = sender != null ? Type.chat : Type.normal;
+
+        addMsg(new Msg(type, message, sender != null ? sender.name() : null, sender != null ? new Vec2(sender.x, sender.y) : null));
+        if(!type.show) return;
+        switch(type){
+            case schematic -> {
+                String id = message.split("<Schem>")[1];
+                id = id.substring(id.indexOf(' ') + 1);
+                Http.get("https://pastebin.com/raw/" + id, r -> ui.schematics.readShare(r.getResultAsString().replace(" ", "+"), sender));
+            }
+            case markPlayer -> {
+                if(!message.split("AT")[1].contains(player.name)) return;
+                if(sender != null)
+                    ui.announce("[gold]你被[white] " + sender.name + " [gold]戳了一下，请注意查看信息框哦~", 10);
+                else ui.announce("[orange]你被戳了一下，请注意查看信息框哦~", 10);
+            }
+        }
+    }
+
+    public static Type resolveMarkType(String message){
+        if(!message.contains("<ARC")) return null;
+        if(message.contains("标记了") && message.contains("Wave")) return Type.markWave;
+        if(message.contains("标记了") && message.contains("Content")) return Type.markContent;
+        if(message.contains("<AT>")) return Type.markPlayer;
+        if(message.contains("<Schem>")) return Type.schematic;
+        return null;
+    }
+
+    private static final Seq<String> serverMsg = Seq.with("加入了服务器", "离开了服务器", "自动存档完成", "登录成功", "经验+", "[YELLOW]本局游戏时长:", "[YELLOW]单人快速投票", "[GREEN]回档成功",
+    "[YELLOW]PVP保护时间, 全力进攻吧", "[YELLOW]发起", "[YELLOW]你可以在投票结束前使用", "[GREEN]投票成功", "[GREEN]换图成功,当前地图",
+    "[RED]本地图禁用单位", "[RED]该地图限制空军,禁止进入敌方领空", "[yellow]本地图限制空军", "[YELLOW]火焰过多造成服务器卡顿,自动关闭火焰",
+    " [GREEN]====", "[RED]无效指令", "[RED]该技能", "切换成功",
+    "[violet][投票系统][]", "[coral][-]野生的", "[CYAN][+]野生的"   // xem相关
+    );
+
+    public static Type resolveServerType(String message){
+        if(message.contains("小贴士")) return Type.serverTips;
+        if(message.contains("[YELLOW][技能]")) return Type.serverSkill;
+        for(int i = 0; i < serverMsg.size; i++){
+            if(message.contains(serverMsg.get(i))){
+                return Type.serverMsg;
+            }
+        }
+        return null;
+    }
+
+    public static void addMsg(Msg msg){
+        msgList.addFirst(msg);
+    }
+
+    void exportMsg(){
+        StringBuilder messageHis = new StringBuilder();
+        messageHis.append("下面是[MDTX-").append(Version.mdtXBuild).append("] 导出的游戏内聊天记录").append("\n");
+        messageHis.append("*** 当前地图名称: ").append(state.map.name()).append("（模式：").append(state.rules.modeName).append("）\n");
+        messageHis.append("*** 当前波次: ").append(state.wave).append("\n");
+        messageHis.append("成功选取共 ").append(msgList.size).append(" 条记录，如下：\n");
+        for(var msg : msgList){
+            messageHis.append(Strings.stripColors(msg.message)).append("\n");
+        }
+        Core.app.setClipboardText(Strings.stripGlyphs(Strings.stripColors(messageHis.toString())));
+    }
+
+    public static class Msg{
+        public final Type msgType;
+        public final String message;
+        public final Date time;
+        public final String sender;
+        public boolean selected;
+        public final @Nullable Vec2 msgLoc;
+
+        public Msg(Type msgType, String message, Date time, String sender, Vec2 msgLoc){
+            this.msgType = msgType;
+            this.message = message;
+            this.time = time;
+            this.sender = sender;
+            this.msgLoc = msgLoc;
+        }
+
+        public Msg(Type msgType, String message, String sender, Vec2 msgLoc){
+            this(msgType, message, new Date(), sender, msgLoc);
+        }
+
+        public Msg(Type msgType, String message, Vec2 msgLoc){
+            this(msgType, message, "null", msgLoc);
+        }
+
+        public Msg(Type msgType, String message){
+            this(msgType, message, null);
+        }
+
+
+        public Msg sendMessage(){
+            ui.chatfrag.addMessage(msgType.arcMsgPreFix() + message);
+            return this;
+        }
+    }
+
+    public enum Type{
+        normal("消息", Color.gray),
+
+        chat("聊天", Color.valueOf("#778899")),
+        console("指令", Color.gold),
+
+        markLoc("标记", "坐标", Color.valueOf("#7FFFD4")),
+        markWave("标记", "波次", Color.valueOf("#7FFFD4")),
+        markContent("标记", "内容", Color.valueOf("#7FFFD4")),
+        markPlayer("标记", "玩家", Color.valueOf("#7FFFD4")),
+        arcChatPicture("分享", "图片", Color.yellow),
+        music("分享", "音乐", Color.pink),
+        schematic("分享", "蓝图", Color.blue),
+        district("规划区", "", Color.violet),
+
+        serverTips("服务器", "小贴士", Color.valueOf("#98FB98"), false),
+        serverMsg("服务器", "信息", Color.valueOf("#cefdce")),
+        serverToast("服务器", "通报", Color.valueOf("#00FA9A")),
+        serverSkill("服务器", "技能", Color.valueOf("#e6ffcc")),
+
+        logicNotify("逻辑", "通报", Color.valueOf("#ffccff")),
+        logicAnnounce("逻辑", "公告", Color.valueOf("#ffccff")),
+
+        eventWorldLoad("事件", "载入地图", Color.valueOf("#ff9999")),
+        eventCoreDestory("事件", "核心摧毁", Color.valueOf("#ffcccc")),
+        eventWave("事件", "波次", Color.valueOf("#ffcc99"));
+
+        public final String name;
+        public final String type;
+        public final String subClass;
+        public Color color;
+        public Boolean show;
+
+        Type(String type, String subClass, Color color, Boolean show){
+            this.name = subClass.isEmpty() ? type : (type + "~" + subClass);
+            this.type = type;
+            this.subClass = subClass;
+            this.color = color;
+            this.show = show;
+        }
+
+        Type(String type, String subClass, Color color){
+            this(type, subClass, color, true);
+        }
+
+        Type(String type, Color color){
+            this(type, "", color);
+        }
+
+        public String arcMsgPreFix(){
+            return "[#" + color.toString() + "]" + "[" + name + "][]";
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/core/src/mindustryX/features/ui/ArcPowerInfo.java b/core/src/mindustryX/features/ui/ArcPowerInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..7f6737204adc9856a176f6f36e8b316dc6e74938
--- /dev/null
+++ b/core/src/mindustryX/features/ui/ArcPowerInfo.java
@@ -0,0 +1,70 @@
+package mindustryX.features.ui;
+
+import arc.*;
+import arc.math.*;
+import arc.scene.*;
+import arc.scene.ui.layout.*;
+import mindustry.*;
+import mindustry.core.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+import mindustryX.features.Settings;
+
+//move from mindustry.arcModule.ui.PowerInfo
+public class ArcPowerInfo{
+    public static float balance, stored, capacity, produced, need;
+
+    public static void update(){
+        balance = 0;
+        stored = 0;
+        capacity = 0;
+        produced = 0;
+        need = 0;
+        Groups.powerGraph.each(item -> {
+            var graph = item.graph();
+            if(graph.all.isEmpty() || graph.all.first().team != Vars.player.team()) return;
+            balance += graph.getPowerBalance();
+            stored += graph.getLastPowerStored();
+            capacity += graph.getLastCapacity();
+            produced += graph.getLastPowerProduced();
+            need += graph.getLastPowerNeeded();
+        });
+    }
+
+    public static int getPowerBalance(){
+        return (int)(balance * 60);
+    }
+
+    public static float getSatisfaction(){
+        if(Mathf.zero(produced)){
+            return 0f;
+        }else if(Mathf.zero(need)){
+            return 1f;
+        }
+        return produced / need;
+    }
+
+
+    public static Element getBars(){
+        Table power = new Table(Tex.wavepane).marginTop(6);
+
+        Bar powerBar = new Bar(
+        () -> Core.bundle.format("bar.powerbalance", (getPowerBalance() >= 0 ? "+" : "") + UI.formatAmount(getPowerBalance())) +
+        (getSatisfaction() >= 1 ? "" : " [gray]" + (int)(getSatisfaction() * 100) + "%"),
+        () -> Pal.powerBar, ArcPowerInfo::getSatisfaction);
+        Bar batteryBar = new Bar(
+        () -> Core.bundle.format("bar.powerstored", UI.formatAmount((long)stored), UI.formatAmount((long)capacity)),
+        () -> Pal.powerBar,
+        () -> stored / capacity);
+
+        power.clicked(() -> Settings.cycle("arccoreitems",4));
+        power.margin(0);
+        power.add(powerBar).height(18).growX().padBottom(1);
+        power.row();
+        power.add(batteryBar).height(18).growX().padBottom(1);
+
+        power.update(ArcPowerInfo::update);
+        return power;
+    }
+}
\ No newline at end of file
diff --git a/core/src/mindustryX/features/ui/ArcWaveInfoDialog.java b/core/src/mindustryX/features/ui/ArcWaveInfoDialog.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d0fc7ec9d8b3f400cd4d9270aef4a03569ff1c2
--- /dev/null
+++ b/core/src/mindustryX/features/ui/ArcWaveInfoDialog.java
@@ -0,0 +1,1117 @@
+package mindustryX.features.ui;
+
+import arc.*;
+import arc.func.*;
+import arc.math.*;
+import arc.math.geom.*;
+import arc.scene.event.*;
+import arc.scene.style.*;
+import arc.scene.ui.*;
+import arc.scene.ui.TextField.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import arc.util.*;
+import mindustry.ai.types.*;
+import mindustry.content.*;
+import mindustry.core.*;
+import mindustry.editor.*;
+import mindustry.game.*;
+import mindustry.gen.*;
+import mindustry.graphics.*;
+import mindustry.io.*;
+import mindustry.type.*;
+import mindustry.type.unit.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustryX.features.*;
+
+import java.util.*;
+
+import static mindustry.Vars.*;
+import static mindustryX.features.ArcWaveSpawner.calWinWave;
+import static mindustry.game.SpawnGroup.never;
+import static mindustry.ui.Styles.*;
+
+//move from mindustry.arcModule.ui.ArcWaveInfoDialog
+public class ArcWaveInfoDialog extends BaseDialog{
+    private int start = 0;
+    private int displayed = 20;
+    private int graphSpeed = 1;
+    private final int maxGraphSpeed = 16;
+    Seq<SpawnGroup> groups = new Seq<>();
+    private SpawnGroup expandedGroup;
+
+    private Table table, nTable, oTable, iTable, eTable, uTable;
+    private int search = -1;
+    private final int maxVisible = 30;
+    private int filterHealth, filterBegin = -1, filterEnd = -1, filterAmount, filterAmountWave;
+    private boolean expandPane = false, filterHealthMode = false, filterStrict = false;
+    private UnitType lastType = UnitTypes.dagger;
+    private StatusEffect filterEffect = StatusEffects.none;
+    private Sort sort = Sort.begin;
+    private boolean reverseSort = false;
+    private float updateTimer;
+    private final float updatePeriod = 1f;
+    private TextField amountField = new TextField();
+    private boolean checkedSpawns;
+    private WaveGraph graph = new WaveGraph();
+
+    public int arcWaveIndex = 0;
+    private final float handerSize = 40f;
+    /**
+     * 是否显示波次界面。如果否，则显示原图
+     */
+    private boolean waveInfo = true;
+    private float waveMulti = 1f;
+
+    private int winWave;
+
+    //波次生成
+    Float difficult = 1f;
+    final Seq<UnitType> spawnUnit = content.units().copy().retainAll(unitType -> !(unitType instanceof MissileUnitType || unitType.controller instanceof BuilderAI || unitType.controller instanceof MinerAI || unitType.controller instanceof RepairAI));
+    final Seq<UnitType> allowUnit = content.units().copy().retainAll(unitType -> !(unitType instanceof MissileUnitType));
+    boolean surplusUnit = true, ErekirUnit = true;
+    boolean showUnitSelect = true;
+    boolean flyingUnit = true, navalUnit = true, supportUnit = true;
+
+    public ArcWaveInfoDialog(){
+        super("ARC-波次编辑器");
+
+        shown(() -> {
+            checkedSpawns = false;
+            winWave = calWinWave();
+
+            setup();
+        });
+        hidden(() -> state.rules.spawns = groups);
+
+        addCloseListener();
+
+        onResize(this::setup);
+
+        addCloseButton();
+
+        buttons.button("@waves.edit", Icon.pencil, () -> {
+            BaseDialog dialog = new BaseDialog("@waves.edit");
+            dialog.addCloseButton();
+            dialog.setFillParent(false);
+            dialog.cont.table(Tex.button, t -> {
+                var style = Styles.flatt;
+                t.defaults().size(210f, 58f);
+
+                t.button("@waves.copy", Icon.copy, style, () -> {
+                    ui.showInfoFade("@waves.copied");
+                    Core.app.setClipboardText(maps.writeWaves(groups));
+                    dialog.hide();
+                }).disabled(b -> groups == null).marginLeft(12f).row();
+
+                t.button("@waves.load", Icon.download, style, () -> {
+                    try{
+                        groups = maps.readWaves(Core.app.getClipboardText());
+                        buildGroups();
+                    }catch(Exception e){
+                        ui.showException("@waves.invalid", e);
+                    }
+                    dialog.hide();
+                }).marginLeft(12f).disabled(b -> Core.app.getClipboardText() == null || Core.app.getClipboardText().isEmpty()).row();
+
+                t.button("@settings.reset", Icon.upload, style, () -> ui.showConfirm("@confirm", "@settings.clear.confirm", () -> {
+                    groups = JsonIO.copy(waves.get());
+                    buildGroups();
+                    dialog.hide();
+                })).marginLeft(12f).row();
+
+                t.button("@clear", Icon.cancel, style, () -> ui.showConfirm("@confirm", "@settings.clear.confirm", () -> {
+                    groups.clear();
+                    buildGroups();
+                    dialog.hide();
+                })).marginLeft(12f);
+            });
+
+            dialog.show();
+        }).size(250f, 64f);
+
+        buttons.defaults().width(60f);
+
+        buttons.button("切换显示模式", () -> {
+            waveInfo = !waveInfo;
+            waveMulti = 1;
+            setup();
+        }).size(250f, 64f);
+
+        if(true){
+            buttons.button("随机", Icon.refresh, this::arcSpawner).width(200f);
+        }
+    }
+
+    void view(int amount){
+        updateTimer += Time.delta;
+        if(updateTimer >= updatePeriod){
+            displayed += amount;
+            if(displayed < 5) displayed = 5;
+            updateTimer = 0f;
+            updateWaves();
+        }
+    }
+
+    void shift(int amount){
+        updateTimer += Time.delta;
+        if(updateTimer >= updatePeriod){
+            start += amount;
+            if(start < 0) start = 0;
+            updateTimer = 0f;
+            updateWaves();
+        }
+    }
+
+    void setup(){
+        groups = JsonIO.copy(state.rules.spawns.isEmpty() ? waves.get() : state.rules.spawns);
+
+        cont.clear();
+        cont.stack(new Table(Tex.clear, main -> {
+            main.table(s -> {
+                s.image(Icon.zoom).padRight(8);
+                s.field(search < 0 ? "" : search + "", TextFieldFilter.digitsOnly, text -> {
+                    search = !text.isEmpty() ? Math.max(Strings.parseInt(text) - 1, -1) : -1;
+                    start = Math.max(search - (displayed / 2) - (displayed % 2), 0);
+                    buildGroups();
+                }).growX().maxTextLength(8).get().setMessageText("@waves.search");
+                s.button(Icon.filter, Styles.emptyi, this::showFilter).size(46f).tooltip("@waves.filter");
+            }).fillX().pad(6f).row();
+            main.pane(t -> table = t).growX().growY().padRight(8f).scrollX(false);
+            main.row();
+            main.table(f -> {
+                f.button("@add", () -> {
+                    if(groups == null) groups = new Seq<>();
+                    SpawnGroup newGroup = new SpawnGroup(lastType);
+                    groups.add(newGroup);
+                    expandedGroup = newGroup;
+                    showUpdate(newGroup, false);
+                    buildGroups();
+                    clearFilter();
+                }).growX().height(70f);
+                f.button(Icon.filter, () -> {
+                    BaseDialog dialog = new BaseDialog("@waves.sort");
+                    dialog.setFillParent(false);
+                    dialog.cont.table(Tex.button, t -> {
+                        for(Sort s : Sort.all){
+                            t.button("@waves.sort." + s, Styles.cleart, () -> {
+                                sort = s;
+                                dialog.hide();
+                                buildGroups();
+                            }).size(150f, 60f).checked(s == sort);
+                        }
+                    }).row();
+                    dialog.cont.check("@waves.sort.reverse", b -> {
+                        reverseSort = b;
+                        buildGroups();
+                    }).padTop(4).checked(reverseSort).padBottom(8f);
+                    dialog.addCloseButton();
+                    dialog.show();
+                    buildGroups();
+                }).size(64f, 70f).padLeft(4f);
+            }).fillX();
+        }), new Label("@waves.none"){{
+            visible(() -> groups.isEmpty());
+            this.touchable = Touchable.disabled;
+            setWrap(true);
+            setAlignment(Align.center, Align.center);
+        }}).width(390f).growY();
+        cont.table(tb -> {
+            if(waveInfo){
+                tb.table(t -> {
+                    t.table(buttons -> {
+                        buttons.clear();
+                        buttons.button("<<", cleart, () -> {
+                            arcWaveIndex -= 10;
+                            if(arcWaveIndex < 0) arcWaveIndex = 0;
+                            setup();
+                        }).size(handerSize);
+
+                        buttons.button("<", cleart, () -> {
+                            arcWaveIndex -= 1;
+                            if(arcWaveIndex < 0) arcWaveIndex = 1;
+                            setup();
+                        }).size(handerSize);
+
+                        TextField sField = buttons.field((arcWaveIndex + 1) + "", text -> {
+                            if(Strings.canParseInt(text)){
+                                arcWaveIndex = Integer.parseInt(text) - 1;
+                                setup();
+                            }
+                        }).get();
+
+                        buttons.button(">", cleart, () -> {
+                            arcWaveIndex += 1;
+                            setup();
+                        }).size(handerSize);
+
+                        buttons.button(">>", cleart, () -> {
+                            arcWaveIndex += 10;
+                            setup();
+                        }).size(handerSize);
+
+                        buttons.button("×", cleart, () -> {
+                            arcWaveIndex = 0;
+                            setup();
+                        }).size(handerSize);
+
+                        buttons.slider(0, winWave, 1, res -> {
+                            arcWaveIndex = (int)res;
+                            sField.setText((arcWaveIndex + 1) + "");
+                        });
+
+                    }).left().row();
+                    t.pane(waveInfo -> {
+                        waveInfo.clear();
+                        waveInfo.table(wi -> {
+                            int curInfoWave = arcWaveIndex;
+                            for(SpawnGroup group : state.rules.spawns){
+                                int amount = group.getSpawned(curInfoWave);
+                                if(amount > 0){
+                                    StringBuilder groupInfo = new StringBuilder();
+                                    groupInfo.append(group.type.emoji()).append("\n");
+                                    groupInfo.append(amount).append("\n");
+                                    if(group.getShield(curInfoWave) > 0f)
+                                        groupInfo.append(UI.formatAmount((long)group.getShield(curInfoWave))).append("\n");
+                                    if(group.effect != null && group.effect != StatusEffects.none)
+                                        groupInfo.append(group.effect.emoji()).append("\n");
+                                    wi.button(groupInfo.toString(), cleart, () -> unitSettingDialog(group)).height(130f).width(50f);
+                                }
+                            }
+                        });
+                    }).scrollY(false).left();
+                }).growX();
+                tb.row();
+                tb.add(graph = new WaveGraph()).grow();
+                tb.row();
+                tb.table(tbt -> {
+                    tbt.button("<", () -> {
+                    }).update(t -> {
+                        if(t.getClickListener().isPressed()){
+                            shift(-graphSpeed);
+                        }
+                    }).width(150f);
+                    tbt.button(">", () -> {
+                    }).update(t -> {
+                        if(t.getClickListener().isPressed()){
+                            shift(graphSpeed);
+                        }
+                    }).width(150f);
+
+                    tbt.button("-", () -> {
+                    }).update(t -> {
+                        if(t.getClickListener().isPressed()){
+                            view(-graphSpeed);
+                        }
+                    }).width(150f);
+                    tbt.button("+", () -> {
+                    }).update(t -> {
+                        if(t.getClickListener().isPressed()){
+                            view(graphSpeed);
+                        }
+                    }).width(150f);
+
+                    tbt.button("x" + graphSpeed, () -> {
+                        graphSpeed *= 2;
+                        if(graphSpeed > maxGraphSpeed) graphSpeed = 1;
+                    }).update(b -> b.setText("x" + graphSpeed)).width(150f);
+                }).growX();
+            }else{
+                tb.pane(p -> {
+                    p.table(Tex.button, t -> {
+                        p.margin(0).defaults().pad(5).growX();
+                        t.add("\uE86D 为单位数量；\uE813 为单位血+盾；\uE810 为计算buff的血+盾；\uE86E 为预估DPS。在游戏中时会考虑地图出怪点数目").color(Pal.accent);
+                    }).scrollX(false).growX().row();
+                    for(int wave = 0; wave < winWave * waveMulti; wave++){
+                        ArcWaveSpawner.waveInfo thisWave = ArcWaveSpawner.getOrInit(wave);
+                        thisWave.specLoc(-1, group -> true);
+                        int finalWave = wave;
+                        p.table(Tex.button, t -> {
+                            t.table(tt -> {
+                                tt.add("第[accent]" + (finalWave + 1) + "[]波");
+                                tt.row();
+                                float firstWaveTime = state.rules.initialWaveSpacing <= 0 ? (2 * state.rules.waveSpacing) : state.rules.initialWaveSpacing;
+                                int thisTime = (int)(finalWave * state.rules.waveSpacing + firstWaveTime);
+                                tt.add(FormatDefault.duration(thisTime / 60f, false)).row();
+                                Label waveTime = tt.add("").get();
+                                tt.update(() -> {
+                                    if(!state.isGame()) waveTime.setText("");
+                                    else{
+                                        int deltaTime = thisTime - (int)(state.wave <= 1 ? (firstWaveTime - state.wavetime) : (firstWaveTime + state.rules.waveSpacing * (state.wave - 1) - state.wavetime));
+                                        waveTime.setText(FormatDefault.duration(deltaTime / 60, false));
+                                    }
+                                });
+                            }).width(120f).left();
+                            if(thisWave.amount == 0) t.add("该波次没有敌人");
+                            else{
+                                t.add(thisWave.proTable(true));
+                                t.pane(thisWave.unitTable(-1, group -> true, mobile ? 8 : 15)).scrollX(true).scrollY(false).growX();
+                            }
+                        }).growX().row();
+                        p.margin(0).defaults().pad(5).growX();
+                    }
+                }).scrollX(false).growX().row();
+                tb.table(tbb -> {
+                    tbb.button("刷新波次显示", this::setup).width(200f);
+                    TextField sField = tbb.field(winWave * (int)waveMulti + "", text -> waveMulti = (Float.parseFloat(text) / winWave)).valid(Strings::canParsePositiveFloat).width(200f).get();
+                    tbb.slider(0.25f, 10f, 0.25f, 1f, t -> {
+                        waveMulti = t;
+                        sField.setText(winWave * (int)waveMulti + "");
+                    }).width(300f);
+                });
+            }
+        }).grow();
+
+
+        buildGroups();
+    }
+
+    void buildGroups(){
+        table.clear();
+        table.top();
+        table.margin(10f);
+
+        if(groups != null){
+            groups.sort(sort.sort);
+            if(reverseSort) groups.reverse();
+
+            for(SpawnGroup group : groups){
+                if((search >= 0 && group.getSpawned(search) <= 0)
+                || (filterHealth != 0 && !(filterHealthMode ? group.type.health * (search >= 0 ? group.getSpawned(search) : 1) > filterHealth : group.type.health * (search >= 0 ? group.getSpawned(search) : 1) < filterHealth))
+                || (filterBegin >= 0 && !(filterStrict ? group.begin == filterBegin : group.begin - 2 <= filterBegin && group.begin + 2 >= filterBegin))
+                || (filterEnd >= 0 && !(filterStrict ? group.end == filterEnd : group.end - 2 <= filterEnd && group.end + 2 >= filterEnd))
+                || (filterAmount != 0 && !(filterStrict ? group.getSpawned(filterAmountWave) == filterAmount : filterAmount - 5 <= group.getSpawned(filterAmountWave) && filterAmount + 5 >= group.getSpawned(filterAmountWave)))
+                || (filterEffect != StatusEffects.none && group.effect != filterEffect)) continue;
+
+                table.table(Tex.button, t -> {
+                    t.margin(0).defaults().pad(3).padLeft(5f).growX().left();
+                    t.button(b -> {
+                        b.left();
+                        b.image(group.type.uiIcon).size(32f).padRight(3).scaling(Scaling.fit);
+                        b.add(group.type.typeColor() + group.type.localizedName);
+                        if(group.effect != null && group.effect != StatusEffects.none)
+                            b.image(group.effect.uiIcon).size(20f).padRight(3).scaling(Scaling.fit);
+                        if(group.items != null && group.items.amount > 0)
+                            b.image(group.items.item.uiIcon).size(20f).padRight(3).scaling(Scaling.fit);
+                        if(group.payloads != null && group.payloads.size > 0)
+                            b.image(Icon.uploadSmall).size(20f).padRight(3).scaling(Scaling.fit);
+
+                        b.add().growX();
+
+                        b.label(() -> {
+                            StringBuilder builder = new StringBuilder();
+                            builder.append("[lightgray]").append(group.begin + 1);
+                            if(group.begin == group.end) return builder.toString();
+                            if(group.end > 999999) builder.append("+");
+                            else builder.append("~").append(group.end + 1);
+                            if(group.spacing > 1) builder.append("[white]|[lightgray]").append(group.spacing);
+                            return builder.append("  ").toString();
+                        }).minWidth(45f).labelAlign(Align.left).left();
+
+                        b.button(Icon.settingsSmall, Styles.emptyi, () -> unitSettingDialog(group)).pad(-6).size(46f);
+                        b.button(Icon.unitsSmall, Styles.emptyi, () -> showUpdate(group, false)).pad(-6).size(46f);
+                        b.button(Icon.cancel, Styles.emptyi, () -> {
+                            if(expandedGroup == group) expandedGroup = null;
+                            groups.remove(group);
+                            table.getCell(t).pad(0f);
+                            t.remove();
+                            buildGroups();
+                        }).pad(-6).size(46f).padRight(-12f);
+                    }, () -> {
+                        expandedGroup = expandedGroup == group ? null : group;
+                        buildGroups();
+                    }).height(46f).pad(-6f).padBottom(0f).row();
+
+                    if(expandedGroup == group){
+                        t.table(spawns -> {
+                            spawns.field("" + (group.begin + 1), TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.begin = Strings.parseInt(text) - 1;
+                                    updateWaves();
+                                }
+                            }).width(100f);
+                            spawns.add("@waves.to").padLeft(4).padRight(4);
+                            spawns.field(group.end == never ? "" : (group.end + 1) + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.end = Strings.parseInt(text) - 1;
+                                    updateWaves();
+                                }else if(text.isEmpty()){
+                                    group.end = never;
+                                    updateWaves();
+                                }
+                            }).width(100f).get().setMessageText("∞");
+                        }).row();
+
+                        t.table(p -> {
+                            p.add("@waves.every").padRight(4);
+                            p.field(group.spacing + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text) && Strings.parseInt(text) > 0){
+                                    group.spacing = Strings.parseInt(text);
+                                    updateWaves();
+                                }
+                            }).width(100f);
+                            p.add("@waves.waves").padLeft(4);
+                        }).row();
+
+                        t.table(a -> {
+                            a.field(group.unitAmount + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.unitAmount = Strings.parseInt(text);
+                                    updateWaves();
+                                }
+                            }).width(80f);
+
+                            a.add(" + ");
+                            a.field(Strings.fixed(Math.max((Mathf.zero(group.unitScaling) ? 0 : 1f / group.unitScaling), 0), 2), TextFieldFilter.floatsOnly, text -> {
+                                if(Strings.canParsePositiveFloat(text)){
+                                    group.unitScaling = 1f / Strings.parseFloat(text);
+                                    updateWaves();
+                                }
+                            }).width(80f);
+                            a.add("@waves.perspawn").padLeft(4);
+                        }).row();
+
+                        t.table(a -> {
+                            a.field(group.max + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.max = Strings.parseInt(text);
+                                    updateWaves();
+                                }
+                            }).width(80f);
+
+                            a.add("@waves.max").padLeft(5);
+                        }).row();
+
+                        t.table(a -> {
+                            a.field((int)group.shields + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.shields = Strings.parseInt(text);
+                                    updateWaves();
+                                }
+                            }).width(80f);
+
+                            a.add(" + ");
+                            a.field((int)group.shieldScaling + "", TextFieldFilter.digitsOnly, text -> {
+                                if(Strings.canParsePositiveInt(text)){
+                                    group.shieldScaling = Strings.parseInt(text);
+                                    updateWaves();
+                                }
+                            }).width(80f);
+                            a.add("@waves.shields").padLeft(4);
+                        }).row();
+
+                        t.table(a -> {
+                            a.add("@waves.spawn").padRight(8);
+
+                            a.button("", () -> {
+                                if(!checkedSpawns){
+                                    //recalculate waves when changed
+                                    spawner.reset();
+                                    checkedSpawns = true;
+                                }
+
+                                BaseDialog dialog = new BaseDialog("@waves.spawn.select");
+                                dialog.cont.pane(p -> {
+                                    p.background(Tex.button).margin(10f);
+                                    int i = 0;
+                                    int cols = 4;
+                                    int max = 20;
+
+                                    if(spawner.getSpawns().size >= max){
+                                        p.add("[lightgray](first " + max + ")").colspan(cols).padBottom(4).row();
+                                    }
+
+                                    for(var spawn : spawner.getSpawns()){
+                                        p.button(spawn.x + ", " + spawn.y, Styles.flatTogglet, () -> {
+                                            group.spawn = Point2.pack(spawn.x, spawn.y);
+                                            dialog.hide();
+                                        }).size(110f, 45f).checked(spawn.pos() == group.spawn);
+
+                                        if(++i % cols == 0){
+                                            p.row();
+                                        }
+
+                                        //only display first 20 spawns, you don't need to see more.
+                                        if(i >= 20){
+                                            break;
+                                        }
+                                    }
+
+                                    p.button("@waves.spawn.all", Styles.flatTogglet, () -> {
+                                        group.spawn = -1;
+                                        dialog.hide();
+                                    }).size(110f, 45f).checked(-1 == group.spawn);
+
+                                    if(spawner.getSpawns().isEmpty()){
+                                        p.add("@waves.spawn.none");
+                                    }
+                                });
+                                dialog.setFillParent(false);
+                                dialog.addCloseButton();
+                                dialog.show();
+                            }).width(160f).height(36f).get().getLabel().setText(() -> group.spawn == -1 ? "@waves.spawn.all" : Point2.x(group.spawn) + ", " + Point2.y(group.spawn));
+
+                        }).padBottom(8f).row();
+                    }
+                }).width(350f).pad(8);
+
+                table.row();
+            }
+        }else{
+            table.add("@editor.default");
+        }
+
+        updateWaves();
+    }
+
+    void showUpdate(SpawnGroup group, boolean payloads){
+        BaseDialog dialog = new BaseDialog("");
+        dialog.setFillParent(true);
+        if(payloads && group.payloads == null) group.payloads = Seq.with();
+        if(payloads) dialog.cont.table(e -> {
+            uTable = e;
+            updateIcons(group);
+        }).padBottom(6f).row();
+        dialog.cont.pane(p -> {
+            int i = 0;
+            for(UnitType type : content.units()){
+                if(type.internal) continue;
+                if(type.isHidden() && !(Core.settings.getBool("developmode"))) continue;
+                p.button(t -> {
+                    t.left();
+                    t.image(type.uiIcon).size(8 * 4).scaling(Scaling.fit).padRight(2f);
+                    t.add(type.localizedName);
+                }, () -> {
+                    if(payloads){
+                        group.payloads.add(type);
+                        updateIcons(group);
+                    }else{
+                        group.type = lastType = type;
+                        updateIcons(group);
+                        dialog.hide();
+                    }
+                    if(group.payloads != null && group.type.payloadCapacity <= 8) group.payloads.clear();
+                    if(group.items != null)
+                        group.items.amount = Mathf.clamp(group.items.amount, 0, group.type.itemCapacity);
+                    buildGroups();
+                }).pad(2).margin(12f).fillX();
+                if(++i % 5 == 0) p.row();
+            }
+        });
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    void showEffect(SpawnGroup group){
+        BaseDialog dialog = new BaseDialog("");
+        dialog.setFillParent(true);
+        dialog.cont.pane(p -> {
+            int i = 0;
+            for(StatusEffect effect : content.statusEffects()){
+                if(effect != StatusEffects.none && effect.reactive) continue;
+
+                p.button(t -> {
+                    t.left();
+                    if(effect.uiIcon != null && effect != StatusEffects.none){
+                        t.image(effect.uiIcon).size(8 * 4).scaling(Scaling.fit).padRight(2f);
+                    }else{
+                        t.image(Icon.none).size(8 * 4).scaling(Scaling.fit).padRight(2f);
+                    }
+
+                    if(effect != StatusEffects.none){
+                        t.add(effect.localizedName);
+                    }else{
+                        t.add("@settings.resetKey");
+                    }
+                }, () -> {
+                    if(group == null){
+                        filterEffect = effect;
+                    }else{
+                        group.effect = effect;
+                    }
+                    updateIcons(group);
+                    dialog.hide();
+                    buildGroups();
+                }).pad(2).margin(12f).fillX();
+                if(++i % 3 == 0) p.row();
+            }
+        });
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    void showItems(SpawnGroup group){
+        BaseDialog dialog = new BaseDialog("");
+        dialog.setFillParent(true);
+        dialog.cont.table(items -> {
+            items.add(Core.bundle.get("filter.option.amount") + ":");
+            amountField = items.field(group.items != null ? group.items.amount + "" : "", TextFieldFilter.digitsOnly, text -> {
+                if(Strings.canParsePositiveInt(text) && group.items != null){
+                    group.items.amount = Strings.parseInt(text) <= 0 ? group.type.itemCapacity : Mathf.clamp(Strings.parseInt(text), 0, group.type.itemCapacity);
+                }
+            }).width(120f).pad(2).margin(12f).maxTextLength((group.type.itemCapacity + "").length() + 1).get();
+            amountField.setMessageText(group.type.itemCapacity + "");
+        }).padBottom(6f).row();
+        dialog.cont.pane(p -> {
+            int i = 1;
+            p.defaults().pad(2).margin(12f).minWidth(200f).fillX();
+            p.button(icon -> {
+                icon.left();
+                icon.image(Icon.none).size(8 * 4).scaling(Scaling.fit).padRight(2f);
+                icon.add("@settings.resetKey");
+            }, () -> {
+                group.items = null;
+                updateIcons(group);
+                dialog.hide();
+                buildGroups();
+            });
+            for(Item item : content.items()){
+                p.button(t -> {
+                    t.left();
+                    if(item.uiIcon != null) t.image(item.uiIcon).size(8 * 4).scaling(Scaling.fit).padRight(2f);
+                    t.add(item.localizedName);
+                }, () -> {
+                    group.items = new ItemStack(item, Strings.parseInt(amountField.getText()) <= 0 ? group.type.itemCapacity : Mathf.clamp(Strings.parseInt(amountField.getText()), 0, group.type.itemCapacity));
+                    updateIcons(group);
+                    dialog.hide();
+                    buildGroups();
+                });
+                if(++i % 3 == 0) p.row();
+            }
+        });
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    void showFilter(){
+        BaseDialog dialog = new BaseDialog("@waves.filter");
+        dialog.setFillParent(false);
+        dialog.cont.defaults().size(210f, 64f);
+        dialog.cont.add(Core.bundle.get("waves.sort.health") + ":");
+        dialog.cont.table(filter -> {
+            filter.button(">", Styles.cleart, () -> {
+                filterHealthMode = !filterHealthMode;
+                buildGroups();
+            }).update(b -> b.setText(filterHealthMode ? ">" : "<")).size(40f).padRight(4f);
+            filter.defaults().width(170f);
+            numField("", filter, f -> filterHealth = f, () -> filterHealth, 15);
+        }).row();
+
+        dialog.cont.add("@waves.filter.begin");
+        dialog.cont.table(filter -> {
+            filter.defaults().maxWidth(120f);
+            numField("", filter, f -> filterBegin = f - 1, () -> filterBegin + 1, 8);
+            numField("@waves.to", filter, f -> filterEnd = f - 1, () -> filterEnd + 1, 8);
+        }).row();
+
+        dialog.cont.add(Core.bundle.get("waves.filter.amount") + ":");
+        dialog.cont.table(filter -> {
+            filter.defaults().maxWidth(120f);
+            numField("", filter, f -> filterAmount = f, () -> filterAmount, 12);
+            numField("@waves.filter.onwave", filter, f -> filterAmountWave = f, () -> filterAmountWave, 8);
+        }).row();
+
+        dialog.cont.table(t -> {
+            eTable = t;
+            updateIcons(null);
+        }).row();
+        dialog.row();
+        dialog.check("@waves.filter.strict", b -> {
+            filterStrict = b;
+            buildGroups();
+        }).checked(filterStrict).padBottom(10f).row();
+
+        dialog.table(p -> {
+            p.defaults().size(210f, 64f).padLeft(4f).padRight(4f);
+            p.button("@back", Icon.left, dialog::hide);
+            p.button("@clear", Icon.refresh, () -> {
+                clearFilter();
+                buildGroups();
+                dialog.hide();
+            });
+        });
+        dialog.addCloseListener();
+        dialog.show();
+    }
+
+    void unitSettingDialog(SpawnGroup group){
+        BaseDialog dialog = new BaseDialog("设置出怪组");
+        dialog.setFillParent(false);
+        dialog.cont.table(Tex.button, a -> nTable = a).row();
+        dialog.cont.table(Tex.button, a -> oTable = a).row();
+        dialog.cont.table(Tex.button, a -> iTable = a).row();
+        dialog.cont.table(c -> {
+            c.defaults().size(210f, 64f).pad(2f);
+            c.button("@waves.duplicate", Icon.copy, () -> {
+                SpawnGroup newGroup = group.copy();
+                groups.add(newGroup);
+                expandedGroup = newGroup;
+                buildGroups();
+                dialog.hide();
+            });
+            c.button("@settings.resetKey", Icon.refresh, () -> ui.showConfirm("@confirm", "@settings.clear.confirm", () -> {
+                group.effect = StatusEffects.none;
+                group.payloads = Seq.with();
+                group.items = null;
+                buildGroups();
+                dialog.hide();
+            }));
+        });
+        buildGroups();
+        updateIcons(group);
+        dialog.addCloseButton();
+        dialog.show();
+    }
+
+    void updateIcons(SpawnGroup group){
+        if(nTable != null && group != null){
+            nTable.clear();
+            nTable.defaults().size(400f, 50f).pad(2f);
+            nTable.table(t -> {
+                t.image(group.type.uiIcon).size(32f).padRight(5).scaling(Scaling.fit).get();
+                //if(group.effect != null && group.effect != StatusEffects.none) b.image(group.effect.uiIcon).size(20f).padRight(3).scaling(Scaling.fit);
+                t.add(group.type.localizedName).padRight(20).color(Pal.accent);
+                t.button(Icon.units, Styles.emptyi, () -> showUpdate(group, false)).pad(-6).size(50f);
+            }).growX().row();
+        }
+
+        if(oTable != null && group != null){
+            oTable.clear();
+            oTable.defaults().size(400f, 250f).pad(2f);
+            oTable.table(t -> {
+                t.table(spawns -> {
+                    spawns.field("" + (group.begin + 1), TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.begin = Strings.parseInt(text) - 1;
+                            updateWaves();
+                        }
+                    }).width(150f);
+                    spawns.add("@waves.to").padLeft(4).padRight(4);
+                    spawns.field(group.end == never ? "" : (group.end + 1) + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.end = Strings.parseInt(text) - 1;
+                            updateWaves();
+                        }else if(text.isEmpty()){
+                            group.end = never;
+                            updateWaves();
+                        }
+                    }).width(150f).get().setMessageText("∞");
+                }).row();
+
+                t.table(p -> {
+                    p.add("@waves.every").padRight(4);
+                    p.field(group.spacing + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text) && Strings.parseInt(text) > 0){
+                            group.spacing = Strings.parseInt(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+                    p.add("@waves.waves").padLeft(4);
+                }).row();
+
+                t.table(a -> {
+                    a.field(group.unitAmount + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.unitAmount = Strings.parseInt(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+
+                    a.add(" + ");
+                    a.field(Strings.fixed(Math.max((Mathf.zero(group.unitScaling) ? 0 : 1f / group.unitScaling), 0), 2), TextFieldFilter.floatsOnly, text -> {
+                        if(Strings.canParsePositiveFloat(text)){
+                            group.unitScaling = 1f / Strings.parseFloat(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+                    a.add("@waves.perspawn").padLeft(4);
+                }).row();
+
+                t.table(a -> {
+                    a.field(group.max + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.max = Strings.parseInt(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+
+                    a.add("@waves.max").padLeft(5);
+                }).row();
+
+                t.table(a -> {
+                    a.field((int)group.shields + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.shields = Strings.parseInt(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+
+                    a.add(" + ");
+                    a.field((int)group.shieldScaling + "", TextFieldFilter.digitsOnly, text -> {
+                        if(Strings.canParsePositiveInt(text)){
+                            group.shieldScaling = Strings.parseInt(text);
+                            updateWaves();
+                        }
+                    }).width(150f);
+                    a.add("@waves.shields").padLeft(4);
+                }).row();
+
+                t.table(a -> {
+                    a.add("@waves.spawn").padRight(8);
+
+                    a.button("", () -> {
+                        if(!checkedSpawns){
+                            //recalculate waves when changed
+                            spawner.reset();
+                            checkedSpawns = true;
+                        }
+
+                        BaseDialog dialog = new BaseDialog("@waves.spawn.select");
+                        dialog.cont.pane(p -> {
+                            p.background(Tex.button).margin(10f);
+                            int i = 0;
+                            int cols = 4;
+                            int max = 20;
+
+                            if(spawner.getSpawns().size >= max){
+                                p.add("[lightgray](first " + max + ")").colspan(cols).padBottom(4).row();
+                            }
+
+                            for(var spawn : spawner.getSpawns()){
+                                p.button(spawn.x + ", " + spawn.y, Styles.flatTogglet, () -> {
+                                    group.spawn = Point2.pack(spawn.x, spawn.y);
+                                    dialog.hide();
+                                }).size(110f, 45f).checked(spawn.pos() == group.spawn);
+
+                                if(++i % cols == 0){
+                                    p.row();
+                                }
+
+                                //only display first 20 spawns, you don't need to see more.
+                                if(i >= 20){
+                                    break;
+                                }
+                            }
+
+                            p.button("@waves.spawn.all", Styles.flatTogglet, () -> {
+                                group.spawn = -1;
+                                dialog.hide();
+                            }).size(110f, 45f).checked(-1 == group.spawn);
+
+                            if(spawner.getSpawns().isEmpty()){
+                                p.add("@waves.spawn.none");
+                            }
+                        });
+                        dialog.setFillParent(false);
+                        dialog.addCloseButton();
+                        dialog.show();
+                    }).width(160f).height(36f).get().getLabel().setText(() -> group.spawn == -1 ? "@waves.spawn.all" : Point2.x(group.spawn) + ", " + Point2.y(group.spawn));
+
+                }).padBottom(8f).row();
+
+
+            }).growX().row();
+        }
+
+        if(iTable != null && group != null){
+            iTable.clear();
+            iTable.defaults().size(200f, 60f).pad(2f);
+            iTable.button(icon -> {
+                icon.add("状态");
+                if(group.effect != null && group.effect != StatusEffects.none){
+                    icon.image(group.effect.uiIcon).padLeft(6f);
+                }else{
+                    icon.image(Icon.logic).padLeft(6f);
+                }
+            }, Styles.cleart, () -> showEffect(group));
+            if(group.type.payloadCapacity > 0) iTable.button("添加载荷", Styles.cleart, () -> showUpdate(group, true));
+            iTable.button(icon -> {
+                icon.add("物品");
+                if(group.items != null){
+                    icon.image(group.items.item.uiIcon).padLeft(6f);
+                    icon.add("" + group.items.amount).padLeft(6f);
+                }else{
+                    icon.image(Icon.effect).padLeft(6f);
+                }
+
+            }, Styles.cleart, () -> showItems(group));
+        }
+
+        if(eTable != null){
+            eTable.clear();
+            eTable.add(Core.bundle.get("waves.filter.effect") + ":");
+            eTable.button(filterEffect != null && filterEffect != StatusEffects.none ?
+            new TextureRegionDrawable(filterEffect.uiIcon) :
+            Icon.logic, () -> showEffect(null)).padLeft(30f).size(60f);
+        }
+
+        if(uTable != null && group != null && group.payloads != null){
+            uTable.clear();
+            uTable.left();
+            uTable.defaults().pad(3);
+            uTable.table(units -> {
+                int i = 0;
+                for(UnitType payl : group.payloads){
+                    if(i < maxVisible || expandPane) units.table(Tex.button, s -> {
+                        s.image(payl.uiIcon).size(45f);
+                        s.button(Icon.cancelSmall, Styles.emptyi, () -> {
+                            group.payloads.remove(payl);
+                            updateIcons(group);
+                            buildGroups();
+                        }).size(20f).padRight(-9f).padLeft(-6f);
+                    }).pad(2).margin(12f).fillX();
+                    if(++i % 10 == 0) units.row();
+                }
+            });
+            uTable.table(b -> {
+                b.defaults().pad(2);
+                if(group.payloads.size > 1) b.button(Icon.cancel, () -> {
+                    group.payloads.clear();
+                    updateIcons(group);
+                    buildGroups();
+                }).tooltip("@clear").row();
+                if(group.payloads.size > maxVisible) b.button(expandPane ? Icon.eyeSmall : Icon.eyeOffSmall, () -> {
+                    expandPane = !expandPane;
+                    updateIcons(group);
+                }).size(45f).tooltip(expandPane ? "@server.shown" : "@server.hidden");
+            }).padLeft(6f);
+        }
+    }
+
+    void numField(String text, Table t, Intc cons, Intp prov, int maxLength){
+        if(!text.isEmpty()) t.add(text);
+        t.field(prov.get() + "", TextFieldFilter.digitsOnly, input -> {
+            if(Strings.canParsePositiveInt(input)){
+                cons.get(!input.isEmpty() ? Strings.parseInt(input) : 0);
+                buildGroups();
+            }
+        }).maxTextLength(maxLength);
+    }
+
+    void clearFilter(){
+        filterHealth = filterAmount = filterAmountWave = 0;
+        filterStrict = filterHealthMode = false;
+        filterBegin = filterEnd = -1;
+        filterEffect = StatusEffects.none;
+    }
+
+    enum Sort{
+        begin(Structs.comps(Structs.comparingFloat(g -> g.begin), Structs.comparingFloat(g -> g.type.id))),
+        health(Structs.comps(Structs.comparingFloat(g -> g.type.health), Structs.comparingFloat(g -> g.begin))),
+        type(Structs.comps(Structs.comparingFloat(g -> g.type.id), Structs.comparingFloat(g -> g.begin)));
+
+        static final Sort[] all = values();
+
+        final Comparator<SpawnGroup> sort;
+
+        Sort(Comparator<SpawnGroup> sort){
+            this.sort = sort;
+        }
+    }
+
+    void updateWaves(){
+        graph.groups = groups;
+        graph.from = start;
+        graph.to = start + displayed;
+        graph.rebuild();
+    }
+
+    void arcSpawner(){
+        BaseDialog dialog = new BaseDialog("ARC-随机生成器");
+
+        Table table = dialog.cont;
+        Runnable[] rebuild = {null};
+        rebuild[0] = () -> {
+
+            table.clear();
+            table.table(c -> {
+                c.table(ct -> {
+                    ct.add("难度：").width(100f);
+                    ct.field(difficult + "", text -> difficult = Float.parseFloat(text)).valid(Strings::canParsePositiveFloat).width(200f);
+                }).width(300f);
+                c.row();
+                c.button("单位设置", showUnitSelect ? Icon.upOpen : Icon.downOpen, Styles.togglet, () -> {
+                    showUnitSelect = !showUnitSelect;
+                    rebuild[0].run();
+                }).fillX().minWidth(400f).row();
+                c.row();
+                if(showUnitSelect){
+                    c.table(list -> {
+                        for(UnitType unit : content.units()){
+                            if(unit.internal) continue;
+                            list.button(unit.emoji(), flatToggleMenut, () -> {
+                                if(spawnUnit.contains(unit)) spawnUnit.remove(unit);
+                                else spawnUnit.add(unit);
+                                rebuild[0].run();
+                            }).tooltip(unit.localizedName).checked(spawnUnit.contains(unit)).size(50f);
+                            if(list.getChildren().size % 8 == 0) list.row();
+                        }
+                    }).row();
+                    c.table(ct -> {
+                        ct.add("环境").width(50f);
+                        ct.button("Surplus", flatToggleMenut, () -> {
+                            surplusUnit = !surplusUnit;
+                            for(UnitType unit : allowUnit.copy().retainAll(unitType -> !(unitType instanceof ErekirUnitType))){
+                                filterUnit(unit, surplusUnit);
+                            }
+                            rebuild[0].run();
+                        }).checked(surplusUnit).width(120f);
+                        ct.button("Erekir", flatToggleMenut, () -> {
+                            ErekirUnit = !ErekirUnit;
+                            for(UnitType unit : allowUnit.copy().retainAll(unitType -> unitType instanceof ErekirUnitType)){
+                                filterUnit(unit, ErekirUnit);
+                            }
+                            rebuild[0].run();
+                        }).checked(ErekirUnit).width(120f);
+                    });
+                    c.row();
+                    c.table(ct -> {
+                        ct.add("兵种").width(50f);
+                        ct.button("空军", flatToggleMenut, () -> {
+                            flyingUnit = !flyingUnit;
+                            for(UnitType unit : allowUnit.copy().retainAll(unitType -> unitType.flying)){
+                                filterUnit(unit, flyingUnit);
+                            }
+                            rebuild[0].run();
+                        }).checked(flyingUnit).width(70f);
+                        ct.button("海军", flatToggleMenut, () -> {
+                            navalUnit = !navalUnit;
+                            for(UnitType unit : allowUnit.copy().retainAll(unitType -> unitType.naval)){
+                                filterUnit(unit, navalUnit);
+                            }
+                            rebuild[0].run();
+                        }).checked(navalUnit).width(70f);
+                        ct.button("支援", flatToggleMenut, () -> {
+                            supportUnit = !supportUnit;
+                            for(UnitType unit : allowUnit.copy().retainAll(unitType -> unitType.controller instanceof BuilderAI || unitType.controller instanceof MinerAI || unitType.controller instanceof RepairAI)){
+                                filterUnit(unit, supportUnit);
+                            }
+                            rebuild[0].run();
+                        }).checked(supportUnit).width(70f);
+                    });
+                }
+                c.row();
+                c.button("生成！", () -> {
+                    groups.clear();
+                    groups = Waves.generate(difficult / 10, new Rand(), flyingUnit, navalUnit, supportUnit);
+                    updateWaves();
+                    buildGroups();
+                }).width(300f);
+            });
+
+        };
+        rebuild[0].run();
+        dialog.addCloseButton();
+        dialog.show();
+        ui.announce("功能制作中..请等待完成\n[orange]目前可调整：难度|空|海|辅，其他功能均无效", 15);
+    }
+
+    private void filterUnit(UnitType unit, boolean filter){
+        if(filter && !spawnUnit.contains(unit)){
+            spawnUnit.add(unit);
+        }else if(!filter && spawnUnit.contains(unit)){
+            spawnUnit.remove(unit);
+        }
+    }
+}
diff --git a/core/src/mindustryX/features/ui/BlockSelectDialog.java b/core/src/mindustryX/features/ui/BlockSelectDialog.java
new file mode 100644
index 0000000000000000000000000000000000000000..4af00d9add5776e8d966880336121b05722e73b0
--- /dev/null
+++ b/core/src/mindustryX/features/ui/BlockSelectDialog.java
@@ -0,0 +1,65 @@
+package mindustryX.features.ui;
+
+import arc.func.*;
+import arc.scene.style.*;
+import arc.scene.ui.layout.*;
+import arc.struct.*;
+import mindustry.graphics.*;
+import mindustry.ui.*;
+import mindustry.ui.dialogs.*;
+import mindustry.world.*;
+import mindustry.world.meta.*;
+
+import static mindustry.Vars.*;
+
+//move from mindustry.arcModule.ui.dialogs.BlockSelectDialog
+public class BlockSelectDialog extends BaseDialog{
+    private final Boolf<Block> condition;
+    private final Cons<Block> cons;
+    private final Boolf<Block> checked;
+    private final boolean autoHide;
+    private String searchBlock = "";
+    private final Table blockTable = new Table();
+
+    public BlockSelectDialog(Boolf<Block> condition, Cons<Block> cons, Boolf<Block> checked){
+        this(condition, cons, checked, true);
+    }
+
+    public BlockSelectDialog(Boolf<Block> condition, Cons<Block> cons, Boolf<Block> checked, boolean autoHide){
+        super("方块选择器");
+        this.condition = condition;
+        this.cons = cons;
+        this.checked = checked;
+        this.autoHide = autoHide;
+        cont.pane(td -> {
+            td.field("", t -> {
+                searchBlock = !t.isEmpty() ? t.toLowerCase() : "";
+                rebuild();
+            }).maxTextLength(50).growX().get().setMessageText("搜索...");
+            td.row();
+            td.add(blockTable);
+        });
+        rebuild();
+        addCloseButton();
+    }
+
+    private void rebuild(){
+        blockTable.clear();
+        blockTable.table(td -> {
+            Seq<Block> blocks = content.blocks().select(block -> condition.get(block) && (searchBlock.isEmpty() || block.name.contains(searchBlock) || block.localizedName.contains(searchBlock)) && (block.privileged || AdvanceToolTable.allBlocksReveal || !block.isHidden())).sort(block -> block.group.ordinal());
+            Seq<BlockGroup> blockGroups = blocks.map(block -> block.group).distinct();
+            blockGroups.each(blockGroup -> {
+                td.row();
+                td.add(blockGroup.toString()).row();
+                td.image().color(Pal.accent).fillX().row();
+                td.table(ttd -> blocks.select(block1 -> block1.group == blockGroup).each(block1 -> {
+                    ttd.button(new TextureRegionDrawable(block1.uiIcon), Styles.cleari, iconSmall, () -> {
+                        cons.get(block1);
+                        if(autoHide) hide();
+                    }).tooltip(block1.localizedName).pad(3f).checked(b -> checked.get(block1)).size(50f);
+                    if(ttd.getChildren().size % 10 == 0) ttd.row();
+                }));
+            });
+        });
+    }
+}
